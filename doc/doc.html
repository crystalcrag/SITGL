<!DOCTYPE html>

<html>
<head>
  <title>SIT Programming Manual</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body>
<div id="toc">
<a class="sub1" href="#introduction"><span>Introduction</span></a>
<a class="sub1" href="#history"><span>History</span></a>
<a class="sub1" href="#conventions"><span>Conventions</span></a>
<a class="sub1" href="#gettingstarted"><span>Getting started</span></a>
  <a class="sub2" href="#includes">Includes</a>
  <a class="sub2" href="#immode">Immediate mode</a>
  <a class="sub2" href="#entry">Entry point</a>
  <a class="sub2" href="#sitglinit">SITGL initialization</a>
  <a class="sub2" href="#create">Creating the interface</a>
  <a class="sub2" href="#eventloop">Main event loop</a>
  <a class="sub2" href="#compiling">Compiling the library</a>

<a class="sub1" href="#integration"><span>Integration</span></a>
  <a class="sub2" href="#SIT_Init">SIT_Init</a>
  <a class="sub2" href="#forwardevt">Event forwarding</a>
  <a class="sub2" href="#SIT_RenderNodes">SIT_RenderNodes</a>
  <a class="sub2" href="#windows">Operating system (Windows)</a>

<a class="sub1" href="#nanovg"><span>nanovg</span></a>
 <a class="sub2" href="#NVGUBO">Uniform Buffer Object location</a>
 <a class="sub2" href="#NVGcaveats">Caveats</a>
 <a class="sub2" href="#NVGoffscreen">Off-screen rendering</a>
 <a class="sub2" href="#NVGext">Extensions</a>

<a class="sub1" href="#geometry"><span>Controls and Geometry</span></a>
 <a class="sub2" href="#hierarchy">Creating the hierarchy</a>
 <a class="sub2" href="#alter">Manipulating the hierarchy</a>
 <a class="sub2" href="#placement">Placing controls</a>
 <a class="sub2" href="#attachment">Attachment specification</a>
 <a class="sub2" href="#abbreviation">Abbreviation</a>
 <a class="sub2" href="#otherattrs">Other attributes</a>
 <a class="sub2" href="#summary">Summary</a>
 <a class="sub2" href="#dialogsize">Relation with dialog size</a>
 <a class="sub2" href="#dynamic">Dynamic behavior</a>
 <a class="sub2" href="#pitfalls">Pitfalls</a>

<a class="sub1" href="#serialization"><span>Reducing code overhead</span></a>
 <a class="sub2" href="#serialized">The serialized model</a>
 <a class="sub2" href="#enums">Using enumeration values</a>
 <a class="sub2" href="#nestedtags">Nested tags</a>
 <a class="sub2" href="#example">Example</a>

<a class="sub1" href="#events"><span>Events/callbacks</span></a>
 <a class="sub2" href="#evtreg">Registration</a>
 <a class="sub2" href="#evttype">Event types</a>
 <a class="sub2" href="#evtredirect">Redirecting events</a>
 <a class="sub2" href="#evtsummary">Summary of events and call data</a>
 <a class="sub2" href="#evtglobal">Global events</a>

<a class="sub1" href="#css"><span>CSS</span></a>
 <a class="sub2" href="#selectors">Selectors</a>
 <a class="sub2" href="#csstypes">Datatypes</a>
  <a class="sub3" href="#strings">Strings</a>
  <a class="sub3" href="#cssdim">Dimension</a>
  <a class="sub3" href="#csscolor">Colors</a>
  <a class="sub3" href="#cssangle">Angles</a>
  <a class="sub3" href="#cssuri">URI</a>
 <a class="sub2" href="#cssboxshadow">Box shadow</a>
 <a class="sub2" href="#cssbackground">Background properties</a>
 <a class="sub2" href="#cssborder">Border properties</a>
 <a class="sub2" href="#cssborderimg">Border image properties</a>
 <a class="sub2" href="#cssoutline">Outline properties</a>
 <a class="sub2" href="#csstextshadow">Text shadow</a>
 <a class="sub2" href="#csstext">Text/font properties</a>
 <a class="sub2" href="#cssothers">Other properties</a>

<a class="sub1" href="#widgets"><span>Widgets/Controls</span></a>
 <a class="sub2" href="#SIT_WIDGET">SIT_WIDGET</a>
 <a class="sub2" href="#SIT_APP">SIT_APP</a>
 <a class="sub2" href="#SIT_DIALOG">SIT_DIALOG</a>
 <a class="sub2" href="#SIT_LABEL">SIT_LABEL</a>
 <a class="sub2" href="#SIT_BUTTON">SIT_BUTTON</a>
 <a class="sub2" href="#SIT_FRAME">SIT_FRAME</a>
 <a class="sub2" href="#SIT_EDITBOX">SIT_EDITBOX</a>
  <a class="sub3" href="#edittypes">Edit types</a>
  <a class="sub3" href="#editcss">CSS styling</a>
  <a class="sub3" href="#editmem">Memory management</a>
  <a class="sub3" href="#editprop">Editbox properties</a>
  <a class="sub3" href="#editevents">Events</a>
  <a class="sub3" href="#editkbd">Keyboard shortcuts</a>

 <a class="sub2" href="#SIT_COMBOBOX">SIT_COMBOBOX</a>
 <a class="sub2" href="#SIT_LISTBOX">SIT_LISTBOX</a>
  <a class="sub3" href="#listreport">Managing columns</a>
  <a class="sub3" href="#listitems">Managing items</a>
  <a class="sub3" href="#listembed">Embedding controls</a>
  <a class="sub3" href="#listicon">Icon view</a>
  <a class="sub3" href="#listcat">Category separator</a>
  <a class="sub3" href="#listprop">Listbox properties</a>
  <a class="sub3" href="#listevents">Events</a>
  <a class="sub3" href="#listkbd">Keyboard shortcuts</a>

 <a class="sub2" href="#SIT_CANVAS">SIT_CANVAS</a>
 <a class="sub2" href="#SIT_SCROLLBAR">SIT_SCROLLBAR</a>
 <a class="sub2" href="#SIT_SLIDER">SIT_SLIDER</a>
 <a class="sub2" href="#SIT_PROGRESS">SIT_PROGRESS</a>
 <a class="sub2" href="#SIT_TAB">SIT_TAB</a>
 <a class="sub2" href="#SIT_TOOLTIP">SIT_TOOLTIP</a>
 <a class="sub2" href="#SIT_TOOLTIP">SIT_HTMLTAG</a>
 <a class="sub2" href="#SIT_FILESELECT">SIT_FILESELECT</a>
 <a class="sub2" href="#SIT_DIRSELECT">SIT_DIRSELECT</a>

<a class="sub1" href="#miscfunc"><span>Miscellaneous functions</span></a>

<a class="sub1" href="#extractrl"><span>Extra widgets</span></a>
 <a class="sub2" href="#propfactory">Property factory</a>
 <a class="sub2" href="#filechooser">File chooser</a>
 <a class="sub2" href="#colorchooser">Color chooser</a>
 <a class="sub2" href="#vt100">Console window</a>
  <a class="sub3" href="#vt100init">Initialization</a>
  <a class="sub3" href="#vt100prop">Custom properties</a>
  <a class="sub3" href="#vt100css">Styling</a>
  <a class="sub3" href="#vt100kbd">Keyboard shortcuts</a>

<a class="sub1" href="#i18n"><span>Internationalization</span></a>
 <a class="sub2" href="#localeinfo">Locale information</a>
 <a class="sub2" href="#msgextract">Automating message extraction</a>
 <a class="sub2" href="#loadmsgs">Loading translation file</a>
 <a class="sub2" href="#advi18n">Advanced features</a>

<a class="annex sub1" href="#annexA"><span>UtilityLib API</span></a>
 <a class="annex sub2" href="#doublelink">Double-linked list</a>
 <a class="annex sub2" href="#dosaccess">DOS access</a>
 <a class="annex sub2" href="#multithread">Multi-thread</a>
 <a class="annex sub2" href="#timer">Timer functions</a>
 <a class="annex sub2" href="#utility">Utility functions</a>
 <a class="annex sub2" href="#inifile">INI file</a>

<a class="annex" href="#annexB"><span>stb_image API</span></a>
<a class="annex sub1" href="#annexC"><span>Advanced rendering API</span></a>
 <a class="annex sub2" href="#composite">Composited rendering</a>
 <a class="annex sub2" href="#rendernode">Rendering individual widget</a>

<a class="annex" href="#annexD"><span>Internal: border rendering</span></a>

<br>
<br>
</div>

<div id="content">
<h1>SITGL Programming Manual</h1>

<p id="tagline">Simple Interface Toolkit - OpenGL edition</p>

<div id="abstract"><u>Abstract:</u>
<p>This purpose of this library is to display and manage interaction with controls common to typical desktop
environment: buttons, checkboxes, labels, text edit area, ... built on top of the OpenGL API, using an
immediate mode rendering/interaction loop. Interface between the operating system and this library must be
handled by another layer (typically: SDL, GLFW, SFML, ...). Typical usage for this library is to be integrated
into a video game engine.

<p><b>Pre-requisite</b>: basic knowledge of OpenGL, advanced knowledge of the C programming language
and decent knowledge adout <a href="https://www.w3.org/TR/CSS22/">CSS</a>.
</div>

<p id="auth">Written by T.Pierron, September 2020</p>

<h2 id="introduction">Introduction</h2>

<p>Welcome to <b>SITGL programmer's manual</b>, a comprehensive
guide through the Simple Interface Toolkit OpenGL edition: a simple framework to build
graphical user interface that will be rendered using OpenGL.

<p>This library is loosely based on a <b>similar framework</b> called simply SIT and follows the same
principles and general ideas: the documentation for SIT also largely applies to this framework. Reading
this manual is not necessary however, since this one will cover almost everything there is to know about SITGL.

<p>This library and its API is <b>written in C</b> and care have been taken to keep it as simple as
possible (that is: as few functions as possible) so that it should be relatively easy to access
this library from another language (as long as it supports a C ABI, which almost any language
worth its salt should).

<p>The API has also been carefully designed to be a good compromise between productivity, minimal
footprint and ease of integration:
<ul>
  <li><b>Productivity</b>: write as little code as possible, while still allowing you freedom to build
  complex interface.
  <li><b>Small footprint</b>: the first point being a nebulous target, a line had to be drawn in
  order to keep the project away from feature creep: only basic controls with room to build more complex
  one from this basic building blocks.
  <li><b>Ease of integration</b>: these kind of libraries always require some boilerplate code
  in order to integrate it with existing system. This part has been designed to limit the amount of
  code needed to get something on the screen, while still allowing a decent amount of freedom in the
  way rendering is done (at the cost of more boilerplate, the more complex your needs are).
</ul>

<p>Inspiration for this library comes from various frameworks from the industry than spans several
decades: the API of SITGL is strongly inspired by <a href="https://en.wikipedia.org/wiki/X_Toolkit_Intrinsics">X-Intrinsics</a>,
layout of the controls within forms and screen is inspired by <a href="https://en.wikipedia.org/wiki/Motif_%28software%29">Motif</a>
<tt>XmForm</tt> widget, and theming is done using 99% standard-compliant CSS.

<p>That being said, OpenGL and user-interface will always imply a decent amount of boilerplate code
and careful consideration on how to properly use this library. Care has been taken for this to be as
painless as possible, but don't expect miraculously dropping a few files on your project and start
coding your interface right after. You'll have to read this documentation further, at least until
chapter 11: controls.



<h2 id="history">History</h2>

<p class="note">This part can be skipped for those who would like to dive directly in this framework.
It will explain how this library came into birth.

<p>As it is often the case with these projects, it usually starts with a need to add an user interface
on top of an OpenGL application. For something as mundane, you might think that there would a lot of
choices to choose from. But there were 3 aspects that were critical in my eyes, to consider using any
potential solution: <b>productivity</b>, <b>ease of integration</b> and <b>small footprint</b> (around
300K). One aspect that I could live by if it were not that optimal, was performance.

<p>Having spent a decent chunk of my career developing user interfaces, I was particularly aware of how
much of a drag, a poorly designed API can be on your productivity. Designing a decent user-interface
is already a complex and not particularly fun process, the last thing you want on top of that is fighting
against the API.

<p>During these years, I had time to developed a lot of <b>basic building blocks</b> (layout routines,
drawing, event system, documentation, ...) related to user interface. At this point I thought: why not
gather all those blocks into a single library?

<p><b>Among those blocks</b> were SIT: the Simple Interface Toolkit, which, to this day, I still use and
where the "Simple" of its name is not just an empty word: among all the user interface libraries I
used over the years (Gadtools AmigaOS, Xaw, Motif, GTK, Qt, AWT, Win32 common controls, MFC, HTML/CSS)
it is one of the most productive and easiest to pick up/configure. Also, having eaten my own dog food
all these years, gave me ample time to be sure this framework is reasonably stable and cover the needs
of a typical GUI application in practice and not just on paper.

<p>The <b>main problem with SIT</b> is that the rendering/interaction was handled by the Win32 common controls
libraries of Windows (comctl32.dll and comdlg32.dll). While it is relatively easy to mix OpenGL
context and common controls, I wanted something that can be used in part of the inner rendering
loop of the hosting application and especially having the possibility to theme the controls themselves.

<p>While technically, it is possible to do this with Win32 controls, in practice it is way too much
effort, and to add insult to injury, all those efforts would not have been portable.

<p><b>Another huge building block</b> I had laying around was a nearly complete library used to parse
HTML 5/CSS 2.1, and produce PDF documents based on the CSS Paged media specification. This library
did not support HTML form elements, but I thought this part would be simple enough, that it would
take little to no time to implement most of the form elements.

<p>This library definitively wasn't a toy: it has been used (and still is as of writing this) on some
production server to generate hundreds of not-so-trivial PDF documents every day. After hacking this
library for a few weeks, I managed to get the ACID2 test working:

<div class="image">
  <img src="images/nanovg-acid2.png">
</div>

<p>Not too bad! But I quickly realized that there were some major road blocks coming ahead:

<ul>
  <li>Achieving ACID2 compliance means that <b>the code was not trivial</b>: you need a complete block/inline/floats
  model working, including correct drawing order (z-index, float, blocks, inline). Code for laying out tables
  was bizantine and boiled down to a never ending parade of edge cases (good luck trying to optimize that part).
  Correctly implementing margin collapse proved to be extremely difficult.

  <li><b>Optimizing</b> all of this would have been a nightmare: not impossible, but the amount of code
  needed would have been staggering, especially since the code related to element layout that was not trivial
  at all.

  <p>For example: the rendering order in this library was done by putting all the elements that
  draw something on the screen/page into an array, then applying the libc <tt>qsort()</tt> function
  on it, using a very complex function that can give an order given two elements. For a library that
  generates static documents, this is perfectly acceptable. For an user interface library where lots
  of changes can happen anywhere, this is far from ideal.

  <li><b>CSS positioning</b> has always been a PITA. Flexbox and CSS grid models have eased the pain,
  but neither of these were supported by this library. Supporting these features would have required
  large chunk of code to be added to an already complex code base. Supporting these features efficiently
  would have required even more years of work. Without these, you were pretty much stuck with table layout,
  probably nested to hell and back, CPU usage be damned if any changes occur anywhere. Although with the
  computing power available on a modern system, this is not as much of a problem as it seems.

  <li>And even if I managed to miraculously mitigate all of these issues, there are still some <b>use
  case that are ridiculously complex</b>/next to impossible to implement without some deep access to
  the document object model. Implementing even a trimmed down version of a DOM was way above my motivation/pain
  limit.

  <p>For example: try to make a list with a header (<tt>&lt;thead&gt;</tt>, with multiple columns) where
  only the body (<tt>&lt;tbody&gt;</tt>) can have a vertical scroll bar, while keeping everything aligned
  and flexible (i.e: no hardcoded dimension). Something that can be trivially done with almost any toolkit
  of the past 30 years.

  <li>And even after doing all of these, I still had to implement the <b>form elements</b> (buttons,
  text edit, ...).
</ul>

<p>Still, my goto technology whenever I had to do an user interface mock-up has been HTML/CSS for a long
time at this point. Despite its shortcomings, CSS is still a very powerful technology with a reasonable
learning curve and not the least, is the fact it has been thoroughly documented.

<p>At this point, I started to realized that CSS positioning was going to be a huge problem. On the other
hand, positioning elements with SIT is extremely easy, somewhat efficient (relatively easy to recompute
only parts of the interface if something change) and not the least, I also had an implementation and a
documentation.

<p>So why not combining the best of both world: use the expressiveness of CSS to manage the appearance,
while creation/layout/update will be handled by SIT. The only work left at this point was to glue
the different parts of these two libraries and add the few missing bits (control logic).

<p>A couple of months of hacking, and SITGL was born.

<h2 id="conventions">Conventions</h2>

<p>Before you read following sections, there are some facts that you must keep in mind,
since they usually won't be stated anywhere else:</p>

<ul>
  <li>The encoding used by this library is <strong>UTF-8</strong>. Every string
  transmitted must be encoded in this charset, and every string you'll get from
  it will be encoded in UTF-8.

  <ul>
	<li><strong>Rationale</strong>: UTF-8 is ASCII compatible, least resistance path
	to unicode compliance, and is not endianess-sensitive.</li>
	<li><strong>Cons</strong>: String modification, especially in C, can be a PITA.
	Sometimes it is easier to temporarily convert the string in UTF-16.</li>
  </ul>

  <li>This library makes use of mandatory <strong>namespace</strong>, using traditional
  underscore-separated
  prefix common in C. "SIT" is the basic namespace, and to be a little more lexical
  auto-completeness friendly, another letter is used to distinguish different kind of symbols.
  Thus if your IDE is setup to trigger auto-completion after typing 4 letters, it will
  filter unwanted symbols automatically:

  <ul>
	<li><tt class="o dt">'_'</tt> : Functions and datatypes (i.e: <tt>SIT_CreateWidget()</tt>,
	<tt>SIT_Accel</tt>).
	<li><tt class="o dt">'_'</tt> : Tag names (e.g: <tt>SIT_Title</tt>, ...)
	<li><tt class="o dt">'V'</tt> : Tag values (e.g: <tt>SITV_AttachForm</tt>, <tt>SITV_AttachWidget</tt>, ...)
	<li><tt class="o dt">'E'</tt> : Events (e.g: <tt>SITE_OnClick</tt>, <tt>SITE_OnPaint</tt>, ...)
	<li><tt class="o dt">'K'</tt> : Virtual keys (<tt>SITK_Enter</tt>, <tt>SITK_Space</tt>, ...)
	<li>A few more specialized prefixes exist like <tt>GFX_</tt> for canvas
	related API, <tt>SITTB_</tt> for toolbar, <tt>SITOM_</tt> for OnMouse events...
  </ul>

  <li>Unless explicitly stated, every objects given to this library <b>will not be modified</b>, nor be
  taken ownership. That means if you allocate a string, you'll have to free it yourself. You can
  use local variables or static strings and be assured the library will not generate invalid memory
  access.

  <li>The following type definitions are used everywhere and thus won't be explained again.
  Keep them in mind, there are not that many:

  <ul>
	<li><tt class="t dt">STRPTR</tt>: A shortcut for <tt>char *</tt>. This library does not use the const specifier
	(because most of the API makes use of vararg).
	<li><tt class="t dt">ULONG</tt>: typedef for <tt>unsigned long</tt>.
	<li><tt class="t dt">APTR</tt>: alias for <tt>void *</tt>, it means Absolute Pointer.
	<li><tt class="t dt">Bool</tt>: enumeration that can take the value of <tt>True</tt> (1) or <tt>False</tt> (0).
	<li><tt class="t dt">SIT_Widget</tt>: opaque type that identify a control within this library.
  </ul>

  <li>Minimal version of OpenGL required to use this library is v3. You'll also need a C99 compiler in
  order to build this library.
</ul>

<p>If you are using the <b>pre-built binaries for Windows</b>, keep in mind that those were built with
<a href="http://mingw.org/">MinGW</a>, <tt>gcc</tt> 4.7.1, linked against the <tt>msvcrt.dll</tt> from
Windows (and since this library is written entirely in C, you don't have to worry about the C++ runtime).
If you are using this with a different compiler (especially one with a different C runtime), you'll have
to strictly avoid cross-boundary memory deallocation: <b>if an object is allocated by one runtime,
it must be freed by the same runtime</b>.

<p>Other than the C runtime, this library has no other dependencies.



<h2 id="gettingstarted">Getting started</h2>

<p>This section will present a broad overview of the framework look'n feel and how to setup your tool
chain to get started.

<p>Like stated in the introduction, this library is usually only a tiny component of a whole application.
<b>Its purpose is to draw controls</b> and make interaction with those controls possible with the mouse and/or
keyboard. Anything else needs to be handled yourself or by another library. One of the <b>most critical
part missing</b> is the interface between this library and the operating system.

<p>While <b>it is possible to use native operating system call</b>, you'll quickly realize that doing so is
extremely tedious and require arcane knowledge of API way past their prime. If you are interested,
in the "<tt>examples</tt>" directory of the source distribution of this library, you can find a working
program to use this library with nothing more than the Win32 API (<tt>exampleWIN32.c</tt>).

<p>The more likely scenario is to <b>use an existing framework</b> for this: there are a lot of high quality
framework dedicated to this task, that's why it was pointless to (badly) reinvent the wheel for this
library, even if it means more documentation to read. To name a few: <a href="http://libsdl.org/download-1.2.php">SDL1</a>,
<a href="http://libsdl.org/">SDL2</a> or <a href="https://www.glfw.org/">GLFW</a>. SDL in particular
is extremely stable, have good documentation, have been ported to almost anything that can display
raster graphics (consoles, mobile phones, Windows, Linux, Mac OS X, ...) and have a pretty straightforward
API.

<p>In this same "<tt>examples</tt>" folder, you'll find source code for interfacing this library with SDL1,
SDL2 and GLFW. These examples are a much better starting point, if you want to begin a project from scratch.

<p>No programming guide can pretend to be complete without showing what a "<b>Hello world</b>" program might
look like, here using the SDL1 framework:

<pre id="helloworld"><com>/*
 * exampleSDL.c : small example showing how to integrate SITGL with SDL
 *
 * Written by T.Pierron, May 2020
 */</com>

<def>#include </def><val>&lt;stdio.h&gt;</val><def>
#include </def><val>&lt;SDL/SDL.h&gt;</val><def>
#include </def><val>"nanovg.h"</val><def>
#include </def><val>"SIT.h"</val>

<def>#define</def><inc> SCREENWIDTH  500</inc><def>
#define</def><inc> SCREENHEIGHT 200</inc>
<type>int</type> main(<type>int</type> nb, <type>char</type> * argv[])
{
	SDL_Surface * screen;
	SDL_Event     event;
	SIT_Widget    app;

	<kwd>if</kwd> (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) &lt; <val>0</val>)
		<kwd>return</kwd> <val>1</val>;

	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, <val>1</val>);

	screen = SDL_SetVideoMode(SCREENWIDTH, SCREENHEIGHT, <val>32</val>, SDL_HWSURFACE | SDL_GL_DOUBLEBUFFER | SDL_OPENGL);
	<kwd>if</kwd> (screen == <val>NULL</val>) {
		fprintf(<val>stderr</val>, <val>"failed to set video mode, aborting.</val><spe>\n</spe><val>"</val>);
		<kwd>return</kwd> <val>1</val>;
	}
	SDL_WM_SetCaption(<val>"SITGL Test"</val>, <val>"SITGL Test"</val>);

	app = SIT_Init(SIT_NVG_FLAGS, SCREENWIDTH, SCREENHEIGHT,
		<val>"html { font-size: 30px; background: #eee; color: black; padding: 20px }"</val>, <val>0</val>);

	<kwd>if</kwd> (app == <val>NULL</val>)
	{
		SIT_Log(SIT_ERROR, <val>"could not initialize SITGL: <spe>%s</spe>.<spe>\n</spe>"</val>, SIT_GetError());
		<kwd>return</kwd> <val>1</val>;
	}

	SIT_SetValues(app,
		SIT_RefreshMode, SITV_RefreshAsNeeded,
		SIT_AddFont,     <val>"sans-serif"</val>, <val>"Georgia"</val>,
		<val>NULL</val>
	);

	SIT_CreateWidgets(app, <val>"&lt;label name=hello title='Hello, world!'&gt;"</val>);

	SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
	SDL_EnableUNICODE(<val>1</val>);
	<com id="render">/* set high precision timer (this function comes from SITGL) */</com>
	FrameSetFPS(<val>50</val>);

	<kwd>while</kwd> (app)
	{
		<kwd>while</kwd> (SDL_PollEvent(&amp;event))
		{
			<kwd>switch</kwd> (event.type) {
			<kwd>case</kwd> SDL_MOUSEBUTTONDOWN:
				SIT_ProcessClick(event.button.x, event.button.y, event.button.button-<val>1</val>, <val>1</val>);
				<kwd>break</kwd>;
			<kwd>case</kwd> SDL_MOUSEBUTTONUP:
				SIT_ProcessClick(event.button.x, event.button.y, event.button.button-<val>1</val>, <val>0</val>);
				<kwd>break</kwd>;
			<kwd>case</kwd> SDL_MOUSEMOTION:
				SIT_ProcessMouseMove(event.motion.x, event.motion.y);
				<kwd>break</kwd>;
			<kwd>case</kwd> SDL_QUIT:
				app = <val>NULL</val>;
			<kwd>default</kwd>:
				<kwd>break</kwd>;
			}
		}

		<com id="render">/* application rendering goes here ... */</com>

		<com>/* update and render */</com>
		<kwd>if</kwd> (SIT_RenderNodes(FrameGetTime()))
			SDL_GL_SwapBuffers();
		<com>/* will yield the CPU if there is enough time left */</com>
		FrameWaitNext();
	}

	SIT_Nuke(SITV_NukeAll);
	SDL_FreeSurface(screen);
	SDL_Quit();

	<kwd>return</kwd> <val>0</val>;
}</pre>

<p><b>This example might seem overwhelming at first</b>, but don't worry, everything will be eventually
explained in this document. To compile this program, you'll have to either compile the <tt>SITGL.dll</tt> library
by yourself or use a pre-compiled binary package (recommended).

<p>Then to get a binary from this source, it can be simply done by using the following command
line (here, using <tt>MinGW</tt>):
<pre>gcc.exe -Wall example.c -I<em>&lt;SITGL_includes&gt;</em> -I<em>&lt;SDL_includes&gt;</em> SDL.dll SITGL.dll -o example.exe</pre>

<p>One of the advantage of using <tt>MinGW</tt> is that DLL files can be used as linkable objects. They
must be available in the source directory though, but since the application will be built here, you'll
also need those DLLs to run the program. The program should compile without errors or warnings, and it
should look like this if you try to run it:

<div class="image">
  <img src="images/hello-world.png">
</div>

<p>Not very impressive, but you'll see that there is not that much missing to create a normal user interface.

<p>If this is your first contact with this library, it is strongly suggested you <b>try to compile and run this
program</b> before reading this document further. It will ensure that your toolchain is working and have a base
where you can iterate on.

<p><tt>SITGL.dll</tt> has no external dependencies: everything is <b>self-contained</b> within the library itself,
therefore it will not introduce undefined symbols on the linking phase, which makes its integration
slightly simpler.

<p>If you manage to get this program running, the explanations below will give a brief overview of what
each part of the source code is doing:

<h3 id="includes"><span>Includes</span></h3>

<p>Include files for SITGL are pretty simple: there are only 4 include files:
<ul>
  <li><tt>SIT.h</tt>: the main and <b>only mandatory include</b> in order to use this library. Declarations in
  this file will allow you to create and manipulate your user interface.

  <li><tt>UtilityLibLite.h</tt>: this file is automatically included by <tt>SIT.h</tt>. It contains some
  <b>basic utility functions</b>, like double-linked list, DOS access (directory scan, delete files/dir,
  ...) with UTF-8 support, string manipulation, internationalization... It will be explained in
  <a href="#annexA">annex A: UtilityLib API</a>.

  <p>As its name suggest, <b>it is a strip down version</b> of a much larger library, even though most of the
  parts that have been removed are not that essential for a typical application (like expression parsing,
  CGI query parsing, encodings other than UTF-8, ...).

  <li><tt>nanovg.h</tt>: developed by Mikko Memononen, it is a <b>2D drawing library built on top of OpenGL</b>.
  This is the library that is responsible for drawing everything from <tt>SITGL</tt>. All of its API has been
  exported and can be accessed by the application linking against <tt>SITGL.dll</tt>. It is even possible to only use
  <tt>nanovg</tt> to render graphics, and never use <tt>SITGL</tt>, although if you don't intend to use
  the full extend of this library, you might as well integrate <tt>nanovg</tt> directly into your application
  (it is very easy to do).

  <p><span class="n">Note</span>: <tt>nanovg</tt> itself uses <tt>stb_truetype.h</tt> for font rasterization
  and <tt>stb_image.h</tt> for image loading. The latter has also all of its public functions exported,
  as documented in <a href="#annexB">Annex B: stb_image API</a>.

  <li><tt>nanovg_gl_utils.h</tt>: a few optional utility functions to make <tt>nanovg</tt> render
  all the graphical operations into an offscreen bitmap (known as a <b>Frame Buffer Object</b> in
  OpenGL parlance or <tt>FBO</tt> in short). By default <tt>nanovg</tt> will make its rendering into
  the main framebuffer.
</ul>

<h3 id="immode"><span>Immediate mode</span></h3>

<p>This is one aspect that differentiate <tt>SITGL</tt> from a typical desktop user interface library:
when rendering a user-interface on top of a scene handled by OpenGL, that scene will likely refresh the
entire screen, and therefore the entire interface will have to be redrawn. Also user inputs will be
interleaved between user interface and the underlying engine.

<p>This library has an <b>alternate mode to render its components</b> if the entire screen is managed
by <tt>SITGL</tt>: it can tell you whenever the screen needs to be updated, otherwise you can just keep
what's already being displayed on the screen. But if the user interface has to be displayed on top of
an existing application, whenever something change in the engine, the user interface will have to be
refreshed too.

<p>That being said, even if there is nothing to update on the screen, the main loop must still be running.
Because some actions made by user will trigger animations: if you use a blocking event loop, the animation
will stop, until some events are generated (key pressed, mouse moved, ...): this is usually not what you want.

<h3 id="entry"><span>Entry point</span></h3>

<p>At the beginning of the <tt>main()</tt> function, the first thing that needs to be done is to initialize
your windowing system (SDL, GLFW, ...). Before you can initialize <tt>SITGL</tt>, <b>an OpenGL context
needs to be created first</b>. If you try to initialize this library too early, it will fail. In case
of SDL, the OpenGL context is created with the function <tt>SDL_SetVideoMode()</tt>. If you are using
GLFW, the context will be valid when calling the function <tt>glfwMakeContextCurrent()</tt>. Therefore
this library <b>cannot</b> be initialized sooner than this.

<p>Also, a requirement needed by <tt>nanovg</tt> is that the <b>stencil buffer must be enabled</b> (any
depth will suffice). By default, SDL will not initialize it
(<a href="https://www.glfw.org/docs/latest/window_guide.html#window_hints_values">GLFW</a> will, see
value for <tt>GLFW_STENCIL_BITS</tt>), the function to enable the stencil buffer with SDL is:
<pre>SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 1);</pre>
<p>Keep in mind that it must be called before creating the OpenGL context.

<h3 id="sitglinit"><span>SITGL initialization</span></h3>

<p>Once the windowing system has been initialized, you can do the same with SITGL using the function
<tt>SIT_Init()</tt>. This library is composed of 3 sub-systems:

<ol>
  <li><tt>nanovg</tt>: this is the <b>low-level rendering library</b>. Even though there is GL in its name, SITGL
  does not deal directly with OpenGL, <b>everything</b> goes through <tt>nanovg</tt>. The first parameter
  is a bitfield that will be transmitted as is to the function <tt>nvgCreateContext()</tt>. If you don't
  care about this parameter, simply use <tt>SIT_NVG_FLAGS</tt>.

  <li><b>CSS</b>: <tt>nanovg</tt> is a bit too low-level to be used directly, that's why this sub-system
  has been added on top of <tt>nanovg</tt>. Most of the properties related to appearance can be used (the
  complete list will be described later).
  
  <p>The last 2 parameters are used to initialize the appearance of the controls. By default, <b>SITGL
  does not have any styles defined</b>. If you were to add a button without a stylesheet, only the text
  will be visible: there will no hovering, activated or disabled effect (events will be triggered though).

  <p>The reason for this, is because every application will use something different, having default would
  be nice, but ultimately, those default values will always be replaced sooner or later.

  <p>That being said, writing a stylesheet for all the different controls and their states is a difficult
  and tedious process, that's why it is strongly advised to look in the "<tt>examples/css</tt>" folder for
  some <b>pre-made stylesheets</b> and iterate on these, instead of starting from scratch.

  <li>The last, but not least, component is the <b>user-interface library</b>. The return value from
  this function is the root control representing the screen, where you can add widgets in it, in order
  to provide interactive elements to the user.
</ol>

<p>If <tt class="o">NULL</tt> is returned, something went wrong. The typical reasons for this to happen are:

<ul>
  <li>You need a driver that supports at least <b>OpenGL version 3+</b>.
  <li>The OpenGL context <b>was not created</b> before calling the <tt>SIT_Init()</tt> function.
</ul>

<p>You can use the function <tt>SIT_GetError()</tt> to get a somewhat human readable message to know
what went wrong. The <tt>SIT_Log()</tt> will display an operating system popup: this function can actually
be called at any time, even before the initialization phase.

<p>Once the initialization is done, you can start creating the user interface.

<h3 id="create"><span>Creating the interface</span></h3>

<p>The whole interface can be created using a single function: <tt>SIT_CreateWidget()</tt> (or the one
derived from this function: <tt>SIT_CreateWidgets()</tt>). Expect to see it a lot in your program. Its
name was inspired from <acronym title="X Toolkit Intrinsics">Xt</acronym>, where you instantiated your
controls using <tt>XtVaCreateWidget()</tt> or <tt>XtVaCreateManagedWidget()</tt>. Widget is a portmanteau
word for "Windows Gadget": small windows with specialized behavior.

<p>This function uses a <tt class="o">NULL</tt>-terminated list of key/value pairs. This has the
advantage of being rather fault tolerant (incorrect tags are simply ignored), and you don't have to
remember countless of datatypes or even the order of the arguments. The drawback is you have to be
careful with implicit promotion (for example: if a tag asks for an integer, be careful that your
expression is not promoted to a <tt class="t">double</tt> datatype, otherwise you'll certainly get
a stack overflow).

<p>Among all the control types this function can create, the one returned by <tt>SIT_Init()</tt> is
a little bit special: it cannot be deleted and its sole purpose in to act as a root for other widgets
to be added.

<p>After creating your controls, you usually register callbacks to respond to user actions, like
keystroke, repainting, mouse click, ... Obviously, in a small example like that, we didn't have any
event to process.


<h3 id="eventloop"><span>Main event loop</span></h3>

<p>Then the last part of this example is dedicated to collect events for the windowing system and forward
them to <tt>SITGL</tt>. All these forwarding functions will take raw values, so that integrating these
should be no more than a single line of code.

<p>Once events have been transmitted to <tt>SITGL</tt>, you might want to refresh the screen to take
user actions into account. Depending on which refreshing mode you activated, the <tt>SIT_RefreshNodes()</tt>
might be a no-op if it returns <tt class="o">False</tt>. If it returned <tt class="o">True</tt>, that
means something has been drawn on the OpenGL back buffer, and you should use your windowing toolkit to
swap the buffer. In case of <tt>SDL</tt>, the function is simply <tt>SDL_GL_SwapBuffers()</tt>.

<p>And that's it for this example. Keep in mind this was just a quick overview. The next sections will
go more in details about all the concepts needed to use this library. This might seem like a lot of
effort to just display a simple line of text, and in some way it is, but you'll quikly realize that
building complex user-interface will not require that much effort from this point onward.

<h3 id="compiling"><span>Compiling the library</span></h3>

<p>This section is a quick overview on how to compile this library. First, you'll need a gcc-compatible
compiler, that supports at least C99 (you'll also need anonymous nested unions, part of C11). As of
writing this, this library <b>cannot</b> be compiled with a 64bit compiler.

<p>With that in mind, you'll also need some parts of the windows SDK, like the one included with
<tt>MinGW</tt>: this library does not make use of advanced features of the Win32 API. Any SDK
covering at least Windows 2000 should be largely enough.

<p>Basically what you need is a <tt>MinGW</tt> compiler, you can get from <a href="http://mingw.org/">mingw.org</a>
(but development seems to have stalled, even though for compiling <tt>SITGL</tt> the development
environment provided are largely sufficient) or <a href="http://mingw-w64.org/doku.php">mingw-w64.org</a>
(this site offers way more up-to-date compilers, including both 32bit and 64bit version).

<p>Once the tool chain has been setup, the way to compile this into a DLL is simply to compile all the
source files into a dynamic library, like this:
<pre>gcc -DBUILDING_DLL -Wall -Os -shared *.c -o SITGL.dll -static-libgcc -s</pre>

<p><span class="n">Note</span>: due to the use of UTF-8 strings and libc functions, your compiler might
complain of signed/unsigned types mismatch. UTF-8 strings have to be accessed through a
<tt class="t">unsigned char *</tt> pointer, whereas all the prototypes from the libc will use a
<tt class="t">char *</tt> pointer. There was basically 3 possibilities to handle that problem:
<ol>
  <li>Casting hell.
  <li>Macro hell.
  <li>Don't give a damn and disable the compiler warning.
</ol>

<p><span class="n">Note</span>: for <tt>gcc</tt> (and derivative compilers, like <tt>mingw</tt>) the
pointer sign mismatch warning will be already disabled through the use of a pragma directive.

<hr>

<p>Optionally, you can also compile the file <tt>SITGL.rc</tt>, which contains some meta-data (like version
number, license, author, ...) that Windows can display in various places:
<pre>windres.exe -i SITGL.rc -J rc -o SITGL.res -O coff</pre>

<p>And then use the resulting file <tt>SITGL.res</tt> as a linkable object. The library will work
perfectly fine without it though.

<p>Keep in mind, that <tt>MinGW</tt> will link against the <tt>msvcrt.dll</tt> from Windows, meaning
that you don't have to deal with those pesky runtime redistribuable, like some other environment. Although,
if you want to use this library with another runtime, every object allocated by this library, will have
to be freed by <tt>SITGL</tt> too.

<h2 id="integration">Integration</h2>

<p>This section will describe more in details how to <b>integrate <tt>SITGL</tt> within a windowing
framework</b>. All the examples in this section will use SDL v1 as basis. Although it is a bit dated at
the time of writing this, its API is still as straightforward as it can be.

<h3 id="SIT_Init"><span>SIT_Init</span></h3>

<p>As explained in the <a href="#sitglinit">introduction</a>, <b>the first function</b> you'll need to
call in order to use <tt>SITGL</tt> is <tt>SIT_Init()</tt>, just after creating the OpenGL context.
Here is its prototype:

<pre>SIT_Widget <b>SIT_Init</b>(<type>int</type> nvgFlags, <type>int</type> width, <type>int</type> height, <type>STRPTR</type> theme, <type>int</type> _1_if_theme_is_path_0_if_string);</pre>

<p>The arguments have the following meaning:
<ul>
  <li><tt>nvgFlags</tt>: flags that will be transmitted as is to nanovg. If you want to use a specific
  combination of flags, you'll have to include <val>"nanovg.h"</val>. If you don't care,
  simply use the macro <tt>SITGL_NVG_FLAGS</tt>. For reference, these are the flags you can use:
  <ul>
	<li><tt>NVG_ANTIALIAS</tt>: will draw all graphics opearations using sub-pixel anti-aliasing. Most
	of the times it produces way better looking graphics, but it has some caveats: attempting to draw
	filled polygons with a thickness below 1 pixel <em>may</em> result in artifacts (c.f
	<a href="https://github.com/memononen/nanovg/issues/571#issue-580801786">issue 571</a> or
	<a href="https://github.com/memononen/nanovg/issues/579#issuecomment-629709381">issue 579</a>).

	<li><tt>NVG_STENCIL_STROKE</tt>: will increase the precision of filled shape. Strongly advised to
	keep that flag if you intend to use complex CSS properties (highly likely you will).
  </ul>

  <p>These flags can (should) be disabled if you activated Multi-Sample Anti-Aliasing (MSAA) option
  in the OpenGL driver.

  <li><tt>width</tt>, <tt>height</tt>: the initial size of the screen, in pixels. You'll be able to
  change it later, it the window size has changed.

  <li><tt>theme</tt>: a <tt class="o">NULL</tt>-terminated string describing either a path to a file,
  where to read CSS styles or a string containing a stylesheet. In either case, the string will not
  be modified, so you can safely use static strings for this argument.
  
  <p>Unless the stylesheet is very simple, it is strongly advised to use an external file for loading
  CSS styles, otherwise you'll have to recompile your program each time. Also, keep in mind that it
  will be possible to change the entire stylesheet at any moment.

  <li><tt>_1_if_theme_is_path_0_if_string</tt>: this is how you tell what object to look for the
  <tt>theme</tt> parameter.
</ul>

<p><b>If everything went well</b>, you should get a <tt>SIT_Widget</tt> object as the returned value. <b>This
is a very important object</b>, and should be kept somewhere safe, because there will be no other way
to get it back.

<p><b>If something went wrong</b>, you can call the function <tt>SIT_GetError()</tt>: it will return a human
readable message describing what went wrong. The string returned is a small static buffer, no need to
free this value. You can then use the function <tt>SIT_Log()</tt> to show this message to the user.

<p>The object returned contains a few global properties, you might want to change before creating anything.
The full list of properties will be described in the <a href="#SIT_APP">dedicated</a> section. This is done
using the function <a href="#SIT_SetValues"><tt>SIT_SetValues()</tt></a>. For the purpose of integration,
those properties can be safely ignored for now.

<p>Then, you can start creating the interface through a series of <a href="#SIT_CreateWidget"><tt>SIT_CreateWidget()</tt></a>
or <a href="#SIT_CreateWidgets"><tt>SIT_CreateWidgets()</tt></a> calls. The way those functions work is
not important at this point. Once you have some interactive elements on screen, you'll need to transmit
user events from your windowing system, to the <tt>SITGL</tt> event processing functions in order for
the elements to become useful.

<h3 id="forwardevt"><span>Event forwarding</span></h3>

<p>This part will <b>not</b> explain how to properly process events using whatever windowing framework,
but you can look in the "<tt>example</tt>" directory, for some popular framework (SDL1, SDL2 and GLFW).

<p>To make your interface really interactive, you will need to forward events using the following functions:

<ul>
  <li><tt class="dt"><type>void</type> SIT_ProcessMouseMove(<type>int</type> x, <type>int</type> y);</tt>
  <p>Forward <b>mouse move</b> messages. <tt>x</tt> and <tt>y</tt> should simply contain the coordinates relative
  to the top left corner of the window/screen (the values must not be relative to the previous mouse
  move event).

  <p>It is more than advised than your framework knows how to handle <b>mouse move capture</b>: when you click
  and hold the mouse button, mouse move events should be triggered <b>even if the mouse exit the window</b>
  (as long the mouse button is pressed). <tt>SITGL</tt> <b>cannot</b> work around this. On the other
  hand, when the mouse is outside the window when no buttons are pressed, <tt>SITGL</tt> don't expect
  to receive any events.

  <li><tt class="dt"><type>int</type> SIT_ProcessClick(<type>int</type> x, <type>int</type> y, <type>int</type> button, <type>int</type> pressed);</tt>
  <p>Forward <b>mouse buttons/mouse wheel</b>. All default widgets from <tt>SITGL</tt> can work with only one
  mouse button. Having mouse wheel events will make scrolling a little bit more user-friendly. Even
  though most widgets will allow you to click-drag an inactive area to scroll the content, so that even
  with only one mouse button, the interface should remain extremely usable. The expected
  parameters are:
  <ul>
	<li><tt>x</tt>, <tt>y</tt>: just like for mouse movement, this must be the <b>absolute coordinate</b>
	relative to the top left corner of the screen where the mouse button event occured.
	<li><tt>button</tt>: which mouse buttons are pressed. You can use the following symbols:
	  <ul>
	    <li>SITOM_ButtonLeft  (<val>0</val>).
	    <li>SITOM_ButtonRight (<val>1</val>).
	    <li>SITOM_ButtonLeft (<val>2</val>).
		<li>SITOM_ButtonWheelUp  (<val>3</val>).
		<li>SITOM_ButtonWheelDown  (<val>4</val>).
	  </ul>
	<li><tt>pressed</tt>: <val>1</val> if the button is pressed, <val>0</val>
	if it has just been released.
  </ul>

  <p>This is the part where <b>correct handling of mouse capture</b> is very important: when you press
  a mouse button, then move the mouse outside the window (while still keeping the button pressed), and
  finally release the button, the windowing framework <b>must</b> send a mouse click event. Again, if
  your windowing framework can't handle this, don't bother submitting a bug report/feature request
  to <tt>SITGL</tt>.

  <p><b>The return code</b> indicates whether or not the event was targeting a <tt>SITGL</tt> element (it does
  not necessarily mean that the event had an effect). If the screen has to be shared between a user interface
  and your 3d scene, you might want to ignore events if they are targeting <tt>SITGL</tt> components.

  <li><tt class="dt"><type>int</type> SIT_ProcessKey(<type>int</type> key, <type>int</type> modifier, <type>int</type> pressed);</tt>

  <p><b>Forward key without (obvious) unicode representation</b>. Keys like qualifiers (Shift, Control,
  Alt, ...), cursor (Up, Down, ...), BackSpace, Delete, PageUp, PageDown, ...

  <p>The parameters expect the following values:
  <ul>
	<li><tt>key</tt>: must be enumeration from <tt>SITK_*</tt>. You'll have to manually translate values
	from your windowing toolkit to the one used by <tt>SITGL</tt>. In order to have a decent keyboard
	support, it is advised to translate as much <tt>SITK_*</tt> values as possible.
	<li><tt>modifier</tt>: which modifier were held when the key was pressed. Supported modifier
	tokens start with <tt>SITK_Flag*</tt>. For example: <tt>SITK_FlagShift</tt> if the Shift key
	was also pressed. <span class="n">Warning</span>: there is also a key named <tt>SITK_Shift</tt>:
	this value is when the Shift key itself is pressed.
	<li><tt>pressed</tt>: <val>1</val> if the button is pressed, <val>0</val>
	if it has just been released.
  </ul>

  <p><b>The return code</b> works similarly to <tt>SIT_ProcessClick()</tt>: it means that the event was
  processed by a <tt>SITGL</tT> control, which means you might not want to reuse that event afterward.
  If your event loop first distribute keyboard events to your 3d scene, then gives the leftover to
  <tt>SITGL</tt>, the return code is not that useful, since <tt>SITGL</tt> will be at the bottom of
  the food chain.

  <li><tt class="dt"><type>int</type> SIT_ProcessChar(<type>int</type> codePoint, <type>int</type> modifier);</tt>
  <p><b>Forward key with unicode character</b>. This is mostly used by the text edit widget. If you don't plan
  on using it, you can skip this part. The expected parameters are as follows:
  <ul>
	<li><tt>codePoint</tt>: unicode code point generated by the key.
	<li><tt>modifier</tt>: modifier that were held when key was generated (same values as for
	<tt>SIT_ProcessKey()</tt>).
  </ul>

  <p>Some framework like SDL1 does not translate automatically every keystroke, and needs to be
  explicitly activated using the function <tt>SDL_EnableUNICODE(<val>1</val>);</tt>.
  If you don't want to activate the translation at all times, <tt>SITGL</tt> does provide mechanism
  to activate it only when a text edit has received the keyboard focus (this will be described more
  in detail in the <a href="#events">events</a> section).
  <p><span class="n">Note</span>: if a key press generates multiple characters, you'll have to call
  this function for each unicode code point.

  <p><b>The return code</b> works exactly like <tt>SIT_ProcessKey()</tt>.

  <li><tt class="dt"><type>void</type> SIT_ProcessResize(<type>int</type> width, <type>int</type> height);</tt>
  <p><b>Forward screen resize</b>. <tt>width</tt> and <tt>height</tt> are obviously the new window size, in
  pixels.
  
  <p><span class="n">Note</span>: this library will suppose that the OpenGL framebuffer belongs to
  your application, therefore, if the window size has changed, <b>YOU</b> will have to change the
  size of the framebuffer (using <tt>glViewport()</tt>) <b>before</b> refreshing the interface using
  <tt>SIT_RenderNodes()</tt> (you don't have to do it before forwarding the event though). In any case,
  failure to do so, will result of a weird aspect ratio of everything drawn by <tt>SITGL</tt>/<tt>nanovg</tt>.
</ul>

<p>That's about it for event forwarding. It sounds like a lot, but beside keyboard events, all the
other should be no more than one line of code. And again, check out the "<tt>example</tt>" directory
for how to handle this using various frameworks (Win32, SDL1, SDL2 and GLFW).

<h3 id="SIT_RenderNodes"><span>SIT_RenderNodes()</span></h3>

<p>Last but not least, in order to have a proper interactive interface, it advised to display something
to the user. That's the purpose of this function: <b>render all the controls you've created so far</b>.
The prototype of this function is as follows:

<p><tt class="dt">SIT_RENDER SIT_RenderNodes(<type>double</type> time);</tt>

<p>The only parameter needed is the time in millisecond, <b>since the application was started</b>
<span class="n">Note</span>: this parameter doesn't need a sub-millisecond precision, but should
at least match the framerate at which <tt>SIT_RenderNodes()</tt> is called. Still, the more precise
it is, the smoother the animations will be. The <b>return code</b> is one of the following values:

<ul>
  <li><tt>SIT_RenderNothing</tt> (0): nothing has been done, since there was no changes since last
  <tt>SIT_RenderNodes()</tt> call. This return code is only sent if the refresh as needed mode has
  been <a href="#SIT_APP">activated</a> (by default it is not).
  <li><tt>SIT_RenderDone</tt> (1): all the nodes has been rendered, with no other ones pending. You
  can swap GL buffer to display the result, or continue the rendering of top of what's already there.
  <li><tt>SIT_RenderComposite</tt> (2): one or more nodes require drawing outside of <tt>SITGL</tt>/<tt>nanovg</tt>
  control (usually done by OpenGL) and another control overlaps that area, and therefore cannot be
  drawn until the external rendering is done. Once the drawing is done, you have to call <tt>SIT_RenderNodes()</tt>
  as long as this code is returned. This mode will be described more in details in <a href="#annexC">annex C</a>,
  since it requires additional setup to work.
  <p><span class="n">Note</span>: if you don't plan to use composite operations, you can simply treat
  the return code as a boolean (since <tt>SIT_RenderComposite</tt> will never be returned).
</ul>

<p>Which refresh mode to activate will depend on where the interface will be drawn: if the screen is
entirely refreshed by <tt>SITGL</tt> (every pixels must be under <tt>SITGL</tt> control), then you
can <a href="#SIT_APP">activate</a> the refresh as needed mode. If drawn on top of a 3D scene, the
interface will have to be refreshed at the same rate as the scene.

<hr>

<p>As stated in the introduction, this function must be called at regular interval, usually at least
20 times per second, in order for animations and asynchronous events to be processed in time.

<p>The rendering of the interface is entirely handled by <tt>nanovg</tt>. The latter needs to be setup
properly in order for any output to appear on screen (between the calls to the functions <tt>nvgBeginFrame()</tt>
and <tt>nvgEndFrame()</tt>). As the complexity of your application grows, <b>you'll want at some point
to bypass <tt>SITGL</tt> and use <tt>nanovg</tt> or <tt>OpenGL</tt> API directly</b>, possibly alongside
with some elements still rendered by <tt>SITGL</tt>. This library will allow you this (it is refered
as <em>composite rendering</em> in this library), but some precaution
needs to be taken as to when calling the <tt>SIT_RenderNodes()</tt> function. This is somewhat of an
advanced feature and will be described in <a href="#annexC">annex C: advanced rendering API</a>.

<p>Therefore, if you just want to display an interface of top of 3d scene, or a screen entirely managed
by <tt>SITGL</tt>, the rendering loop shouldn't be more complicated than what was presented in the
<a href="#render">introduction</a>.

<h3 id="windows"><span>Operating system (Windows)</span></h3>

<p>This section will briefly explain what needs to be known to have a <b>smooth integration wihtin the
Microsoft Windows operating system</b>. Although information in this section is not necessarily specific
to <tt>SITGL</tt>, it will spare you a few hours of digging through ancient documentation, that are
not particularly fun to read.

<h4>HiDPI auto-scaling</h4>

<p>Starting with Windows 8, Microsoft introduced a feature that automatically <b>scales the entire content
of a top-level window</b> if your screen is considered to be of high pixel density. OpenGL and this library
will provide you with enough tools to deal with that already, adding that feature on top wil cause you
more troubles than anything else (especially in full screen mode). Nevertheless, you'll still have to
tell Windows to disable it.

<p>First, you can <b>do it manually</b> by displaying the program's properties and then by explicitly
disabling the HiDPI scaling:

<div class="image">
  <img src="images/windows_hidpi.png">
</div>

<p>If you want to do it <b>without manual intervention</b>, you'll need to add a manifest file to your
application. First, you'll need to create a <a href="https://docs.microsoft.com/en-us/windows/win32/menurc/about-resource-files?redirectedfrom=MSDN">resource file</a>.
This file is used by Windows to add some meta-data to your program: <b>icon</b> displayed by the file explorer,
<b>version</b> information, and <b>manifest</b>. There are a whole lot of other information that can
be added, but for an OpenGL application, that's pretty much all you'll ever need.

<p>The manifest file is a way to tell the system that your program is aware of certain feature and
that the operating system should get out of the way. To do this, first create a resource file. The
typical name for such a file is usually <tt>&lt;app&gt;.rc</tt>:

<pre>1 MANIFEST "&lt;app&gt;.exe.Manifest"</pre>

<p><tt>&lt;app&gt;</tt> needs to be replace by your application's name. Then create a text file named
<tt>&lt;app&gt;.exe.Manifest</tt>, with the content:

<pre><note>&lt;?</note><com>xml <dva>version</dva>="1.0" <dva>encoding</dva>="UTF-8" <dva>standalone</dva>="yes"</com><note>?&gt;</note>
<com>&lt;assembly <dva>xmlns</dva>="urn:schemas-microsoft-com:asm.v1" <dva>manifestVersion</dva>="1.0" <dva>xmlns:asmv3</dva>="urn:schemas-microsoft-com:asm.v3"&gt;
	&lt;asmv3:application&gt;
		&lt;asmv3:windowsSettings <dva>xmlns</dva>="http://schemas.microsoft.com/SMI/2005/WindowsSettings"&gt;
			&lt;dpiAware&gt;</com><b>true</b><com>&lt;/dpiAware&gt;
		&lt;/asmv3:windowsSettings&gt;
	&lt;/asmv3:application&gt;
	&lt;description&gt;</com><b>Executable</b><com>&lt;/description&gt;
&lt;/assembly&gt;</com>
</pre>

<p>You can now compile your RC file (not the manifest file) into a linkable object and use this to
produce a standalone executable. Be aware, that if you have manually changed the properties of your
program, those settings will be kept into a cache. Before producing an executable, delete manually
the program first.

<h4>Program icon</h4>

<p>While you are at it, you might as well add a <b>dedicated icon for your program</b>. This is also
done in the resource file, by adding the following line:

<pre>1 ICON "&lt;app&gt;.ico"</pre>

<p>As usual, replace <em>&lt;app&gt;</em> by the name of your application, then use your favorite paint
program to generate an icon named <tt>&lt;app&gt;.ico</tt> in the same folder where the program is.

<h4>Version information</h4>

<p><b>Version information</b> can also be added in the resource file, so that it can be read by Windows in
various places (usually inside file properties "Details" tab). To do this, add the following block in
the same resource file:

<pre>
<val>1</val> <spe><b>VERSIONINFO</b></spe>
FILEVERSION <val>1</val>,<val>0</val>,<val>0</val>,<val>0</val>
PRODUCTVERSION <val>1</val>,<val>0</val>,<val>0</val>,<val>0</val>
FILETYPE <val>1</val>
{
	<spe><b>BLOCK</b></spe> <dim>"StringFileInfo"</dim>
	{
		<spe><b>BLOCK</b></spe> <dim>"040904b0"</dim>
		{
			<spe><b>VALUE</b></spe> <dim>"FileVersion"</dim>,      <dim>"1.0"</dim>
			<spe><b>VALUE</b></spe> <dim>"FileDescription"</dim>,  <dim>"Simple Interface Toolkit - OpenGL edition"</dim>
			<spe><b>VALUE</b></spe> <dim>"InternalName"</dim>,     <dim>"SITGL"</dim>
			<spe><b>VALUE</b></spe> <dim>"LegalCopyright"</dim>,   <dim>"BSD Licensed"</dim>
			<spe><b>VALUE</b></spe> <dim>"OriginalFilename"</dim>, <dim>"SITGL.dll"</dim>
			<spe><b>VALUE</b></spe> <dim>"ProductName"</dim>,      <dim>"SITGL"</dim>
			<spe><b>VALUE</b></spe> <dim>"ProductVersion"</dim>,   <dim>"1.0"</dim>
		}
	}
	<spe><b>BLOCK</b></spe> <dim>"VarFileInfo"</dim>
	{
		<spe><b>VALUE</b></spe> <dim>"Translation"</dim>, <val>0x0409</val>, <val>1200</val>
	}
}</pre>

<p>Replace the inner block, by what is the most appropriate for your application.


<h2 id="nanovg">nanovg</h2>

<p><tt>nanovg</tt> is the low-level rendering library used by <tt>SITGL</tt>. This section will describe
what needs to be known about <tt>nanovg</tt>, and the few changes that have been made.
It <b>will not</b> go too much in detail on how to properly use this library, because its API is pretty
straightforward, since it mimics the canvas API of javascript.

<p>Also, font rendering is handled by <a href="https://github.com/nothings/stb"><tt>stb_truetype.h</tt></a> and
image loading is handled by <tt>stb_image.h</tt>. The latter has its functions made available in <tt>nanovg.h</tt>,
because any 3d engine worth its salt will have to load textures at some point or another, might as
well reuse those functions.

<h3 id="NVGUBO"><span>Uniform Buffer Object location</span></h3>

<p><b>One important thing to keep in mind</b> is that <tt>nanovg</tt> has been compiled with OpenGL 3 support,
using <em>Uniform Buffer Object</em> to transfer drawing state to shaders. The uniform buffer location
is set to 0 (last parameter of <tt>glUniformBlockBinding</tt>). That means you'll have to be careful
not to use that binding in your program, especially when using the auto-binding of OpenGL 4+
(ie: declaration like "<tt>layout (std140, binding = 2) uniform param</tt>", do not set the <tt>binding</tt>
to 0), otherwise the resulting conflict will probably overwrite each other values with disastrous and
<b>hard to debug</b> consequences.

<p>If you want to change that binding location, you'll have to recompile the library after changing the
value assigned to token <tt>GLNVG_FRAG_BINDING</tt>.

<h3 id="NVGcaveats"><span>Caveats</span></h3>

<p>With the default <tt>nanovg</tt> flags sent to <a href="#SIT_Init">SIT_Init()</a>, the rendering
done by this library will use its built-in anti-aliasing routines. This mode has a few caveats that
you need to be aware of:

<ul>
  <li><b>Avoid 0-width path</b>: with a code like that:
  <pre style="margin-left:0">nvgBeginPath(vg);
nvgFillColorRGBA8(vg, <val>"</val><spe>\x20\x20\xff\x88</spe><val>"</val>);
nvgMoveTo(vg, <val>10</val>, <val>50</val>);  nvgLineTo(vg, <val>10</val>, <val>10</val>);
nvgLineTo(vg, <val>50</val>, <val>10</val>);  nvgLineTo(vg, <val>50</val>, <val>50</val>);
nvgLineTo(vg, <val>100</val>, <val>50</val>); nvgLineTo(vg, <val>100</val>, <val>10</val>);
nvgLineTo(vg, <val>140</val>, <val>10</val>); nvgLineTo(vg, <val>140</val>, <val>50</val>);
nvgFill(vg);</pre>
  <p>You'll get:
  <p><img src="images/nvg_0width_path.png">
  <p>The line between the two squares isn't supposed to be here. To avoid that, you'll need to split the path in two.

  <li><b>Be wary of the path-winding rule</b>: <tt>nanovg</tt> can be confused as to which path in the
  interior and which path is the exterior. Consider the following code:
<pre style="margin-left:0"><type>float</type> mx = <val>50</val>, my = <val>50</val>, thick = <val>8</val>;
nvgPathWinding(vg, NVG_CCW);
nvgRoundedRect(vg, mx, my, width, height, thick * <val>3</val>);
nvgPathWinding(vg, NVG_CW);
nvgRoundedRect(vg, mx+thick, my+thick, width-thick*<val>2</val>, height-thick*<val>2</val>, thick * <val>2</val>);
nvgFill(vg);
</pre>
  <p>You'll get:
  <p><img src="images/nvg_winding_rule.png">
  <p><span class="n">Note</span>: the red lines show the bounding box of each rectangles, and have been
  added with a paint program. In this case, you'll need to swap NVG_CCW and NVG_CW to get correct results.

  <li><b>Sub-pixel path drawing might result in some artifacts</b>: which is another artifact of the
  anti-aliasing method used by <tt>nanovg</tt>: if a path end up covering less than one pixel, you might
  see those artifacts around that edge. For example:
<pre style="margin-left:0"><com>/* both arc end up at the same point */</com>
nvgBeginPath(vg);
nvgFillColorRGBA8(vg, <val>"\0\0\0</val><spe>\xff</spe><val>"</val>);
nvgEllipseArc(vg, <val>50</val>, <val>50</val>, <val>40</val>, <val>40</val>, -M_PI, -M_PI_2, NVG_CW);
nvgLineTo(vg, <val>50</val>, <val>20</val>);
nvgEllipseArc(vg, <val>50</val>, <val>50</val>, <val>40</val>, <val>30</val>, -M_PI_2, -M_PI, NVG_CCW);
nvgFill(vg);

<com>/* second arc is shifted by one pixel */</com>
nvgBeginPath(vg);
nvgEllipseArc(vg, <val>110</val>, <val>50</val>, <val>40</val>, <val>40</val>, -M_PI, -M_PI_2, NVG_CW);
nvgLineTo(vg, <val>110</val>, <val>20</val>);
nvgEllipseArc(vg, <val>110</val>, <val>50</val>, <val>39</val>, <val>30</val>, -M_PI_2, -M_PI, NVG_CCW);
nvgFill(vg);

<com>/* rectangle height is within a pixel */</com>
nvgBeginPath(vg);
nvgRect(vg, <val>10</val>, <val>60.25</val>, <val>50</val>, <val>0.5</val>);
nvgFill(vg);

<com>/* rectangle height is within a pixel, but at pixel boundary */</com>
nvgBeginPath(vg);
nvgRect(vg, <val>60</val>, <val>60</val>, <val>50</val>, <val>0.5</val>);
nvgFill(vg);
</pre>

  <p><img src="images/nvg_sub_pixel_path.png">

  <p>The ending edge is not as sharp as it should be with the first path. This is because the arcs end
  up covering less than one pixel. We prevented that in the second path, and the result is slightly sharper
  despite the gap in the coordinates being wider.

  <p>The lines both have a thickness of 0.5px, yet you can see that the color is slightly different.

  <li><b>Avoid 0-width gap between two paths of same color</b>: due to the way anti-aliasing is applied,
  you'll get thin lines appearing between the shapes. Consider the following code:
<pre style="margin-left:0">nvgBeginPath(vg);
nvgFillColorRGBA8(vg, <val>"</val><spe>\xff\xff\xff\xff</spe><val>"</val>);
nvgMoveTo(vg, <val>10.0</val>, <val>50</val>);  nvgLineTo(vg, <val>10.0</val>, <val>30</val>);
nvgLineTo(vg, <val>50.5</val>, <val>30</val>);  nvgLineTo(vg, <val>50.5</val>, <val>50</val>);
nvgFill(vg);

nvgBeginPath(vg);
nvgMoveTo(vg, <val>50.5</val>, <val>50</val>); nvgLineTo(vg, <val>50.5</val>, <val>30</val>);
nvgLineTo(vg, <val>90.0</val>, <val>30</val>); nvgLineTo(vg, <val>90.0</val>, <val>50</val>);
nvgFill(vg);
</pre>
  <p>It will basically draw 2 rectangles next to each other:
  <p><img src="images/nvg_visible_edge.png">
  <p>The image has been enlarged 4 times. That faint vertical lines is an <b>intrinsic effect of anti-aliasing</b>,
  it is not entirely <tt>nanovg</tt> fault, but something you need to be aware nonetheless. The only
  way to get rid of these is to merge paths, so that they are drawn in one pass. This is actually more
  difficult than it sounds, since you also need to avoid 0-width path. Nevertheless, <tt>SITGL</tt>
  uses this trick to do border rendering.
</ul>

<p>If this is a big problem for you, you can activate MSAA from OpenGL and disable anti-aliasing on
the <tt>nanovg</tt> side. Keep in mind that MSAA is a global settings and will also affect the way
your scene is rendered.

<h3 id="NVGoffscreen"><span>Off-screen rendering</span></h3>

<p><tt>nanovg</tt> comes with a simple API to perform off-screen rendering. Those functions are located
in the header file <tt>nanovg_gl_utils.h</tt>. Off-screen rendering can be interesting if you want to
build an OpenGL texture that you want to map onto an object in your 3d scene later, the typical use case
is to render text for use as decals over your models.

<p>This is the basic setup to do so:
<pre><com>/*
 * init FBO: NVG_IMAGE_MASK means that the color buffer will be 1 byte per pixel, otherwise it will be 4.
 * useful if you only want to render text. In the fragment shader, you can simply recolor the text using
 * something like this:
 *	vec4 col = texture(nvgFBO, tex);
 *  vec4 text = vec4(1,0,0,1); // color of text
 *
 *	if (col.x &lt; 0.004)
 *		discard;
 *
 *	color = vec4(text.r, text.g, text.b, col.x);
 */</com>
<type>int</type> width = <val>1920</val>;
<type>int</type> height = <val>1080</val>;
NVGcontext * vg = <com>/* ... */</com>;
NVGLUframebuffer * nvgFBO = nvgluCreateFramebuffer(vg, width, height, NVG_IMAGE_MASK);

<com>/*
 * next step is rendering into that FBO
 */</com>
<type>void</type> render(<type>void</type>)
{
	nvgluBindFramebuffer(nvgFBO);
	glViewport(<val>0</val>, <val>0</val>, width, height);
	nvgBeginFrame(vg, width, height, <val>1</val>);

	<com>/* now you can use any NVG API */</com>
	
	nvgEndFrame(vg);
	nvgluBindFramebuffer(<val>NULL</val>);
}

<com>/*
 * then reuse the texture from nvgFBO as a texture source for your 3d scene
 */</com>
<type>void</type> renderScene(<type>void</type>)
{
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, nvgFBO->texture);

	<com>/* ... */</com>
}

<com>/*
 * when not needed anymore, you can free the FBO using:
 */</com>
nvgluDeleteFramebuffer(nvgFBO);
nvgFBO = <val>NULL</val>;
</pre>


<h3 id="NVGext"><span>Extensions</span></h3>



<h2 id="geometry">Controls and Geometry</h2>

<p><b>If there is only one chapter to read in this whole documentation: this is the one</b>, since unless you
already know <tt>Motif</tt>, the approach taken by this library is not that common. This section will
explain you how to create your controls and how to give some hints to the library in order to place
them with least amount of effort.

<h3 id="hierarchy"><span>Creating the hierarchy</span></h3>

<p>Widgets/controls within this library are supposed to be <b>organized in a tree-like
structure</b>: some controls are leaves (push buttons, checkbox, ...), some others are
branches, that will contain one or more children (tabs, dialogs, frame, ...). The root
of the tree in a little bit special: it is used to represent the whole screen and as such
its dimension always matches the current window size.

<p>The root control is obtained by successfully initializing <tt>SITGL</tt> using the
<a href="#SIT_Init"><tt>SIT_Init()</tt></a> function. After that, you can start adding controls to
this root, using this function:

<pre id="SIT_CreateWidget">SIT_Widget SIT_CreateWidget(<type>STRPTR</type> name, <type>int</type> type, SIT_Widget parent, ...);</pre>

<p>Let's emphasized once again the <b>importance of this function</b>, you better have to
memorize its prototype now, it is not that complicated. Each parameters have the following
meaning:
<ul>
  <li><tt class="dt">name</tt>: an <b>arbitrary name</b> you want to give to your control. It can
  be whatever you want, don't have to be unique, can contain spaces or unicode
  characters, but cannot be <tt class="o">NULL</tt> or the empty string. The
  name can be helpful if you want to find the control by its name using
  <tt>SIT_GetById()</tt>. In doubt, use a short, ASCII, lowercase letters name only.
  
  <p>In the CSS userland, the name can be used as an ID in <a href="#selectors">selectors</a>. As
  a shortcut, you can add the following text after the name:
  <ul>
	<li><tt>.<em>&lt;classname&gt;</em></tt>: where <em>&lt;classname&gt;</em> is to be replaced
	by an arbitrary text to setup the control class name that can then be used in CSS selectors.
	Otherwise, you'll have to set this up manually using the property <tt>SIT_Classes</tt>.
	<li><tt>#<em>&lt;tag&gt;</em></tt>: setup the <b>tag name</b>. The syntax is sadly backward
	compared to CSS, but the name of the SIT widget has to correspond to the ID in CSS, therefore
	the <tt>#</tt> does the opposite of what it does in CSS. If no tag name was given, an automatic one
	will be set (the complete list can be found <a href="#selectors">here</a>).
	<span class="n">Note</span>: <b>this information can only be set at creation time</b>.
  </ul>
  
  <p>For example:
  <ul>
	<li><tt class="o">"ok.def"</tt>: widget name will be <tt>ok</tt>, initial class name will be <tt>def</tt>,
	tag name will depend on the type of widget created.
	<li><tt class="o">"canvas#td.selected"</tt>: name/ID of the widget is <tt>canvas</tt>, tag name
	for CSS selectors will be <tt>td</tt>, class name is <tt>selected</tt>
	<li><tt class="o">"button1.default small</tt>: name of widget is <tt>button1</tt>, class name
	will match both <tt>default</tt> and <tt>small</tt> within CSS selectors.
  </ul>

  <li><tt class="dt">type</tt>: the <b>type of widget</b> you want to create. An enumeration that
  describes the type of control you want to create (like <Tt>SIT_BUTTON</tt>,
  <tt>SIT_LABEL</tt>, ...). The full list will be described in <a href="#controls">chapter
  dedicated to control types</a>.
  
  <p>In the CSS counterpart, this can be used as the tag name is selectors. The association between
  this enumeration and the tag name can be found <a href="#">here</a>, even though at this point it
  is not important.

  <li><tt class="dt">parent</tt>: where in your hierarchy your control will be inserted. It
  cannot be <tt class="o">NULL</tt>.

  <li><tt class="dt">...</tt>: a <tt class="o">NULL</tt>-terminated list of <b>key (or tag) / value pairs</b>.
  Obviously the list of keys a control accepts depend on its type. Also keep in
  mind that the order in which tags are specified does not matter. You can get the complete
  list of tags in the SIT main header (<tt>SIT.h</tt>), this guide will
  only explain the most important ones. Don't worry, if a tag is not explained, its usage
  should be pretty straightforward.
  
  <p><span class="n">Note</span>: don't forget to always <tt class="o">NULL</tt>-terminate the list,
  even if there are no arguments. If you are using a gcc-derived compiler, a warning should be displayed
  if you forget that sentinel.
</ul>

<p>The <b>value returned</b> is the control that have been created. The typical following step is to
register some callbacks in order to process user input (callbacks will be described in the
<a href="#events">next chapter</a>).

<p>You don't really have to check the return code for every call to <tt>SIT_CreateWidget()</tt>, since
if parent is <tt class="o">NULL</tt>, all subsequent attempt to create a widget will fail, while all
the functions requiring a widget parameter from the SIT API are <tt class="o">NULL</tt>-safe.

<p>Also, remember that <b>tag names are prefixed</b> by <tt>SIT_</tt>, and <b>enumeration values</b>
by <tt>SITV_</tt>, so if the first member of the pair does not start with <tt>SIT_</tt>, it is the sign
that something is wrong with the code. To make this problem more obvious, it is strongly advised to
indent your code into two columns for tag/value list, like this:</p>

<pre>SIT_Widget dialog = SIT_CreateWidget(<val>"inventory"</val>, SIT_DIALOG, app,
	SIT_DialogStyles, SITV_Plain | SITV_Modal,
	SIT_AccelTable,   shortcuts,
	<val>NULL</val>
);</pre>

<p>Which is another aspect heavily under-estimated by beginners, which tend to
dismiss long-term maintainability for immediate on-screen results.</p>

<p>If you keep that in mind, you are ready for <b>the next step</b>: creating your interface. You can either
create a top-level dialog, or start adding controls directly in the root widget. The various control
types that can be created will be examined more thoroughly in the <a href="#controls">next chapter</a>,
along with their specific properties they accept. For now, we will focus on a very critical aspect,
which was almost the reason why this library was created in the first place: <b>laying your control</b>.

<h3 id="alter"><span>Manipulating the hierarchy</span></h3>

<p>Some properties of controls can be altered at any time, some can only be read once the control has
been created. To do this, <b>there are 2 dedicated functions</b>: again, keep them in mind, you'll use them
extremely frequently in almost every program:

<ul>
  <li><tt class="dt"><type>void</type> SIT_SetValues(SIT_Widget, ...);</tt>
  <p>This function can be used to <b>set one or multiple values</b> at a time. It accepts the same arguments
  as <tt>SIT_CreateWidget()</tt> function: a <tt class="o">NULL</tt>-terminated list of key/value(s) pairs.
  Sometimes, it will not be possible to set all the values at once when using <tt>SIT_CreateWidget()</tt>,
  especially when having cross reference attachment (more on this later in this chapter), therefore
  you'll need a second set of attributes to change using this function.

  <li><tt class="dt"><type>void</type> SIT_GetValues(SIT_Widget, ...);</tt>
  <p>This function works similarly to <tt>SIT_SetValues()</tt>, but instead <b>will retrieve values from
  a particular widget</b>. It will accept the same arguments as <tt>SIT_SetValues()</tt>, but instead of
  providing values, <b>you'll need to provide pointers of the type corresponding to the property</b>.
  
  <p>In the main header file <tt>SIT.h</tt> you'll get the type expected by each property. To retrieve
  a readable property, you'll have to provide a pointer that can store at least the size of the type.
  <p><span class="n">Note</span>: for string properties, you won't have to provide storage for its
  content, you'll just need a pointer to store the start of the buffer (ie: <tt class="t">STRPTR *</tt>).
  Keep in mind, this will be the raw pointer used internally by the library, don't even try to modify
  anything unless you like hardcore debugging.

  <p>Also, some properties accepts multiple arguments (when being set), therefore when retrieving the values,
  you'll have to provide as many pointers as there are arguments (and not an array of pointers).

</ul>

<p><b>To know which parameters can be set and which can be read</b>, you can look directly in the <tt>SIT.h</tt>
header file: just search for the name of the tag (or better: if your development environment supports
it, simply go to its declaration).

<p><b>To look for a particular widget</b> within the hierarchy, you can use the following function:
<ul>
	<li><tt class="dt">SIT_Widget SIT_GetById(SIT_Widget parent, <type>STRPTR</type> name);</tt>
	<p>Another function you will likely use a lot in any program, keep it in mind.
	<p>This function search in the hierarchy, starting with widget given as first argument, then looking
	at the list of children, and so on recursively. The widget name will be matched <b>case sensitively</b>.

	<p>It will happen that you know beforehand that the widget you are looking for is a sibling of
	a widget reference you have on hand (this will happen quite a lot in event callbacks). At this point,
	you could use the <tt>SIT_GetValues()</tt> to retrieve the <tt>SIT_Parent</tt> property value, or
	you could just prefix the name by <tt class="o">"../"</tt>. Alternatively, if you want to search
	the entire hierarchy, no matter what, you can prefix the name by <tt class="o">"/"</tt>.
</ul>

<p>Widgets can also be <b>removed at any time</b>, using the following function:
<ul>
	<li><tt class="dt"><type>void</type> SIT_RemoveWidget(SIT_Widget);</tt>
	<p>This function will not just remove the widget, but also free all the resources allocated. If you
	had any reference on this widget, time to clear them. Attempting to use <tt>SIT_SetValues()</tt> or
	<tt>SIT_GetValues()</tt> on a removed widget will certainly cause a crash.
</ul>

<p>At some point, you might want to <b>remove all the controls</b> there are on screen, typically to
start a completely new interface. You could remove them one by one, using the previous function, or
simply use this dedicated function:
<ul>
	<li><tt class="dt"><type>void</type> SIT_Nuke(<type>int</type> what);</tt>
	<p>Use this function if you want to remove everything that has been allocated so far. <tt>what</tt>
	parameter can be one of the following value:
	<ul>
	  <li><tt>SITV_NukeCtrl</tt>: <b>delete all the controls</b>, but keep all the properties set for the
	  root widget (SIT_APP), that includes the CSS stylesheet that was parsed in <tt>SIT_Init()</tt>.
	  <li><tt>SITV_NukeTheme</tt>: delete all the controls and <b>clear all the CSS rules</b>. You'll have
	  to provide a new stylesheet using the <tt>SIT_StyleSheet</tt> property, otherwise all your
	  controls will be almost invisible.
	  <li><tt>SITV_NukeAll</tt>: <b>free absolutely everything</b>. Typical use case is to call this when the
	  application is about to exit <b>and</b> to make some memory profiling tool happy. For a normal
	  release, don't even bother freeing resources upon exit: the operating system will do it for
	  you much quicker than this library or your program will ever be able to.
	</ul>
</ul>


<h3 id="placement"><span>Placing controls</span></h3>

<p>One of the main motivation for creating this library in the first place was to provide a more
intuitive way of laying out control on the screen. The goal of this part is to define where your
controls will be placed on a dialog, by <b>specifying the least amount of information</b> (the worst
case is having to specify the exact coordinates of all your controls).

<p>The way it works in this library, is to <b>specify linear constraints between controls</b> and/or
parent dialog. Instead of giving specific coordinates and size of each controls, you can say for example
that the right edge of this label has to be put <tt class="o">0.5em</tt> (a unit proportional to the font's size)
to the left edge of this edit field, whose right edge will be anchored at <tt class="o">1em</tt> from
the right edge of its container box.

<p>This way you <b>solve two problems</b> in one shot:
<ol>
  <li>Your application is mostly <b>DPI agnostic</b>: you can change the font size at will (at least
  within reasonable limits) and your interface will still be lay out correctly.

  <li>Likewise, this will also allow you to change all the messages of your application, while being
  sure no one will be clipped or leave too much white space: <b>internationalization</b> will then
  mostly consist of marking messages to be translated, extract them (a <a href="#msgextract">dedicated
  tool</a> is available) and then provide a translation of the resulting file.
</ol>

<p>You can visualize this as anchors that tied widgets together. As the container box is enlarged, it
will stretch controls that are trapped between two anchors (like the edit fields in the example below,
see <span class="marker small">1</span> and <span class="marker small">2</span>)
or move the controls that are attached only on one side (like the cancel button, see <span class="marker small">3</span>):

<div class="image">
  <img id="diagex1" src="images/sample_ui.png" alt="Geometry management" style="border: 0; box-shadow: none">
  <img class="overlay" src="images/sample_ui_attach.png" style="border: 0; box-shadow: none">
  <span class="marker" style="top: 207px; left: 380px">1<span class="linel" style="width: 50px"></span></span>
  <span class="marker" style="top: 248px; left: 380px">2<span class="linel" style="width: 50px"></span></span>
  <span class="marker" style="top: 425px; left: 380px">3<span class="linel" style="width: 50px"></span></span>
</div>

<p>This toolkit defines <b>8 types of anchors</b> (will also be referred as
attachments). Here is a broad overview of what each does:</p>

<ol>
  <li><tt class="dt">SITV_AttachNone</tt>: This is the <b>default attachment for the position
  and dimension of the control</b>. The default value for the position is the
  point (0, 0), relative to the parent widget. The default value for the
  dimension is the minimal box so that the entire content is visible.</li>
  <li><tt class="dt">SITV_AttachForm</tt>: <b>relative to one of the four borders</b> of the
  parent widget.</li>
  <li><tt class="dt">SITV_AttachPosition</tt>: relative to a <b>certain percentage</b> of the
  width/height of its parent.</li>
  <li><tt class="dt">SITV_AttachWidget</tt>: relative to <b>another widget</b> (has to be in the
  same branch of the control tree).</li>
  <li><tt class="dt">SITV_AttachOpposite</tt>: like <tt>SITV_AttachWidget</tt>, but will use the
  <b>opposite border</b>.</li>
  <li><tt class="dt">SITV_AttachMiddle</tt>: will align the width/height of the control
  in the <b>middle of width/height</b> of specified widget (usually used by labels,
  like in the example above, where the top position has this kind of
  attachment).</li>
  <li><tt class="dt">SITV_AttachNoOverlap</tt>: a mix between <tt>Widget</tt> and
  <tt>None</tt>. This is to help the layout manager to compute the minimal
  dialog size without having controls overlapping each other.
  <li><tt class="dt">SIT_MaxWidth</tt>: given a list of widgets, it will <b>set all their
  widths to the widest one</b>. This is usually targeted for labels, or buttons.
  As its prefix implies, it is an attribute, not a value.</li>
</ol>

<p>This seems like a lot, but you will quickly find out that this is just the
bare minimum. The simple example above already uses 6 out of the 8 possible
types of attachment, it is not uncommon to use all the 8 even with a very
simple dialog (actually just adding a button between Ok and Cancel will make
use of all 8 attachments).</p>

<p>Attachments can also be visualized as <b>virtual lines that extend each border of
the controls</b>. Other widgets can then align themselves along those lines. In the
example below, the "Cancel" button has a <tt>Form</tt> attachment on its top
border and a <tt>Widget</tt> type on its left border. Right and bottom are
set to <tt>None</tt>:</p>

<div class="photo">
  <img src="images/attach_lines.png">
  <img class="overlay" src="images/attach_lines_overlay.png" style="border: 0; box-shadow: none; left: 50%; margin-left: -197px">
</div>

<p>One critical point to keep in mind is that <b>horizontal constraints are evaluated independently
from vertical ones</b>. This is particularly critical when trying to avoid circular dependencies. This
is an area where the layout manager could still get some improvements, but in order to keep the code
as simple as possible (and the current code is already far from trivial), more often than not, a circular
dependency will cause an <b>infinite loop</b>.

<p>Now you had an overview of how geometry is managed, it is time to know how to use them using the
correct tag/value pairs.

<h3 id="attachment"><span>Attachment specification</span></h3>

<p>To completely define the geometry of your widget, you'll have to <b>specify at most 4 attachments</b>:
one for each border. To do this, there are 4 properties that are inherited by nearly all controls intended
to be used within containers/dialogs:

<ol class="compact">
  <li><tt class="dt">SIT_LeftAttachment</tt></li>
  <li><tt class="dt">SIT_TopAttachment</tt></li>
  <li><tt class="dt">SIT_RightAttachment</tt></li>
  <li><tt class="dt">SIT_BottomAttachment</tt></li>
</ol>

<p>All of them take a <b>single argument: the type of attachment</b> you might want to apply to the specified
border (<tt>SITV_Attach*</tt>). The <tt>SITV_Widget</tt>, <tt>SITV_Opposite</tt>, <tt>SITV_NoOverlap</tt>
and <tt>SITV_Middle</tt> types of attachment <b>require a relative widget</b> to do their job, otherwise
you'll get an error, and your program will exit immediately (harsh, but let it motivate you to test
your code). This is done using another set of attributes:

<ol class="compact">
  <li><tt class="dt">SIT_LeftObject</tt></li>
  <li><tt class="dt">SIT_TopObject</tt></li>
  <li><tt class="dt">SIT_RightObject</tt></li>
  <li><tt class="dt">SIT_BottomObject</tt></li>
</ol>

<p>The expected argument for this kind of attributes is a <tt>SIT_Widget</tt> object, obtained by a
former call to <tt>SIT_CreateWidget()</tt>. Remember that the order in which tags are given to
<tt>SIT_CreateWidget()</tt> <b>does not matter</b>, you can set <tt>SIT_LeftObject</tt> before
<tt>SIT_LeftAttachment</tt> for example. You can even set these properties for attachment that does
not require a relative object (<tt>SITV_None</tt>, <tt>SITV_Form</tt>, ...), the argument will be
simply ignored. Also, geometric properties don't have to be set at creation time, this is particularly
important when you have two widgets referring to each other.

<p>There is a <b>third group of properties</b> that you might find interesting: usually you'll want to
specify <b>some space between your controls</b> and their attachments. This is done using this set of
properties:

<ol class="compact">
  <li><tt class="dt">SIT_LeftOffset</tt></li>
  <li><tt class="dt">SIT_TopOffset</tt></li>
  <li><tt class="dt">SIT_RightOffset</tt></li>
  <li><tt class="dt">SIT_BottomOffset</tt></li>
</ol>

<p>These attributes accept an integer (<tt class="t">int</tt>) as argument, that <b>specify the amount
of pixels</b> between the constraint. However pixels are <b>not DPI agnostic</b>, as it can be nearly
impossible to find a good compromise using only pixels, between low and high resolution displays.
That's why most attributes that accept a length in <tt>SITGL</tt> will allow you to specify a
dimension relative to the font height, known as <tt class="o">Em</tt>. By using the macro
<tt>SITV_Em(em)</tt>, the <tt>em</tt> argument will be <b>multiplied by the widget font's height</b>
(this macro accepts floating numbers). Note however that this only works at creation time: if you
change the font size afterwards, the properties that have been set relative to its height, won't be
changed (or, if you really to, you can reset the properties that uses Em units after chaging the font).

<hr>

<p>With this 3 groups of properties in mind, we can now see more precisely how they are used with each
attachment type:

<ul id="attachspec">
  <li><tt class="dt">SITV_AttachNone</tt><br>
  <b>This is the default attachment for all 4 borders</b>, unless specified otherwise. Usually this
  kind of attachment is useful to automatically compute the optimal width and height of your controls
  (like labels, buttons, ...). Offsets and Object groups are ignored. If you want to manually specify
  everything, you'll have to use another set of properties (<tt>SIT_X</tt>, <tt>SIT_Y</tt>,
  <tt>SIT_Width</tt> and <tt>SIT_Height</tt>)

  <li><tt class="dt">SITV_AttachForm</tt><br>
  This will attach your control to the <b>same side of the dialog</b> than the side where this property
  has been set (if set to <tt>SIT_LeftAttachment</tt>, it will be attached to the left side of the dialog).
  Object group is ignored, but offset will specify the distance between your control and the dialog's
  border.

  <li><tt class="dt">SITV_AttachPosition</tt><br>
  A more generalized version of <tt>SITV_AttachForm</tt>, which allows the sides of your control to be
  <b>relative to a fraction of dialog's width/height</b>. Left and Right attachment will always be relative
  to the width, and Top/Bottom will always be relative to the height. To do this, set the corresponding
  Object property using the macro <tt>SITV_AttachPos(percent)</tt>. Offset will also be taken into account,
  can be negative or use the special value <tt>SIT_OffsetCenter</tt>. This will set the offset to (-width/2) or
  (-height/2).

  <p>Knowing this, setting an <tt>SITV_AttachForm</tt> on the left border, is like specifying a
  <tt>SITV_AttachPosition</tt> with <tt>SIT_AttachPos(0)</tt> as argument for the corresponding
  <tt>Object</tt> group. Setting a <tt>SITV_AttachForm</tt> on the right border is like setting
  a <tt>SITV_AttachPosition</tt> with a position set to <tt>SIT_AttachPos(100)</tt>.

  <li><tt class="dt">SITV_AttachWidget</tt><br>
  One of the most common attachment: it will align the border where
  this attachment is set with the <b>opposite</b> border specified
  in the corresponding Object attribute. For example setting a widget attachment
  on the left border, will align this border with the right border of the
  widget specified in the <tt>Object</tt> property. <tt>Offset</tt> will specify
  the distance between the two controls involved.

  <li><tt class="dt">SITV_AttachOpposite</tt><br>
  Similar to <tt>SITV_Widget</tt> attachment, it will align the border where it
  is set, to the <strong>same</strong> border specified in <tt>Object</tt>
  property.

  <p>Strictly speaking, you might object that semantics between <tt>SITV_Opposite</tt> and
  <tt>SITV_Widget</tt> should be inverted. Just remember that "Opposite" does not refer to
  the border it is attached, but the opposite of what is actually done in
  <tt>SITV_Widget</tt> type of attachment. <tt>SITV_Widget</tt> attachment is usually
  way more common, that's why intuitiveness prevails over semantic.

  <li><tt class="dt">SITV_AttachMiddle</tt><br>
  This kind of attachment is usually only set on top or left border. It
  will <b>center the width/height</b> of your control within the width/height of
  the <tt>Object</tt> control.

  <li><tt class="dt">SITV_AttachNoOverlap</tt><br>
  This one is similar to <tt>SITV_Widget</tt>, but instead of attaching two borders, it will make sure
  that the border which has this attachment will not overlap the opposite border of the control you
  specify in the <tt>Object</tt> property. You can set the corresponding <tt>Offset</tt> property to
  indicate the minimal distance between the two controls.
</ul>

<p>That's for the generic property, there is a few more specialized attributes
that you might find useful.

<h3 id="abbreviation"><span>Abbreviation</span></h3>

<p>With all this information, you are now very close to know how to completely layout the
<a href="#diagex1">first example</a> given at the beginning of this section. The cancel button for
example can be specified using the following statement:

<pre>SIT_Widget cancel = SIT_CreateWidget(<val>"Cancel"</val>, SIT_BUTTON, dialog,
	SIT_TopAttachment,   SITV_AttachWidget,
	SIT_TopObject,       editval,
	SIT_TopOffset,       SITV_Em(<val>1</val>),
	SIT_LeftAttachment,  SITV_AttachNoOverlap,
	SIT_LeftObject,      del,
	SIT_LeftOffset,      SITV_Em(<val>0.5</val>),
	SIT_RightAttachment, SITV_AttachForm,
	SIT_RightOffset,     SITV_Em(<val>0.5</val>),
	<val>NULL</val>
);</pre>

<p>Which is rather verbose: 20 arguments, 11 lines. There are hopefully shortcut properties for specifying
a whole group (<tt>Attachment</tt>, <tt>Object</tt> and <tt>Offset</tt>) using a single property:

<ul class="compact">
  <li><tt class="dt">SIT_Left</tt></li>
  <li><tt class="dt">SIT_Top</tt></li>
  <li><tt class="dt">SIT_Right</tt></li>
  <li><tt class="dt">SIT_Bottom</tt></li>
</ul>

<p>Each of these properties expect exactly 3 arguments, <b>in this specific order</b>: the <b>attachment</b>
type, the relative <b>widget</b> (you can give <tt class="o">NULL</tt> if it is not applicable) and the
<b>offset</b>. Once again, be very careful to not forget any arguments, because the library would have
no means to recover, not even to detect it. Using these shortcut properties, the cancel button can also be
instanciated using the following function call:

<pre>SIT_Widget cancel = SIT_CreateWidget(<val>"Cancel"</val>, SIT_BUTTON, dialog,
	SIT_Top,   SITV_AttachWidget,    editval, SITV_Em(<val>1</val>),
	SIT_Left,  SITV_AttachNoOverlap, del,     SITV_Em(<val>0.5</val>),
	SIT_Right, SITV_AttachForm,      <val>NULL</val>,    SITV_Em(<val>0.5</val>),
	<val>NULL</val>
);</pre>

<p>Which is a little more easier to read. Still, we'll see <a href="#serialization">another way</a>
to construct your interface, especially when it contains lots of controls, because it will become tedious
to write it that way.

<h3 id="otherattrs"><span>Other attributes</span></h3>

<p id="manualgeom">Despite all these properties, you might still want to <b>manually configure your
control</b>, especially the width and/or height, since for some controls (canvas, listbox, ...) the
default dimension are 0. To do this, there is another set of 4 properties available:

<ul class="compact">
  <li><tt class="dt">SIT_X</tt></li>
  <li><tt class="dt">SIT_Y</tt></li>
  <li><tt class="dt">SIT_Width</tt></li>
  <li><tt class="dt">SIT_Height</tt></li>
</ul>

<p>You will still be able to specify constraints on left and right border, even if you have given a
value for <tt>SIT_Width</tt>. That way, you'll guarantee that initial width of your control will be
no less than the amount you specified. There is also a <b>shortcut property for this group</b>:
<tt class="dt">SIT_Rect</tt>, which expects 4 integers as arguments, in the order listed above.

<p>If you made your dialog can be resized, the minimal width and/or height you set explicitly might be a
little bit too big, and would like to allow your controls to be resized smaller than the initial
dimension. This is done through the properties <tt class="dt">SIT_MinWidth</tt> and
<tt class="dt">SIT_MinHeight</tt>. It is especially useful for canvas or listbox, where you want to
give them a reasonable width/height initially, but allow them to be resized much smaller than that
later on.

<p>Similarly, if you want your control not to exceed a certain width/height, you can use the
properties <tt class="dt">SIT_MaxBoxWidth</tt> (be careful not to confuse this property with
<tt>SIT_MaxWidth</tt>, see below) or <tt class="dt">SIT_MaxBoxHeight</tt>.

<p>Also, keep in mind that the properties related to width/height <b>applies to the border box</b> of the
control (i.e: the entire box, not just the content like in CSS).

<p>The last remaining property you might be interested in is <tt class="dt">SIT_MaxWidth</tt>, mentioned
at the beginning as the 8th attachment kind. The expected argument is a <tt>SIT_Widget</tt>. You have
to create a linked list between controls that will shared the maximal width. For example:

<pre><com>/* Create some widgets */</com>
SIT_Widget label1 = SIT_CreateWidget(<val>"Label1:"</val>, SIT_LABEL, dialog, <val>NULL</val>);
SIT_Widget label2 = SIT_CreateWidget(<val>"Another label:"</val>, SIT_LABEL, dialog,
						SIT_MaxWidth, label1, <val>NULL</val>);
SIT_Widget label3 = SIT_CreateWidget(<val>"Last:"</val>, SIT_LABEL, dialog, <val>NULL</val>,
						SIT_MaxWidth, label2, <val>NULL</val>);
</pre>

<p>Once again, avoid circular dependencies.</p>

<h3 id="summary"><span>Summary</span></h3>

<p>Just to sum up what we've seen so far, here is the table of all the properties
related to geometry management:

<table class="listview">
<thead>
  <tr><td>Name</td><td>Type</td><td>Description</td>
</thead>
<tbody>
<tr>
  <td><tt>SIT_LeftAttachment</tt></td>
  <td rowspan="4"><type>enum</type></td>
  <td rowspan="4">Border attachment type. See <a href="#attachspec">attachment
  specification</a> for possible values.</td>
</tr><tr>
  <td><tt>SIT_TopAttachment</tt></td>
</tr><tr>
  <td><tt>SIT_RightAttachment</tt></td>
</tr><tr>
  <td><tt>SIT_BottomAttachment</tt></td>
</tr><tr>
  <td><tt>SIT_LeftObject</tt></td>
  <td rowspan="4">SIT_Widget</td>
  <td rowspan="4">Relative control to the attachment specified (if applicable)
  or percentage in case of a <tt>SITV_AttachPosition</tt>.</td>
</tr><tr>
  <td><tt>SIT_TopObject</tt></td>
</tr><tr>
  <td><tt>SIT_RightObject</tt></td>
</tr><tr>
  <td><tt>SIT_BottomObject</tt></td>
</tr><tr>
  <td><tt>SIT_LeftOffset</tt></td>
  <td rowspan="4"><type>int</type></td>
  <td rowspan="4">Distance in pixel between control and attachment. Accept Em unit.</td>
</tr><tr>
  <td><tt>SIT_TopOffset</tt></td>
</tr><tr>
  <td><tt>SIT_RightOffset</tt></td>
</tr><tr>
  <td><tt>SIT_BottomOffset</tt></td>
</tr><tr>
  <td><tt>SIT_Left</tt></td>
  <td rowspan="4"><type>enum</type>,&nbsp;SIT_Widget,&nbsp;<type>int</type></td>
  <td rowspan="4">Shortcut for a group of attachment, object and offset properties. Has to
  be specified in this order.</td>
</tr><tr>
  <td><tt>SIT_Top</tt></td>
</tr><tr>
  <td><tt>SIT_Right</tt></td>
</tr><tr>
  <td><tt>SIT_Bottom</tt></td>
</tr><tr>
  <td><tt>SIT_Margins</tt></td>
  <td><type>int</type>, <type>int</type>, <type>int</type>, <type>int</type></td>
  <td>Shortcut for specifying top, right, bottom and left offset.</td>
</tr><tr>
  <td><tt>SIT_X</tt></td>
  <td rowspan="4"><type>int</type></td>
  <td rowspan="4">Manual positioning of control. Strongly advised to avoid setting
  explicitly X and Y. Width and Height can be useful to override default
  heuristic. Accept Em unit.</td>
</tr><tr>
  <td><tt>SIT_Y</tt></td>
</tr><tr>
  <td><tt>SIT_Width</tt></td>
</tr><tr>
  <td><tt>SIT_Height</tt></td>
</tr><tr>
  <td><tt>SIT_Rect</tt></td>
  <td><type>int</type>, <type>int</type>, <type>int</type>, <type>int</type></td>
  <td>Shortcut for specifying X, Y, Width and Height of control.</td>
<tr>
  <td><tt>SIT_MinWidth</tt></td>
  <td rowspan="2"><type>int</type></td>
  <td rowspan="2">Minimal size the control is allowed to be resized. Used by:
  canvas and listbox. Editbox, slider, progress, combobox will
  honor <tt>SIT_MinWidth</tt>.
<tr>
  <td><tt>SIT_MinHeight</tt></td>
<tr>
  <td><tt>SIT_MaxBoxWidth</tt></td>
  <td rowspan="2"><type>int</type></td>
  <td rowspan="2">Maximal size the control is allowed to have.</td>
<tr>
  <td><tt>SIT_MaxBoxHeight</tt></td>
<tr>
  <td><tt>SIT_MaxWidth</tt></td>
  <td>SIT_Widget</td>
  <td>Linked list of control that will shared the same width.</td>
</tr>
</tbody>
</table>

<h3 id="dialogsize"><span>Relation with dialog size</span></h3>

<p>Now that you know how to specify constraints between your controls, you need to know how the layout
manager will be able to deduce the <b>optimal dimension of the top level window</b>. This process is
done in two passes:

<ol>
  <li>The layout manager will compute the minimal dimension of your dialog, so that no controls overlap
  each other, according to the constraints you've specified. It will use this information to constraint
  the resize handle.
  <li>Then, if the width or height you specify manually for the dialog is greater than the minimal
  dimension, another pass will be done to take into account the size you've given. User will still
  be able to reduce that size down to the optimal minimum.
</ol>

<p>Keep in mind that, with this behavior you <b>cannot place control outside visible view</b>, because
the dialog will be automatically enlarged. If you want to completely hide a control, use the
<tt>SIT_Visible</tt> property. A hidden control will be skipped by the layout manager.

<p>Also, if there are <b>no controls</b> that have a <tt>SITV_AttachForm</tt> attachment on the right
(respectively bottom) side, the layout manager will <b>block resizing</b> operation on the width
(respectively height).

<h3 id="dynamic"><span>Dynamic behavior</span></h3>

<p>So far we have seen how to setup constraints before anything is visible on the screen. There are
some caveats to be aware when <b>modifying constraints on the fly</b>.</p>

<p>Keep in mind that any modifications done within a callback will only be taken into account <b>after
returning to the main event loop</b> (ie: exiting from your function, usually a callback). In the meantime,
you can do whatever you want, including adding, removing (<tt>SIT_RemoveWidget()</tt>) or hiding controls
(through the property <tt>SIT_Visible</tt>), changing constraints, all those modifications will be analyzed
after you give the execution back to this library.

<p>You might wonder what happens to geometric constraints <b>when you hide or remove a control</b>,
while other widgets use it as a relative anchor. The way the library handle this case is to assign
the attachments of the widget being removed/hidden to the same side that any other widget is attached
to. Consider this example:

<div class="image" id="diagex2">
  <img src="images/constraint_sample.png" alt="Constraint sample" style="border: 0; box-shadow: none">
  <span class="marker" style="top: 160px; left: 580px">1<span class="linel" style="width: 70px"></span></span>
  <span class="marker" style="top: 220px; left: 580px">2<span class="linel" style="width: 70px"></span></span>
  <span class="marker" style="top: 310px; left: 580px">3<span class="linel" style="width: 70px"></span></span>
</div>

<p>The "Ok" and "Cancel" (<span class="marker small">3</span>) buttons have their top attachment set to
<tt>SITV_AttachWidget</tt> relative to the list (<span class="marker small">2</span>), while the list has
its top attachment relative to the downward arrow button (<span class="marker small">1</span>).

<p><b>What happens if you remove/hide the server list?</b> Since the top attachment of the "Ok" and
"Cancel" buttons are no more valid, the top attachment of the list widget will then be assigned to the
top attachment of the "Ok" and "Cancel" buttons, which gives the following result:

<div class="image">
  <img src="images/widget_hidden.png" alt="After removal of list widget" style="border: 0; box-shadow: none">
</div>

<p>In case the button is only hidden instead of removed, this behavior is temporary. If you didn't
change the constraints in the meantime, next time you'll show the list, the top attachment of the
"Ok" and "Cancel" buttons will be restored, ie: you'll get again what you have in the first example.

<p>Keep in mind that all of this was achieved, just by hiding the list and nothing more: the attachments
of the various controls were reassigned and the window got resize to match the new content size.

<h3 id="pitfalls"><span>Pitfalls</span></h3>

<p>Setting up constraints is usually not that hard, but there are cases where you'll get some 
<b>unexpected behaviour</b>.

<p>The most classical pitfall is having circular dependency between your constraints. This library has
a crude but small algorithm to detect those, which will be reported through a fatal error (which seems
harsh, but at this point the user interface will be probably unusable). The good use is if it works
the first time, there will be very little surprise afterward.

<h2 id="serialization">Reducing code overhead</h2>

<p>As mentioned in the previous chapter, creating an interface through a series of <tt>SIT_CreateWidget()</tt>
function calls can become very tedious, not to mention a code layout that hardly give any hints as to
where a given part of the interface is being created. Consider the login/password dialog presented
<a href="#diagex2">here</a>, a way to implement that interface using tags/values would be:

<pre><type>static</type> <type>void</type> createUI(SIT_Widget app)
{
	SIT_Widget diag = SIT_CreateWidget(<val>"nanovg"</val>, SIT_DIALOG, app,
		SIT_Title,        <val>"Login screen"</val>,
		SIT_DialogStyles, SITV_Movable,
		<val>NULL</val>
	);

	SIT_Widget ctrl = SIT_CreateWidget(<val>"blurb"</val>, SIT_LABEL, diag,
		SIT_Title,           <val>"&lt;b&gt;NSA&lt;/b&gt; supper &lt;u&gt;secret&lt;/u&gt; network login access."</val>,
		SIT_LeftAttachment,  SITV_AttachForm,
		SIT_RightAttachment, SITV_AttachForm,
		<val>NULL</val>
	);

	SIT_Widget label1 = SIT_CreateWidget(<val>"logintxt"</val>, SIT_LABEL, diag,
		SIT_Title,           <val>"Login:"</val>,
		<val>NULL</val>
	);

	SIT_Widget login = SIT_CreateWidget(<val>"login"</val>, SIT_EDITBOX, diag,
		SIT_Title,           <val>"Haxxor"</val>,
		SIT_Width,           SITV_Em(<val>15</val>),
		SIT_Left,            SITV_AttachWidget, label1, SITV_Em(<val>1</val>),
		SIT_Top,             SITV_AttachWidget, ctrl,  SITV_Em(<val>1</val>),
		SIT_RightAttachment, SITV_AttachForm,
		<val>NULL</val>
	);

	SIT_Widget label2 = SIT_CreateWidget(<val>"passwdtxt"</val>, SIT_LABEL, diag,
		SIT_Title,           <val>"Password:"</val>,
		SIT_MaxWidth,        label1,
		<val>NULL</val>
	);

	SIT_Widget passwd = SIT_CreateWidget(<val>"passwd"</val>, SIT_EDITBOX, diag,
		SIT_Title,           <val>"12345"</val>,
		SIT_EditType,        SITV_Password,
		SIT_Width,           SITV_Em(<val>15</val>),
		SIT_Left,            SITV_AttachWidget, label2, SITV_Em(<val>1</val>),
		SIT_Top,             SITV_AttachWidget, login,  SITV_Em(<val>1</val>),
		SIT_RightAttachment, SITV_AttachForm,
		<val>NULL</val>
	);

	SIT_Widget label3 = SIT_CreateWidget(<val>"srvtxt"</val>, SIT_LABEL, diag,
		SIT_Title,           <val>"Server:"</val>,
		SIT_MaxWidth,        label2,
		<val>NULL</val>
	);

	SIT_Widget show = SIT_CreateWidget(<val>"show"</val>, SIT_BUTTON, diag,
		SIT_Title,           <val>"</val><spe>\xE2\x96\xBC</spe><val>"</val>,
		SIT_Top,             SITV_AttachWidget, passwd,  SITV_Em(<val>1</val>),
		SIT_RightAttachment, SITV_AttachForm,
		<val>NULL</val>
	);

	SIT_Widget server = SIT_CreateWidget(<val>"server"</val>, SIT_EDITBOX, diag,
		SIT_Title,           <val>"nsa.gov.cn.fbi"</val>,
		SIT_Width,           SITV_Em(<val>15</val>),
		SIT_Left,            SITV_AttachWidget, label3, SITV_Em(<val>1</val>),
		SIT_Top,             SITV_AttachWidget, passwd, SITV_Em(<val>1</val>),
		SIT_Right,           SITV_AttachWidget, show,   SITV_Em(<val>1</val>),
		<val>NULL</val>
	);

	SIT_Widget srvlist = SIT_CreateWidget(<val>"srvlist"</val>, SIT_LISTBOX, diag,
		SIT_LeftAttachment,  SITV_AttachForm,
		SIT_RightAttachment, SITV_AttachForm,
		SIT_Top,             SITV_AttachWidget, server, SITV_Em(<val>1</val>),
		SIT_Height,          SITV_Em(<val>5</val>),
		SIT_ViewMode,        SITV_ListViewReport,
		SIT_ColumnNames,     <val>"Name"</val>,
		SIT_ListBoxFlags,    SITV_NoHeaders,
		<val>NULL</val>
	);

	SIT_CreateWidget(<val>"listtitle"</val>, SIT_LABEL, diag,
		SIT_Title,           <val>"Server list:"</val>,
		SIT_Left,            SITV_AttachOpposite, srvlist, SITV_Em(<val>2</val>),
		SIT_Top,             SITV_AttachOpposite, srvlist, <val>0</val>,
		<val>NULL</val>
	);

	SIT_Widget ok = SIT_CreateWidget(<val>"ok"</val>, SIT_BUTTON, diag,
		SIT_Title,           <val>"Ok"</val>,
		SIT_Classes,         <val>"def"</val>,
		SIT_Top,             SITV_AttachWidget, srvlist, SITV_Em(<val>1</val>),
		<val>NULL</val>
	);

	SIT_CreateWidget(<val>"cancel"</val>, SIT_BUTTON, diag,
		SIT_Title,           <val>"Cancel"</val>,
		SIT_Top,             SITV_AttachOpposite, ok, <val>0</val>,
		SIT_RightAttachment, SITV_AttachForm,
		SIT_MaxWidth,        ok,
		<val>NULL</val>
	);

	SIT_SetValues(label1, SIT_Top, SITV_AttachMiddle, login,  <val>0</val>, <val>NULL</val>);
	SIT_SetValues(label2, SIT_Top, SITV_AttachMiddle, passwd, <val>0</val>, <val>NULL</val>);
	SIT_SetValues(label3, SIT_Top, SITV_AttachMiddle, server, <val>0</val>, <val>NULL</val>);
	SIT_SetValues(SIT_GetById(diag, <val>"close"</val>), SIT_Title, <val>"[X]"</val>, <val>NULL</val>);
	SIT_SetValues(SIT_GetById(diag, <val>"title"</val>),
		SIT_Left,  SITV_AttachPosition, SITV_AttachPos(<val>50</val>), SITV_OffsetCenter,
		SIT_Right, SITV_AttachNone, <val>NULL</val>, <val>0</val>,
		<val>NULL</val>
	);

	SIT_Widget list = SIT_GetById(diag, <val>"srvlist"</val>);

	SIT_ListInsertItem(list, -<val>1</val>, <val>NULL</val>, <val>"ns4.org.gov.cn"</val>, <val>NULL</val>);
	SIT_ListInsertItem(list, -<val>1</val>, <val>NULL</val>, <val>"not-fake-real-nsa.com"</val>, <val>NULL</val>);
	SIT_ListInsertItem(list, -<val>1</val>, <val>NULL</val>, <val>"nsa.gov.cn.fbi"</val>, <val>NULL</val>);
	SIT_AddCallback(SIT_GetById(diag, <val>"show"</val>), SITE_OnActivate, showHide, list);

	SIT_ManageWidget(diag);
}</pre>

<p>Which is rather verbose and confusing, because all those statements look very similar. Hopefully,
this library has <b>another interface for creating widgets and setting attributes</b>.

<p>This API is <b>not a complete replacement</b> of the generic tag/value model. It is especially
targeted to those interfaces that consist mostly of static content, with lots of controls and very few
room for building them through loops. In such case, using the plain <tt>SIT_CreateWidget()</tt> is very
tedious. On the other way, if you created your interface through control structures, like
<tt class="k">for</tt>, <tt class="k">while</tt> or <tt class="k">if</tt>, this API is poorly suited.
The good news is that both APIs can be perfectly mixed together, since at its heart, this API is just
a fancy wrapper around the <tt>SIT_CreateWidget()</tt> and <tt>SIT_SetValues()</tt> functions.</p>

<h3 id="serialized"><span>The serialized model</span></h3>

<p>To understand how this interface works, we need to go back to where we
introduced the tag/value model. So far, every time we try to set an attribute
(a.k.a tag or property) we used an enumeration like <tt>SIT_Title</tt>,
<tt>SIT_Left</tt>, ... Actually every properties have also a string associated.
This string is case-insensitive and is simply the enumeration value, without the
<tt>SIT_</tt> prefix. Internally they are written using camel case, e.g.
<tt>SIT_LeftAttachment</tt> can be accessed through <tt class="o">"leftAttachment"</tt>.

<p>Those strings can be used to <b>form HTML-like tags</b> with key/value statements
to create controls or set their values. If you want to create a control, the
tag name is actually the control type, whereas if you want to set attributes,
the tag name is actually the control's name for which attributes will be set.
The tag name is then followed by a list of key/value pairs, using the HTML
notation: <tt>key=value</tt>, where <tt>value</tt> can be enclosed by single
or double quotes if it contains spaces. To escape a value use the
<tt>&amp;#DD;</tt> or <tt>&amp;#xXX;</tt> notation, where <tt>DD</tt> is a
decimal number and <tt>XX</tt> an hexadecimal one, representing the <b>unicode
code point</b> of the character you want to escape (anti-slash will be interpreted
as a normal character and other HTML entities are not recognized).</p>

<p>There is one special key that <b>does not have a corresponding enumeration
property</b>: it is the name of the control (since it is given as the first argument
to <tt>SIT_CreateWidget()</tt>). As you would surely have guessed by yourself now,
the key to set this information is simply "<tt>name</tt>". This key is actually
a little bit more important when using this API, than when using the tag/value
model, because widget's name can be used wherever a widget pointer is expected
(especially in places like attachments).

<p>For example, to create a label as a child of a given dialog, you can use
the following function call:</p>

<pre id="SIT_CreateWidgets">SIT_CreateWidgets(dialog, <val>"&lt;label name=hello title='hello, world'&gt;"</val>);</pre>

<p>Remember that just like with <a href="#hierarchy"><tt>SIT_CreateWidget</tt></a> function, the
<tt>name</tt> property can also be used to override the default tag name, and/or already give a class
name, without having to manually set the <tt>SIT_Classes</tt> property.

<p>For properties that require more than one argument, you'll have to specify
them using a comma-separated list. Missing arguments will be set to
<tt class="o">0</tt> or <tt class="o">NULL</tt>. For example:</p>

<pre>SIT_CreateWidgets(dialog,
	<val>"&lt;label name=sep left=FORM right=FORM top=WIDGET,server,5 overflow=1&gt;"</val>);</pre>

<p>That means the comma is a special character, and if you ever want to include
it in a string, you will have to single or double quote it. When combined with
multiple arguments, remember to leave the comma outside the quotes, like this:

<pre>SIT_CreateWidgets(dialog,
	<val>"&lt;label name=sep left=FORM right=FORM top=WIDGET,'hello, world',5 overflow=1&gt;"</val>);</pre>

<p>The following table lists the available tag names that can be created:</p>

<table class="listview pad">
<thead>
  <tr><td>Tag name</td><td>SIT Type</td>
	  <td>Tag name</td><td>SIT Type</td></tr>
</thead>
<tbody>
  <tr><td><tt>label</tt></td><td><a href="#SIT_LABEL"><tt>SIT_LABEL</tt></a></td>
	  <td><tt>button</tt></td><td><a href="#SIT_BUTTON"><tt>SIT_BUTTON</tt></a></td></tr>
  <tr><td><tt>frame</tt></td><td><a href="#SIT_FRAME"><tt>SIT_FRAME</tt></a></td>
	  <td><tt>listbox</tt></td><td><a href="#SIT_LISTBOX"><tt>SIT_LISTBOX</tt></a></td></tr>
  <tr><td><tt>canvas</tt></td><td><a href="#SIT_CANVAS"><tt>SIT_CANVAS</tt></a></td>
	  <td><tt>scrollbar</tt></td><td><a href="#SIT_SCROLLBAR"><tt>SIT_SCROLLBAR</tt></a></td></tr>
  <tr><td><tt>slider</tt></td><td><a href="#SIT_SLIDER"><tt>SIT_SLIDER</tt></a></td>
	  <td><tt>progress</tt></td><td><a href="#SIT_PROGRESS"><tt>SIT_PROGRESS</tt></a></td></tr>
  <tr><td><tt>combobox</tt></td><td><a href="#SIT_COMBOBOX"><tt>SIT_COMBOBOX</tt></a></td>
	  <td><tt>tooltip</tt></td><td><a href="#SIT_TOOLTIP"><tt>SIT_TOOLTIP</tt></a></td></tr>
  <tr><td><tt>tab</tt></td><td><a href="#SIT_TAB"><tt>SIT_TAB</tt></a></td>
	  <td><tt>editbox</tt></td><td><a href="#SIT_EDITBOX"><tt>SIT_EDITBOX</tt></a></td>
</tbody>
</table>

<p>Which is basically like the enumeration without the <tt>SIT_</tt> prefix. Also tag names are <b>not
case sensitive</b>.

<h3 id="enums"><span>Using enumeration values</span></h3>

<p>Some properties expect an enumeration value, which, in the end, <b>is only an
integer</b>. But, except for attachment specification, this interface has no means to
translate a string into a numeric value, unless the string is an integer by
itself (like we do for the <tt>overflow</tt> property in the example above: 1 is the
value for <tt>SITV_Hidden</tt>). Since remembering what's the integer
value for all those attributes is way too tedious, this interface allows you to
specify directly the enumeration value, <b>by ending prematurely the string</b> just
after the equal sign, and then give the arguments as you would have with the
<tt>SIT_CreateWidget()</tt> function. The example above can also be written
that way:</p>

<pre>SIT_CreateWidgets(dialog,
	<val>"&lt;label name=sep left=FORM right=FORM top="</val>, SITV_AttachWidget, server, <val>5</val>,
	<val>"overflow=&quot;</val>, SITV_Hidden, <val>"&gt;"</val>);</pre>

<p>The only caveat is when an attribute requires more than one value. If you
specify one argument using a <em>vararg</em>, <b>all of them must be specified
the same way</b>, and just like with the <tt>SIT_CreateWidget()</tt> function,
be careful to not miss one.</p>

<p>A few predefined constants are available for the <tt>SIT_LeftAttachment</tt>,
<tt>SIT_TopAttachment</tt>, <tt>SIT_RightAttachment</tt> and <tt>SIT_BottomAttachment</tt>
properties (also available for the one that indirectly reference them, like
<tt>SIT_Left</tt>, ...). You can use the following string in place of the
corresponding integer:</p>

<table class="listview pad">
<thead>
  <tr><td>Tag name</td><td>SIT Type</td>
	  <td>Tag name</td><td>SIT Type</td></tr>
</thead>
<tbody>
  <tr><td><tt>NONE</tt></td><td><tt>SITV_AttachNone</tt></td>
	  <td><tt>FORM</tt></td><td><tt>SITV_AttachForm</tt></td></tr>
  <tr><td><tt>OPPOSITE</tt></td><td><tt>SITV_AttachOpposite</tt></td>
	  <td><tt>MIDDLE</tt></td><td><tt>SITV_AttachMiddle</tt></td></tr>
  <tr><td><tt>NOOVERLAP</tt></td><td><tt>SITV_AttachNoOverlap</tt></td>
	  <td><tt>POSITION</tt></td><td><tt>SITV_AttachPosition</tt></td></tr>
  <tr><td><tt>WIDGET</tt></td><td><tt>SITV_AttachWidget</tt></td>
	  <td></td><td></td></tr>
</tbody>
</table>

<p>Also, for the <tt>SIT_*Object</tt> group, if you use a string specification,
the argument will be <b>interpreted as a widget name</b>, that will be searched with
<tt>SIT_GetById()</tt>. You have to be sure the widget exists though: this
is the primary reason why widgets are first created, and then you set
their layout attributes.</p>

<p>Once all arguments have been given, you can continue your string to specify
more attributes, or create more controls.</p>

<h3 id="nestedtags"><span>Nested tags</span></h3>

<p>Some controls are designed to be used as container for other controls, and
as such will require an explicit closing tag, otherwise all subsequent tag
declarations will be created as children of this control. For instance, there
is <b>3 controls that do this implicit behavior</b>:

<ul class="compact">
  <li><tt>SIT_CANVAS</tt>
  <li><tt>SIT_TAB</tt>
  <li><tt>SIT_FRAME</tt>
</ul>

<p>If you want to nest controls in a container that does not nest by default, you'll have to use <tt>SIT_GetById()</tt>
first, then perform a separate <tt>SIT_CreateWidgets()</tt> call.</p>

<p>Also as a little shortcut, if your tag declaration doesn't contain any
children, you can end it using the XML notation: <tt>/&gt;</tt>, sparing you
the hassle to write the ending tag. Actually it doesn't hurt if you specify
it even for non-nesting tags.</p>

<h3 id="example"><span>Example</span></h3>

<p>Knowing all this, you are now able to rewrite the example given at the
beginning to use this new interface (you'll have to check the detail of each widget types to know
what properties they accept though):

<pre><type>static</type> <type>int</type> showHide(SIT_Widget w, <type>APTR</type> cd, <type>APTR</type> ud)
{
	Bool visible;
	SIT_GetValues(ud, SIT_Visible, &amp;visible, <val>NULL</val>); visible = !visible;
	SIT_SetValues(ud, SIT_Visible,  visible, <val>NULL</val>);
	SIT_SetValues(SIT_GetById(w, <val>"../listtitle"</val>), SIT_Visible, visible, <val>NULL</val>);
	<kwd>return</kwd> <val>1</val>;
}

<type>static</type> <type>void</type> createUI(SIT_Widget app)
{
	SIT_Widget diag = SIT_CreateWidget(<val>"nanovg"</val>, SIT_DIALOG, app,
		SIT_Title,        <val>"Login screen"</val>,
		SIT_DialogStyles, SITV_Movable,
		<val>NULL</val>
	);

	SIT_CreateWidgets(diag,
		<val>"&lt;label name=blurb title="</val>, <val>"&lt;b&gt;NSA&lt;/b&gt; supper &lt;u&gt;secret&lt;/u&gt; network login access."</val>, <val>"left=FORM right=FORM&gt;"</val>
		<val>"&lt;label name=logintxt title=Login:&gt;"</val>
		<val>"&lt;editbox name=login title='Haxxor' width=15em left=WIDGET,logintxt,1em top=WIDGET,blurb,1em right=FORM&gt;"</val>
		<val>"&lt;label name=passwdtxt maxWidth=logintxt title=Password:&gt;"</val>
		<val>"&lt;editbox name=passwd title='12345' width=15em left=WIDGET,logintxt,1em editType="</val>, SITV_Password, <val>"top=WIDGET,login,1em right=FORM&gt;"</val>
		<val>"&lt;label name=srvtxt maxWidth=passwdtxt title=Server:&gt;"</val>
		<val>"&lt;button name=show title='&amp;#x25bc;' top=WIDGET,passwd,1em right=FORM&gt;"</val>
		<val>"&lt;editbox name=server title='nsa.gov.cn.fbi' width=15em left=WIDGET,srvtxt,1em top=WIDGET,passwd,1em right=WIDGET,show,1em&gt;"</val>
		<val>"&lt;listbox name=srvlist top=WIDGET,server,1em left=FORM right=FORM height=5em viewMode="</val>, SITV_ListViewReport, <val>"columnNames=Name/&gt;"</val>
		<val>"&lt;label name=listtitle title='Server list:' left=OPPOSITE,srvlist,2em top=OPPOSITE,srvlist&gt;"</val>
		<val>"&lt;button name=ok.def title=Ok top=WIDGET,srvlist,1em&gt;"</val>
		<val>"&lt;button name=cancel maxWidth=ok title=Cancel right=FORM top=OPPOSITE,ok&gt;"</val>
	);
	SIT_SetAttributes(diag,
		<val>"&lt;logintxt top=MIDDLE,login&gt;&lt;passwdtxt top=MIDDLE,passwd&gt;&lt;srvtxt top=MIDDLE,server&gt;&lt;show nextCtrl=ok&gt;&lt;ok nextCtrl=cancel&gt;"</val>
		<val>"&lt;close title='[X]'&gt;&lt;title left="</val>, SITV_AttachPosition, SITV_AttachPos(<val>50</val>), SITV_OffsetCenter, <val>"right=NONE&gt;"</val>
	);
	SIT_Widget list = SIT_GetById(diag, <val>"srvlist"</val>);

	SIT_ListInsertItem(list, -<val>1</val>, <val>NULL</val>, <val>"ns4.org.gov.cn"</val>, <val>NULL</val>);
	SIT_ListInsertItem(list, -<val>1</val>, <val>NULL</val>, <val>"not-fake-real-nsa.com"</val>, <val>NULL</val>);
	SIT_ListInsertItem(list, -<val>1</val>, <val>NULL</val>, <val>"nsa.gov.cn.fbi"</val>, <val>NULL</val>);
	SIT_AddCallback(SIT_GetById(diag, <val>"show"</val>), SITE_OnActivate, showHide, list);

	SIT_ManageWidget(diag);
}</pre>

<p>Which is quite a bit shorter and therefore a lot more pleasant to write, that the never ending stream
of <tt>SIT_CreateWidget</tt> calls.

<h2 id="events">Events/callbacks</h2>

<p>Before we see the different kind of controls more in detail, you'll need to have an overview on
<b>how events are processed</b> in this library. Just like widget creation, event interface uses a
generic approach: you typically register a callback that will be triggered whenever the action
is notified by the system.

<h3 id="evtreg"><span>Registration</span></h3>

<p>Registration for a particular event is done by using the following function:

<pre><type>void</type> SIT_AddCallback(SIT_Widget widget, <type>int</type> type, SIT_CallProc proc, APTR data);</pre>

<p>Each arguments of this function are pretty straightforward, for the sake of
completeness, here are the detailed meaning of each of them:</p>
<ul>
  <li><tt>widget</tt>: The target control that will report the event you want.</li>
  <li><tt>type</tt>: The type of event you want to be notified. Remember that
  event type are prefixed by <tt>SITE_</tt>.</li>
  <li><tt>proc</tt>: Your callback, its prototype will be emphasized below.</li>
  <li><tt>data</tt>: A userdata you can register along with the callback that
  will be given again whenever your callback is invoked.</li>
</ul>

<p>Every callback you'll register for every kind of event, will always <b>use the same prototype</b>.
Remember it well, because you'll use it a lot in every program. For those who might wonder, yes, this
prototype comes straight from <tt>Xt</tt>, almost unmodified:</p>

<pre><type>int</type> callback(SIT_Widget widget, APTR call_data, APTR user_data);</pre>

<div class="bgtip"><p class="tip">Most text editor/development environment can define <b>abbreviations</b>
that can be expanded to a full declaration. It is strongly advised to keep the prototype of event callback
into such an abbreviation, like this:

<span class="preformat"><type>int</type> |(SIT_Widget widget, APTR call_data, APTR user_data)
{
	;
	<kwd>return</kwd> <val>1</val>;
}</span>
</div>

<p>Once again arguments are pretty straightforward:</p>
<ul>
  <li><tt>widget</tt>: the first argument you gave to <tt>SIT_AddCallback()</tt>, when
  you registered your callback.</li>

  <li><tt>call_data</tt>: this is a data structure that depends on the type
  of callback you register. For example, if you register your callback for an
  <tt>SITE_OnPaint</tt> event, <tt>call_data</tt> will point to a <tt>SIT_OnPaint</tt>
  structure. A more detailed description will be given below.

  <p>Whatever object is passed to your callback, it remains the property of this
  library. You are usually allowed to modify them (including strings or array), but
  <strong>never attempt to free any of them yourself, nor keep a reference past the
  end of your callback</strong> (unless it is an atomic type): most of these objects
  reside on the stack when passed to your callbacks.

  <li><tt>user_data</tt>: the fourth argument you gave to <tt>SIT_AddCallback()</tt>.</li>
</ul>

<p>Unless otherwise stated, the <strong>return value</strong> is used to indicate whether
(<tt class="o">1</tt>) or not (<tt class="o">0</tt>) you processed the event. If you did not process
the event, some default action might take place, like for example keyboard event: if you do not
process the Tab key, it will be used to navigate between controls.

<h3 id="evttype"><span>Event types</span></h3>

<p>Here is what to expect for each different kind of events:</p>

<ul>
  <li><tt class="dt" id="SITE_OnClose">SITE_OnClose</tt>

  <p>This event is only meaningful for <b>top level dialog</b>. It will give you a chance to alert the
  user that there are unsaved data that might be lost if the action is carried on. The <tt>call_data</tt>
  parameter passed to the callback is a pointer to a <tt class="t">Bool</tt>. Set it to
  <tt class="o">False</tt> to cancel the action, or leave it as is to close the dialog.
  Whatever the return code, the value of this boolean will decide whether or not the dialog
  will remain open.

  <li><tt class="dt">SITE_OnActivate</tt>
  <p>Triggered when the user wants to perform an <b>action with the control</b>.
  Typically, it is used with buttons (push, radio or checkbox), HTML link,
  list box, etc ...
  
  <p>Be aware that this is not exactly the same as a click event. For example to trigger a button
  activation, the user must click on the button and release it while the mouse is over the button.
  Whereas a click event will be triggered as soon as the button is clicked.

  <li><tt class="dt">SITE_OnChange</tt>
  <p>This event is to notify that an important state has changed with the control. It is triggered by
  3 controls:
  <ul>
	<li><tt>SIT_TAB</tt>: triggered whenever the <b>active tab has changed</b>. <tt>call_data</tt>
	will be an integer indicating which tab is now active (starting at 0).

	<li><tt>SIT_EDITBOX</tt>: will be fired whenever the <b>content of the edit field has changed</b> one
	way or another (by the user actions or programmatically). <tt>call_data</tt> will be a pointer to a
	<tt class="o">NULL</tt> terminated string representing the entire content of text edit control
	(UTF-8 encoded).

	<p><span class="n">Note</span>: this will be actually a raw pointer used by the control itself.
	<b>DO NOT ALTER THIS STRING</b>, in any way, shape or form, you'll mess up the rendering and/or
	internal pointers for line editing. <b>Do not attempt to free</b> the buffer either, this pointer
	is not necessarily malloc()'ed anyway.
	
	<p>Check out one of the following <a href="#SIT_EDITBOX">chapter</a> to know what can be done
	with this control.

	<li><tt>SIT_LISTBOX</tt>: used to signal that the <b>selection has changed</b> within the control.
	<tt>call_data</tt> will be the <tt>user_data</tt> parameter used to create the cell of the list
	box using the function <a href="#SIT_LISTBOX"><tt>SIT_ListInsertItem()</tt></a>
  </ul>

  <li><tt class="dt" id="SITE_OnFocus">SITE_OnFocus</tt>, <tt class="dt">SITE_OnBlur</tt>
  <p>A pair of similar events. Used to notify <b>keyboard focus change</b>.
  <tt>call_data</tt> will be <tt class="o">1</tt> for <tt>SITE_OnFocus</tt> event, and <tt class="o">0</tt>
  for <tt>SITE_OnBlur</tt>. Avoid canceling those event. If you want your
  focus to remain on a particular control, block focus on the other controls.
  instead.

  <li><tt class="dt" id="SITE_OnFinalize">SITE_OnFinalize</tt>
  <p>Will be triggered when the control is <b>about to be destroyed</b>. It will give
  you a chance to free any resources you might have allocated. <tt>call_data</tt> will always be
  <tt class="o">NULL</tt>.

  <p>As your application grows larger, you'll end up inevitably having global variables holding a reference
  to a widget. If that widget got deleted at some point, those references will become invalid and cause
  a crash if you attempt to access them. Clearing those references in a <tt>SITE_OnFinalize</tt> callback
  is the way to handle this problem.
  
  <p><span class="n">Note</span>: you have to be careful with the <b>resources not associated with
  this control</b>. If this event is sent because the parent control is being deleted (typically a window
  has been closed), it will not be safe to access to the control hierarchy at this point, as other
  controls might have already been deleted (especially if you have kept pointers to other widgets,
  you have to assume they do not point to valid memory anymore).

  <li><tt class="dt">SITE_OnClick</tt>
  <p>This event is used to report <b>mouse actions</b> (left click, right click,
  mouse wheel, ...). Mouse events will be described more in details in one of the
  next chapter, when talking about <a href="#SIT_CANVAS">canvas</a>. The <tt>call_data</tt> will be a
  pointer to a <tt>SIT_OnMouse</tt> structure (this datatype is not a pointer,
  so don't forget the star when casting the <tt>call_data</tt>).

  <li><tt class="dt">SITE_OnMouseMove</tt>
  <p>Will report <b>mouse movement</b> within control. <tt>call_data</tt> will be a
  pointer to a <tt>SIT_OnMouse</tt> structure. It is actually quite common
  to use the same callback for <tt>OnClick</tt> and <tt>OnMouseMove</tt>, so
  much that a shortcut name exists: <tt>SITE_OnClickMove</tt>. It will register
  your callback and associated data for both <tt>SITE_OnClick</tt> and <tt>SITE_OnMouseMove</tt>.
  The <tt>x</tt> and <tt>y</tt> member of the <tt>SIT_OnMouse</tt>
  structure will be relative to top left corner of the control. This event
  and the previous will be described more thoroughly in the next <a href="#SIT_CANVAS">chapter</a>.

  <li><tt class="dt">SITE_OnClickMove</tt>
  <li>This is not a real event type, but just a shortcut for registering the
  same callback for both <tt>SITE_OnClick</tt> and <tt>SITE_OnMouseMove</tt>.
  Indeed, it happens quite often to handle both with the same callback (usually
  mouse movement only matters after some mouse buttons have been pressed).
  Note that if you want to remove the callback, you will have to do this using
  the cannonical names.

  <li><tt class="dt" id="SITE_OnResize">SITE_OnResize</tt>
  <p>Whenever any of your control (including dialog box) is <b>about to be
  resized</b>, this event will be triggered. The <tt>call_data</tt> parameter
  will contain a table of 2 <tt class="t">float</tt>, specifying the new width and height in
  pixels of the control.

  <li><tt class="dt">SITE_OnPaint</tt>
  <p>Used to <b>redraw part of a control</b> and/or dialog. <tt>call_data</tt> is a pointer to a
  <tt>SIT_OnPaint</tt> structure. In here you will be able to get the <tt>nanovg</tt> context used
  to draw whatever you want. Keep in mind that CSS styles will already have been drawn at this point.
  This event makes more sense with <a href="#SIT_CANVAS">canvas</a> and will be described more
  in detail in this section.

  <li><tt class="dt">SITE_OnRawKey</tt>, <tt class="dt">SITE_OnVanillaKey</tt>
  <p>Allow you to get <b>notified by key pressed</b>. <tt>SITE_RawKey</tt>
  is for keys that does not have a dedicated unicode character (like cursor
  keys, Shift, Control, Alt, Page Up, ...), while <tt>SITE_OnVanillaKey</tt>
  will report the actual character (in unicode code point and UTF-8). Both
  events will pass a pointer to a <tt>SIT_OnKey</tt> structure for the
  <tt>call_data</tt> argument. Returning <tt class="o">1</tt> for this
  event will prevent some default action to take place.

  <li><tt class="dt">SITE_OnScroll</tt>
  <p>Sent by Slider and ScrollBar to report the <b>new position the user
  set the thumb</b>. The <tt>call_data</tt> can actually be cast to a ULONG
  to get that position.

  <li><tt class="dt">SITE_OnGeometrySet</tt>
  <p>This is a rather low-level callback. It will give you the opportunity to
  <b>set the size and/or position of your control</b> the way you want (avoid non-linear
  movements: they are very awkward). <tt>call_data</tt> will be a table
  of 3 integers. The first two are positions of the left/right or top/bottom
  border relative to the parent widget. The third is 0 if the values
  refer to the left/right borders or 1 if they refer to the top/bottom. This
  library handle the vertical and horizontal constraints in two separate passes,
  that why you cannot have the whole rectangle of the control at once. Those
  values will be pre-filled according to the constraints specified on the control.

  <p>If you want to change the position and/or the size of the control, simpy modify
  the first two elements as you wish. The typical use case for this event is to
  have a row of more than 3 controls evenly spaced along the width of the dialog
  (the standard attachment model cannot handle this case easily).

  <li><tt class="dt">SITE_OnSortItem</tt>
  <p>Only sent by Listbox, it is used to provide a <b>custom sorting method for items</b> of a list box.
  This event will be described more in detail in the <a href="#listevents">SIT_LISTBOX</a> chapter.

  <li><tt class="dt">SITE_OnSortColumn</tt>
  <p>Another event only sent by the Listbox widget: it will notify you of a <b>new column being selected
  as for the sorting key</b>. You can accept the selection (by returning 1 from your callback) or cancel
  the it (by returning 0). This event will also be described more in detail in the
  <a href="#listevents">dedicated</a> section.

  <li><tt class="dt" id="SITE_OnDropFiles">SITE_OnDropFiles</tt>
  <p>Triggered when files/folders are <b>dropped over the root widget</b> (it will never be
  triggered for other controls). The <tt>call_data</tt> parameter will be a
  <tt class="o">NULL</tt>-terminated table of <tt class="t">STRPTR</tt> containing
  the fully qualified path of each dropped objects (UTF8 encoded).
  As usual, do not keep a reference on those strings past the end of
  your callback.

  <li><tt class="dt">SITE_OnSetOrGet</tt>
  <p>Will be described in the <a href="#">extra widgets</a> chapter.
</ul>

<h3 id="evtredirect"><span>Redirecting events</span></h3>

<p>One feature you'll need at some point is redirecting one event received from a particular widget to
another one. The over typical use case is to redirect keyboard events: if you have an <tt>SIT_EDITBOX</tt>
and a <tt>SIT_LISTBOX</tt> in your interface, you might want to redirect some keys from the edit box
to the listbox when the former has the focus, like up and down arrow to select another item.

<p>The function to do this is:
<pre id="SIT_ApplyCallback"><type>int</type> SIT_ApplyCallback(SIT_Widget, <type>APTR</type> call_data, <type>int</type> type);</pre>

<p>The return code will be the first positive value returned by the callback that processed the event.

<p>Of course, this function can also be used to create events from scratch: you do not need an existing
event to redirect it to another widget. As long as you respect the datatype (<tt>call_data</tt>) for
the event, the targeted widget will see no difference from a user-generated event.

<h3 id="evtsummary"><span>Summary of events and call data</span></h3>

<p>This table will show you a quick summary of what to expect for each event types:

<table class="listview pad">
<thead><tr><td>Event<td>Call data<td>Description</thead>
<tbody>
  <tr><td>SITE_OnClose<td><tt><type>Bool </type>*</tt><td>Triggered when dialog is about to be closed, so that it can be canceled.
  <tr><td>SITE_OnActivate<td><em>none</em><td>It signals that the user want to activate the widget (button, checkbox, radio, ...).
  <tr><td>SITE_OnChange<td><tt><type>int</type></tt><br><tt><type>STRPTR</type></tt><td>Something important changed with the widget.
  <tr><td>SITE_OnFocus<td><tt><val>1</val></tt><td>The control gained the keyboard focus.
  <tr><td>SITE_OnBlur<td><tt><val>0</val></tt><td>The control lost the focus.
  <tr><td>SITE_OnFinalize<td><tt><val>NULL</val></tt><td>The widget is about to be destroyed, you should
  free any resources you allocated with it. 
  <tr><td>SITE_OnClick<td><tt>SIT_OnMouse&nbsp;*</tt><td>A mouse button has been pressed or released within the control.
  <tr><td>SITE_OnMouseMove<td><tt>SIT_OnMouse&nbsp;*</tt><td>The mouse is moving over the control.
  <tr><td>SITE_OnResize<td><tt><type>float </type> [<val>2</val>]</tt><td>The widget has been resized.
  <tr><td>SITE_OnPaint<td><tt>SIT_OnPaint *</tt><td>You can do any custom rendering within the callback.
  <tr><td>SITE_OnRawKey<td><tt>SIT_OnKey *</tt><td>A key without (obvious) unicode character has been pressed or released.
  <tr><td>SITE_OnVanillaKey<td><tt>SIT_OnKey *</tt><td>A key with unicode character has been pressed (no released event will be sent).
  <tr><td>SITE_OnScroll<td><tt><type>ULONG</type></tt><td>Scroll position has changed for a scrollbar or a slider.
  <tr><td>SITE_OnGeometrySet<td><tt><type>float </type>[<val>3</val>]</tt><td>Fine tune size of control during layout of forms.
  <tr><td>SITE_OnSortItem<td><tt>SIT_OnSort *</tt><td>Compare two items to reorder rows of list box.
  <tr><td>SITE_OnSortColumn<td><tt><type>int</type></tt><td>Notify a new column has been selected as key for sorting in a list box.
  <tr><td>SITE_OnDropFiles<td><tt><type>STRPTR </type>*</tt><td>NULL-terminated list of filenames that have been dropped on the root window.
  <tr><td>SITE_OnSetOrGet<td><tt>SIT_OnVal *</tt><td>Custom property setter/getter.
</tbody>
</table>

<h3 id="evtglobal"><span>Global events</span></h3>

<p>At some point, you might want to be <b>notified of any events that happen within your application</b>.
Some event types can be registered at the root widget (the one returned by <tt>SIT_Init()</tt>),
even though, at first glance, it doesn't make sense to register them at this level (like <tt>SITE_OnActivate</tt>
or <tt>SITE_OnFocus</tt>).

<p>The reason to do that is it to trigger the registered callback whenever one of such event happens in
<b>any type of widget</b>. Even though the callback is registered at the root, the widget parameter
will actually be the widget that generated the event.

<p>The typical use case for this feature is to <b>play sounds for some actions</b>, like button press,
key press within controls (typically edit box), focus change, and so on...

<p><b>Tracking focus change</b> will also be required if you have <b>disabled keyboard auto-repeat</b>. Whenever a text
edit widget receive the focus, you might want to re-enable auto-repeat, otherwise text editing will
be somewhat tedious.

<p>The event types that respond globally are:
<ul class="compact">
  <li><tt>SITE_OnClose</tt>
  <li><tt>SITE_OnClick</tt>
  <li><tt>SITE_OnActivate</tt>
  <li><tt>SITE_OnChange</tt>
  <li><tt>SITE_OnFocus</tt>
  <li><tt>SITE_OnBlur</tt>
</ul>

<p><span class="n">Note</span>: global callbacks will be triggered <b>before</b> events on the real
widgets. All the other ones will be triggered only for the root widget.

<p>For example, with SDL1, this is the typical callback you might want to register to enable
auto-repeat when a text edit widget get the focus:
<pre>
<type>static int</type> trackFocus(SIT_Widget w, <type>APTR</type> cd, <type>APTR</type> ud)
{
	<type>static uint8_t</type> repeatOn = <val>0</val>;

	<type>int</type> type;
	<com>/*
	 * note: some widgets will temporarily receive the mouse focus without changing the keyboard focus
	 *       (like spinner on numeric input): that's why we don't use &lt;w&gt; parameter.
	 */</com>
	SIT_GetValues(SIT_GetFocus(), SIT_CtrlType, &type, NULL);
	<kwd>if</kwd> (cd && type == SIT_EDITBOX)
	{
		<kwd>if</kwd> (repeatOn == <val>0</val>)
		{
			SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
			repeatOn = <val>1</val>;
		}
	}
	<kwd>else if</kwd> (repeatOn)
	{
		SDL_EnableKeyRepeat(<val>0</val>, <val>0</val>);
		repeatOn = <val>0</val>;
	}
	<kwd>return</kwd> <val>0</val>;
}

<type>int</type> main(<type>void</type>)
{
	<com>/* ... */

	/* after SITGL initialization */</com>
	SIT_AddCallback(app, SITE_OnFocus, trackFocus, NULL);
	SIT_AddCallback(app, SITE_OnBlur,  trackFocus, NULL);
}</pre>

<h2 id="css">CSS</h2>

<p>This library implements a small subset of CSS in order to give a <b>meaningful appearance to your
controls</b>. By default this library won't provide any (besides text color being black and anything
else being transparent), because it is highly likely that any defaults will not suit your needs, so
no need to even bother providing some.

<p>Writing a complete stylesheet for every controls and every possible states is a tedious process,
don't underestimate this aspect. It is highly recommended <b>you start with a pre-defined stylesheet</b>
and iterate from there.

<p>This section will provide more details about which subset of CSS has been implemented and all the
extensions/deviations that have been added.

<p><span class="n">Note</span>: this section <b>will not be a tutorial</b> on how to use properly use CSS.
Assumption is made that you already have basic knowledge on how CSS works.

<h3 id="selectors"><span>Selectors</span></h3>

<p>Before you'll be able to apply styles to controls, you'll need to know <b>how to target those controls</b>
using CSS selectors.

<p>In the chapter explaining the <a href="#SIT_CreateWidget"><tt>SIT_CreateWidget()</tt></a> function,
it was mentioned that the tag name with which you can target CSS selectors will be automatically
chosen if you don't provide any. The table below <b>will list the tag name automatically chosen</b>
for each control types as well as the <b>different parts</b> that a control is made up.

<p>Keep in mind those are the parts that will be created, no matter what. You are free to add or even
delete those parts if you don't want them. Just use the <tt>SIT_GetById()</tt> function to get a
reference to a given part (using tag name as the parameter).

<table class="listview pad">
<thead><tr><td>Control type<td>Tag name<td>Description
<tbody>
  <tr><td><tt>SIT_APP</tt><td><tag>html</tag><td>No children.
  <tr><td rowspan="2"><tt>SIT_DIALOG</tt><td><tag>dialog</tag><td>Normal top level window, containing the following child widgets:
  <ul class="compact" style="margin: 0">
	<li><tag>title</tag>: label containing the title.
	<li><tag>close</tag>: button for closing the dialog.
	<li><tag>client</tag>: area where controls will be added.
  </ul>
  <tr><td><tag>form</tag><td><tt>SITV_DialogStyles</tt> set to <tt>SITV_Plain</tt>. No child widgets.
  <tr><td><tt>SIT_LABEL</tt><td><tag>label</tag><td>No children.
  <tr><td rowspan="3"><tt>SIT_BUTTON</tt><td><tag>button</tag><td>Normal push button.
  <tr><td><tag>checkbox</tag><br><td><tt>SIT_ButtonType</tt> set to <tt>SITV_CheckBox</tt>. Child widget:
  <ul class="compact" style="margin: 0">
	<li><tag>box</tag>: HTML tag use to contain the checkmark.
  </ul>
  <tr><td><tag>radio</tag><td><tt>SIT_ButtonType</tt> set to <tt>SITV_RadioButton</tt>.
  <ul class="compact" style="margin: 0">
	<li><tag>box</tag>: HTML tag use to contain the radio mark.
  </ul>
  <tr><td><tt>SIT_FRAME</tt><td><tag>fieldset</tag><td>No children.
  <tr><td rowspan="2"><tt>SIT_LISTBOX</tt><td><tag>listbox</tag><td><tt>SIT_ViewMode</tt> set to <tt>SITV_ListViewIcon</tt>.
  <ul class="compact" style="margin: 0">
	<li><tag>td</tag>: cell of table (one item in the list).
  </ul>
  <tr><td><tag>table</tag><td>If set to <tt>SITV_ListViewReport</tt>.
  <ul class="compact" style="margin: 0">
	<li><tag>td</tag>: cell of table (several per row).
  </ul>
  <tr><td><tt>SIT_EDITBOX</tt><td><tag>editbox</tag><td>If <tt>SIT_EditType</tt> is set to <tt>SITV_Integer</tt>, <tt>SITV_Float</tt> or <tt>SITV_Double</tt>,
  the following children will be created:
  <ul class="compact" style="margin: 0">
	<li><tag>spin.up</tag>: up arrow to increase value.
	<li><tag>spin.down</tag>: down arrow to decrease value.
  </ul>
  <tr><td><tt>SIT_COMBOBOX</tt><td><tag>combobox</tag><td>Will have the following children:
  <ul class="compact" style="margin: 0">
	<li><tag>arrow</tag>: arrow anchored to the right that can ne clicked to open a list with entries.
	<li><tag>popup</tag>: popup that will contain the list of items.
  </ul>
  <tr><td><tt>SIT_CANVAS</tt><td><tag>canvas</tag><td>No children.
  <tr><td rowspan="2"><tt>SIT_SCROLLBAR</tt><td><tag>vscroll</tag><td>If property <tt>SIT_HorizScroll</tt> is set to 0 (default value).
  <tr><td><tag>hscroll</tag><td>With <tt>SIT_HorizScroll</tt> set to 1.
  <p>The following children will be added:
  <ul class="compact" style="margin: 0">
	<li><tag>thumb</tag>: clikable and draggable portion of the scrollbar.
	<li><tag>arrow.up</tag>, <tag>arrow.down</tag>: arrows for vertical scrollbar to increase/decrease by one line.
	<li><tag>arrow.left</tag>, <tag>arrow.right</tag>: arrows for horizontal scrollbar.
  </ul>
  <tr><td><tt>SIT_SLIDER</tt><td><tag>slider</tag><td>The following children will be available:
  <ul class="compact" style="margin: 0">
	<li><tag>thumb</tag>: clikable and draggable portion of the slider.
	<li><tag>gauge</tag>: portion of the slider that shows range selected.
  </ul>
  <tr><td><tt>SIT_PROGRESS</tt><td><tag>progress</tag><td>Contains one of the following child:
  <ul class="compact" style="margin: 0">
	<li><tag>bar.horiz</tag>: bar that represents progress if <tt>SIT_HorizScroll</tt> is set to <tt class="o">True</tt> (default value).
	<li><tag>bar.vert</tag>: for vertical progress bar.
  </ul>
  <tr><td><tt>SIT_TAB</tt><td><tag>tab</tag><td>Each tab is created as label with the tag name <tag>pane</tag>.
  <tr><td><tt>SIT_TOOLTIP</tt><td><tag>tooltip</tag><td>No children.
  <tr><td><tt>SIT_HTMLTAG</tt><td><em>name</em><td>Tag name will be actually the same as the name of the widget.
</table>

<p><span class="n">Note</span>: check out the <a href="#widgets">widgets</a> chapter for some examples
on how to style each control.

<p>Then with those tag names along the ID and classes that you have to explicitly set, <b>you can form
standard CSS selectors</b>. As a reference, this is the supported operators you can use to combine with
tag/ID/classes to form CSS rules:

<ul>
	<li><tt class="dt">.</tt> : class selector.
	<li><tt class="dt">#</tt> : ID selector.
	<li><tt class="dt">:</tt> : pseudo-class selector, the following pseudo classes are supported:
	<ul>
	  <li><tt>link</tt> : match any HTML tag that have an <b><tt>href</tt> attribute</b> that is not empty.
	  <li><tt>active</tt> : the element is being <b>activated by user action</b>, typically by holding mouse
	  button down over the element (or using space bar key). This class is useful for button-like
	  controls, to show that input has been received, but can still be cancelled by moving the mouse outside
	  the control.
	  <li><tt>hover</tt> : the mouse cursor is <b>over the element</b>. <span class="n">Note</span>: <tt>:active</tt>
	  class will also match <tt>:hover</tt>
	  <li><tt>focus</tt> : the element is the <b>target of keyboard events</b>.
	  <li><tt>kbdfocus</tt> : the keyboard <b>focus</b> have been explicitly set on this element <b>with the
	  keyboard</b> (usually tab key). <tt>:focus</tt> can be triggered by mouse action. Usually, this is
	  the class you want to target if you want to highlight which control has the keyboard focus.
	  <li><tt>checked</tt> : target elements that have a toggle state (typically checkbox or radio
	  button), with their <b>checked state being set</b>.
	  <li><tt>disabled</tt> : the <b>element is disabled</b> (no mouse or keyboard events will be sent).
	</ul>
	<li><tt class="dt">></tt> : immediate child selector.
	<li><tt class="dt">+</tt> : sibling selector.
	<li><tt class="dt">[]</tt> : arbitrary attribute selector.
	<li><tt class="dt">*</tt> : any tag selector.
</ul>

<p>After that, feel free to combine all of these to make whatever CSS rules to target an element.
Standard <b>rule precedence will be taken into account</b> (because that's what the C in CSS is about).
As a quick reminder, here is the weight that will determine which selector will take precedence (from
highest to lowest priority):
<ul>
  <li>Explicit styles set to an element using the <b><tt>SIT_Styles</tt> property</b>.
  <li><b>ID selectors</b>.
  <li><b>Class</b> selectors (that includes pseudo-classes).
  <li><b>tag name</b> / <tt>*</tt>.
</ul>

<p>If two CSS rules end up having the <b>same weight</b>, it will be the <b>order in which they are
declared</b> that will set the precedence: later rules will override earlier ones.

<p>This is just a very quick overview. If you are new to CSS and this is not enough to get you
started, you'll have to familiarize yourself with CSS on your own. There are plenty of tutorials available
out there that you can find using your favorite search engine.

<p>If you are comfortable with CSS selectors, you can finally start adding attributes to your rules,
in order to give appearance to your controls. The following sections will describe all the attributes
<tt>SITGL</tt> supports as well as their expected arguments and potential extensions.

<h3 id="csstypes"><span>Datatypes</span></h3>

<p>This section will explain what atomic <b>datatypes that this library supports</b>, as long as their
quirks and extensions. Those datatypes will be used as building blocks for the properties, so it is
important to have a good understanding of what they do.

<h4 id="strings">Strings</h4>

<p>A very basic datatype, that has <b>a few obscure features</b>. To spare you the hassle of finding them
out, here is what needs to be known about them.

<p>Strings can be enclosed by <b>single or double quotes</b> (ASCII character 39 or 34). Character
encoding is supposed to be UTF-8, this library does not give you any choice in that regard.

<p>To escape an <b>ASCII character</b> (typically the single or double quote, it won't work with
character code &gt; 127), prefixed it using the anti-slash (ASCII character 92). Be careful however,
if the anti-slash is followed by some hexadecimal digits, they will be interpreted as an unicode
code point (that will be converted to UTF-8). Additionally, the escape sequence can be followed
by a newline, to break character globbing.

<p>Some examples:
<ul>
	<li><tt class="o">"images/background.png"</tt>: will be interpreted as <tt>images/background.png</tt>.
	<li><tt class="o">'it\'s a file.css'</tt>: encodes the string <tt>it's a file.css</tt>.
	<li><tt class="o">"patte\r\n"</tt>: encodes <tt>pattern</tt>. Usual C escape sequence are not recognized.
	<li><tt class="o">"d\e9j\e0 vu"</tt>: will translate into <tt>d&#xe9;j&#xe0; vu</tt>
	<li><tt class="o">"Ph\153be"</tt>: will generate an invalid UTF-8 sequence: <tt>Ph&#x153be;</tt>, because
	all hex digits following \ will be used to form an unicode code point (with U+153BE being non-existant).
	<li><tt class="o">"Ph\153<br>be"</tt>: to prevent that globbing, you need a newline after the
	character you want to encode, in this case it will give: <tt>Ph&#x153;be</tt>.
</ul>

<p><b>Pro-tip</b>: try to only use ASCII characters.

<h4 id="cssdim">Dimension</h4>

<p>Dimensions will be used extensively within CSS properties, so keep them in mind. Dimensions are
floatting numbers with a unit suffix. The only number allowed to not have an unit is the number 0.
For all the other numbers, it will be processed as an error condition. Here are the following units
you can use:

<ul>
  <li><tt class="dt">px</tt>: this unit will guarantee that it will <b>match the pixel resolution of the
  screen</b>: if you ask for a <tt>border-width</tt> of <tt>2px</tt>, the border will indeed be occupy
  2 pixels on the screen. No attempts will be made to adjust for HiDPI monitors. This is more often
  than not, <b>not</b> the unit you want to use.
  <li><tt class="dt">in</tt>, <tt class="dt">cm</tt>, <tt class="dt">mm</tt>, <tt class="dt">pt</tt>: 
  these units are mostly a relic from the days this library was rendering to PDF format, since postscript
  points (pt) is the native unit of PDF. However <tt>SITGL</tt> makes no attempt at figuring the DPI
  of the monitor where the rendering occur, meaning that those units are mostly useless. <tt>SITGL</tt>
  will assume a resolution of 72 DPI, for what it is worth, which is probably not much. <b>Avoid</b>.
  <li><tt class="dt">em</tt>: This is more often that not, <b>the unit you want to use</b>. This unit
  will be <b>relative to the element font's height</b>. This is how you make a DPI agnostic interface:
  set the font size to some reasonable value and then derive all your user interface elements from
  it.

  <li><tt class="dt">vw</tt>, <tt class="dt">vh</tt>: unit that is <b>relative to the viewport</b>
  width/height. This unit is particularly useful to set the font height on the root node. After that,
  all the elements will inherit that value. <tt>1vw</tt> equals to 1% of the viewport width. A good
  base font size is usually between <tt>1.3vw</tt> and <tt>1.7vw</tt>.
</ul>

<p>There is an important fact to keep in mind with these units: even though you can use floating
points, once something has to be rendered on screen, this library with <b>convert everything to integers</b>.
Even though <tt>nanovg</tt> can handle sub-pixel positioning perfectly, more often than not, it
will produce extremely blurry graphics, particularly when it comes to fonts, since they will be
already anti-aliased.

<p>That automatic rounding has a side effect though, especially when using the <tt>em</tt> unit: the
<b>sum of the parts is not necessarily equal to the whole</b>. For example: when you have a border
of 0.1em and a padding of 0.2em, the total might not be exactly 0.3em, because of that rounding.

<h4 id="csscolor">Colors</h4>

<p>Colors are an important part of CSS, and as such, there is a variety of way to specify them, as
well as some extensions:

<ul>
  <li><b>Named colors</b>: there are <b>140 pre-defined colors</b>. In the table below you can see all of
  them. Hover the mouse to get its name and their RGB components:
<table id="colors">
<tr>
	<td style='background: #000000' title='black #000000'>
	<td style='background: #000080' title='navy #000080'>
	<td style='background: #00008b' title='darkblue #00008B'>
	<td style='background: #0000cd' title='mediumblue #0000CD'>
	<td style='background: #0000ff' title='blue #0000FF'>
	<td style='background: #006400' title='darkgreen #006400'>
	<td style='background: #008000' title='green #008000'>
	<td style='background: #008080' title='teal #008080'>
	<td style='background: #008b8b' title='darkcyan #008B8B'>
	<td style='background: #00bfff' title='deepskyblue #00BFFF'>
	<td style='background: #00ced1' title='darkturquoise #00CED1'>
	<td style='background: #00fa9a' title='mediumspringgreen #00FA9A'>
	<td style='background: #00ff00' title='lime #00FF00'>
	<td style='background: #00ff7f' title='springgreen #00FF7F'>
<tr>
	<td style='background: #00ffff' title='aqua #00FFFF'>
	<td style='background: #00ffff' title='cyan #00FFFF'>
	<td style='background: #191970' title='midnightblue #191970'>
	<td style='background: #1e90ff' title='dodgerblue #1E90FF'>
	<td style='background: #20b2aa' title='lightseagreen #20B2AA'>
	<td style='background: #228b22' title='forestgreen #228B22'>
	<td style='background: #2e8b57' title='seagreen #2E8B57'>
	<td style='background: #2f4f4f' title='darkslategray #2F4F4F'>
	<td style='background: #32cd32' title='limegreen #32CD32'>
	<td style='background: #3cb371' title='mediumseagreen #3CB371'>
	<td style='background: #40e0d0' title='turquoise #40E0D0'>
	<td style='background: #4169e1' title='royalblue #4169E1'>
	<td style='background: #4682b4' title='steelblue #4682B4'>
	<td style='background: #483d8b' title='darkslateblue #483D8B'>
<tr>
	<td style='background: #48d1cc' title='mediumturquoise #48D1CC'>
	<td style='background: #4b0082' title='indigo #4B0082'>
	<td style='background: #556b2f' title='darkolivegreen #556B2F'>
	<td style='background: #5f9ea0' title='cadetblue #5F9EA0'>
	<td style='background: #6495ed' title='cornflowerblue #6495ED'>
	<td style='background: #66cdaa' title='mediumaquamarine #66CDAA'>
	<td style='background: #696969' title='dimgray #696969'>
	<td style='background: #6a5acd' title='slateblue #6A5ACD'>
	<td style='background: #6b8e23' title='olivedrab #6B8E23'>
	<td style='background: #708090' title='slategray #708090'>
	<td style='background: #778899' title='lightslategray #778899'>
	<td style='background: #7b68ee' title='mediumslateblue #7B68EE'>
	<td style='background: #7cfc00' title='lawngreen #7CFC00'>
	<td style='background: #7fff00' title='chartreuse #7FFF00'>
<tr>
	<td style='background: #7fffd4' title='aquamarine #7FFFD4'>
	<td style='background: #800000' title='maroon #800000'>
	<td style='background: #800080' title='purple #800080'>
	<td style='background: #808000' title='olive #808000'>
	<td style='background: #808080' title='gray #808080'>
	<td style='background: #808080' title='grey #808080'>
	<td style='background: #87ceeb' title='skyblue #87CEEB'>
	<td style='background: #87cefa' title='lightskyblue #87CEFA'>
	<td style='background: #8a2be2' title='blueviolet #8A2BE2'>
	<td style='background: #8b0000' title='darkred #8B0000'>
	<td style='background: #8b008b' title='darkmagenta #8B008B'>
	<td style='background: #8b4513' title='saddlebrown #8B4513'>
	<td style='background: #8fbc8f' title='darkseagreen #8FBC8F'>
	<td style='background: #90ee90' title='lightgreen #90EE90'>
<tr>
	<td style='background: #9370d8' title='mediumpurple #9370D8'>
	<td style='background: #9400d3' title='darkviolet #9400D3'>
	<td style='background: #98fb98' title='palegreen #98FB98'>
	<td style='background: #9932cc' title='darkorchid #9932CC'>
	<td style='background: #9acd32' title='yellowgreen #9ACD32'>
	<td style='background: #a0522d' title='sienna #A0522D'>
	<td style='background: #a52a2a' title='brown #A52A2A'>
	<td style='background: #a9a9a9' title='darkgray #A9A9A9'>
	<td style='background: #add8e6' title='lightblue #ADD8E6'>
	<td style='background: #adff2f' title='greenyellow #ADFF2F'>
	<td style='background: #afeeee' title='paleturquoise #AFEEEE'>
	<td style='background: #b0c4de' title='lightsteelblue #B0C4DE'>
	<td style='background: #b0e0e6' title='powderblue #B0E0E6'>
	<td style='background: #b22222' title='firebrick #B22222'>
<tr>
	<td style='background: #b8860b' title='darkgoldenrod #B8860B'>
	<td style='background: #ba55d3' title='mediumorchid #BA55D3'>
	<td style='background: #bc8f8f' title='rosybrown #BC8F8F'>
	<td style='background: #bdb76b' title='darkkhaki #BDB76B'>
	<td style='background: #c0c0c0' title='silver #C0C0C0'>
	<td style='background: #c71585' title='mediumvioletred #C71585'>
	<td style='background: #cd5c5c' title='indianred #CD5C5C'>
	<td style='background: #cd853f' title='peru #CD853F'>
	<td style='background: #d2691e' title='chocolate #D2691E'>
	<td style='background: #d2b48c' title='tan #D2B48C'>
	<td style='background: #d3d3d3' title='lightgrey #D3D3D3'>
	<td style='background: #d87093' title='palevioletred #D87093'>
	<td style='background: #d8bfd8' title='thistle #D8BFD8'>
	<td style='background: #da70d6' title='orchid #DA70D6'>
<tr>
	<td style='background: #daa520' title='goldenrod #DAA520'>
	<td style='background: #dc143c' title='crimson #DC143C'>
	<td style='background: #dcdcdc' title='gainsboro #DCDCDC'>
	<td style='background: #dda0dd' title='plum #DDA0DD'>
	<td style='background: #deb887' title='burlywood #DEB887'>
	<td style='background: #e0ffff' title='lightcyan #E0FFFF'>
	<td style='background: #e6e6fa' title='lavender #E6E6FA'>
	<td style='background: #e9967a' title='darksalmon #E9967A'>
	<td style='background: #ee82ee' title='violet #EE82EE'>
	<td style='background: #eee8aa' title='palegoldenrod #EEE8AA'>
	<td style='background: #f08080' title='lightcoral #F08080'>
	<td style='background: #f0e68c' title='khaki #F0E68C'>
	<td style='background: #f0f8ff' title='aliceblue #F0F8FF'>
	<td style='background: #f0fff0' title='honeydew #F0FFF0'>
<tr>
	<td style='background: #f0ffff' title='azure #F0FFFF'>
	<td style='background: #f4a460' title='sandybrown #F4A460'>
	<td style='background: #f5deb3' title='wheat #F5DEB3'>
	<td style='background: #f5f5dc' title='beige #F5F5DC'>
	<td style='background: #f5f5f5' title='whitesmoke #F5F5F5'>
	<td style='background: #f5fffa' title='mintcream #F5FFFA'>
	<td style='background: #f8f8ff' title='ghostwhite #F8F8FF'>
	<td style='background: #fa8072' title='salmon #FA8072'>
	<td style='background: #faebd7' title='antiquewhite #FAEBD7'>
	<td style='background: #faf0e6' title='linen #FAF0E6'>
	<td style='background: #fdf5e6' title='oldlace #FDF5E6'>
	<td style='background: #ff0000' title='red #FF0000'>
	<td style='background: #ff00ff' title='fuchsia #FF00FF'>
	<td style='background: #ff00ff' title='magenta #FF00FF'>
<tr>
	<td style='background: #ff1493' title='deeppink #FF1493'>
	<td style='background: #ff4500' title='orangered #FF4500'>
	<td style='background: #ff6347' title='tomato #FF6347'>
	<td style='background: #ff7f50' title='coral #FF7F50'>
	<td style='background: #ff8c00' title='darkorange #FF8C00'>
	<td style='background: #ffa07a' title='lightsalmon #FFA07A'>
	<td style='background: #ffa500' title='orange #FFA500'>
	<td style='background: #ffb6c1' title='lightpink #FFB6C1'>
	<td style='background: #ffc0cb' title='pink #FFC0CB'>
	<td style='background: #ffd700' title='gold #FFD700'>
	<td style='background: #ffdab9' title='peachpuff #FFDAB9'>
	<td style='background: #ffdead' title='navajowhite #FFDEAD'>
	<td style='background: #ffe4b5' title='moccasin #FFE4B5'>
	<td style='background: #ffe4c4' title='bisque #FFE4C4'>
<tr>
	<td style='background: #ffe4e1' title='mistyrose #FFE4E1'>
	<td style='background: #ffebcd' title='blanchedalmond #FFEBCD'>
	<td style='background: #ffefd5' title='papayawhip #FFEFD5'>
	<td style='background: #fff0f5' title='lavenderblush #FFF0F5'>
	<td style='background: #fff5ee' title='seashell #FFF5EE'>
	<td style='background: #fff8dc' title='cornsilk #FFF8DC'>
	<td style='background: #fffacd' title='lemonchiffon #FFFACD'>
	<td style='background: #fffaf0' title='floralwhite #FFFAF0'>
	<td style='background: #fffafa' title='snow #FFFAFA'>
	<td style='background: #ffff00' title='yellow #FFFF00'>
	<td style='background: #ffffe0' title='lightyellow #FFFFE0'>
	<td style='background: #fffff0' title='ivory #FFFFF0'>
	<td style='background: #ffffff' title='white #FFFFFF'>
	<td style='background: url(images/checkboard.png)' title='transparent'>
</table>

  <p>Or check the source file <tt>SIT_CSSColors.h</tt> for the complete list.

  <li><tt>selfore</tt>, <tt>selback</tt>: these two pre-defined keywords will retrieve the selection
  color currently in use by the operating system for (respectively) the text and the background.

  <li><b>Hex value</b>: can be specified by using a <tt>#</tt>, followed by 1, 2, 3, 4, 6 or 8 hex digits.
  Each have the following byte layout:
  <ul>
	<li><b>1 digit</b>: will represent 16 shades of gray (e.g.: <tt>#0</tt> is black and <tt>#f</tt> is white).
	<li><b>2 digits</b>: 256 shades of gray.
	<li><b>3 digits</b>: RGB color, with each component having 16 shades.
	<li><b>4 digits</b>: RGBA color, each component has 16 shades.
	<li><b>6 digits</b>: RGB color with 256 shades per component.
	<li><b>8 digits</b>: RGBA with 256 shades per component (i.e: first 6 digits are RGB components,
	last 2 are alpha).
  </ul>
  <p>Anything else will generate an error, with no attempt to recover anything from the input.

  <li><tt>rgb(r, g, b)</tt>: <tt>r</tt>, <tt>g</tt> and <tt>b</tt> value must be <b>decimal</b> numbers
  between 0 and 255.
  <li><tt>rgba(r, g, b, a)</tt>: same range as <tt>rgb()</tt>, but <tt>a</tt> needs to be between
  0 and 1 (possibly fractional).
  <li><tt>hsl(h, s, l)</tt>: Specify a color using the hue, saturation, luminosity color space.
  <tt>h</tt> must be between 0 and 360, representing the angle on the color wheel, <tt>s</tt> and
  <tt>l</tt>  must be between 0 and 100.
  <li><b>Extension</b>: <tt>rgba(name, a)</tt> or <tt>rgba(#hex, a)</tt>: <b>the rationale behind this
  notation</b> is as follows: let's say you give a color to an element using a name or a hex value.
  Now you would like to make that element blend a little bit with the background. Using the
  default <tt>rgba</tt> notation, you'll have to convert the hex numbers into decimal or if you
  used a name, find out what its color value is (probably in hex too). Then you can add the alpha
  part.
  <p>For colors that are already in hex value, you might be tempted to use the 8 hex digits notation,
  but this is not very readable: when looking at <tt>#12345678</tt>, it is not immediately obvious
  to tell which part is the RGB components and which part is alpha. Moreover alpha is usually handled
  as a percentage, which is way easier to do with values between 0 and 1, than with hex in the range
  0 to 255.
</ul>

<h4 id="cssangle">Angles</h4>

<p>Angles are used in linear gradient and transformation matrix. You can use the following units:
<ul>
  <li><tt>deg</tt>: represent the angle in degrees, the full circle being <tt>360deg</tt>.
  <li><tt>grad</tt>: gradients with the full circle being <tt>400grad</tt>.
  <li><tt>rad</tt>: radians, with the full circle being 2 * &pi;.
  <li><tt>turn</tt>: one circle is 1 turn.
</ul>

<p>Orientation for angle works as follow:
<table><tr><td style="vertical-align: top">
<ul>
  <li>Angle 0 is <b>pointing straight up</b> (with respect to the screen).
  <li>A positive angle goes clockwise.
  <li>Negative angles goes counter-clockwise (the trigonometric way).
</ul>
<td><img src="images/cssangles.png">
</table>

<h4 id="cssuri">URI</h4>

<p>URI are needed whenever you want to load external resources. One important aspect to keep in
mind is that, <b>this library has no networking capabilities</b> (and hopefully never will). All
resources must be local. Path will be relative to where your CSS file is located (or the current
directory if you use a string as a stylesheet).

<p>URI can also be used to embed inline images, using the <tt>data:</tt> prefix. For example:
<pre>url(data:image/gif;base64,R0lGODlhDwAPAKEBAAAAAP///////////yH5BAEKAAIALAAAAAAPAA8AAAIklB8Qx53b4otSUWcvyiz4/4AeQJbmKY4p1HHapBlwPL/uVRsFADs=);</pre>
<p>Will embed a 15x15px image, using the GIF image format. You can use <a href="dataURI.html" target="_blank">this
page</a> to generate such URI. Also, check out <a href="#annexB">Annex B</a> to know which file formats are supported.

<p>Even though there are no limits to how long those URI can be in <tt>SITGL</tt>, it is recommended
to keep them short (below a few kilobytes).


<p>The following sections will describe how those datatypes are used within CSS attributes. These
sections are ordered in the way rendering stack is ordered in this library: from bottom to top.


<h4 id="cssparsing">Parsing</h4>

<p>When a property accept <b>multiple arguments</b>, the order of these arguments does not necessarily have
to match the order described in this document. <b>The way it works is as follows</b>: the input given for
a property is split into atomic types (like dimension, strings, uri, identifier, ...). Each of these
arguments will then be assigned to the first available argument that match this type.

<p>For example, if you look at the <tt>text-shadow</tt> property, it expects a dimension for the
horizontal offset, another dimension for the vertical offset, a third dimension for the blur radius
and finally a color. Knowing this, how does a (valid) declaration like this get parsed:
<pre><com>text-shadow</com>: <atr>1px black 1px</atr></pre>
<p><b>Parsing is done as follows</b>:
<ol>
  <li>First, the input is split into atomic types, we get: <tt>1px</tt>, <tt>black</tt> and <tt>1px</tt>.
  <li>The first argument is a dimension, and is therefore assigned to the first dimension, which is the
  horizontal offset.
  <li>The second argument is a color, and is assigned to the first color type of the property (which
  only have one): which is the color of the shadowed text.
  <li>The third argument is a dimension and is assigned to the next available dimension: vertical offset
  (horizontal offset already has a value).
  <li>Blur radius will not be assigned to any value, therefore will be set to its default value, which is 0.
</ol>


<h3 id="cssboxshadow"><span>Box shadow</atr></h3>

<pre><com>box-shadow</com>: <atr>&lt;offsetX&gt; &lt;offsetY&gt; &lt;blurradius&gt; &lt;spreadradius&gt; inset &lt;color&gt;</atr></pre>

<p>Box shadow is a useful property to simulate depth. Multiple shadows can be specified, by
separating the declarations with a comma: the shadows will be ordered top to bottom.

<p><tt>spreadradius</tt> is to enlarge (positive dimension) or shrink (negative dimension) the shadow.

<p><tt>inset</tt> keyword will make the shadow be drawn inside the element, instead of outside.

<p><tt>box-shadow</tt> will take <tt>border-radius</tt> into account when drawing the corner:

<div class="image">
  <img src="images/box-shadow.png">
</div>

<p>But due to a limitation of <tt>nanovg</tt> API, it only works if the border radius is uniform
in all corners (ie: circular, with the same radius).

<p>Also that's all the shape it can handle, irregular borders (usually declared with <tt>border-image</tt>)
will be considered rectangular. To add a drop shadow effect, it is recommended to use a paint program
and incorporate the shadow within the border directly.

<h3 id="cssbackground"><span>Background properties</span></h3>

<p>This is used to paint the interior of an element. There are a few properties to do that:
<pre>
<com>background</com>:            <atr>&lt;color&gt; &lt;uri&gt; &lt;attachment&gt; &lt;repeat&gt; &lt;offsetX&gt; &lt;offsetY&gt; &lt;clip&gt;</atr>
<com>background-color</com>:      <atr>&lt;color&gt;</atr>
<com>background-image</com>:      <atr>&lt;uri&gt;;</atr>
<com>background-attachment</com>: <atr>fixed|scroll</atr>
<com>background-repeat</com>:     <atr>repeat|repeat-x|repeat-y|no-repeat</atr>
<com>background-position</com>:   <atr>&lt;offsetX&gt; &lt;offsetY&gt;</atr>
<com>background-size</com>:       <atr>cover|contain|&lt;sizeX&gt; &lt;sizeY&gt;</atr></pre>

<p>All those properties <b>accept multiple background parameters</b>, separated by a comma. Backgrounds will
be drawn top to bottom. CSS standard allow the use of <tt>background-color</tt> only for the last (bottomest)
background. This library allows you to use it for all declarations. <strong>Rationale</strong>: using
an RGBA color on top of background is a very easy way to apply a slight tint to an image. Otherwise,
you'll have to use a linear gradient for this, which is a lot more verbose.

<p><span class="n">Caveat</span>: the <tt>background</tt> property cannot assign all of the individual
background parameters. You'll have to use individual properties instead.

<p><tt>uri</tt> parameter has a few extensions, that you might find useful:
<ul>
  <li><b>Mask</b>: if the URI is prefixed by <tt>mask:</tt>, the color of the background will be modulated
  by the color of the text (<tt>color</tt> property). This will work only for grayscale image. If you
  supply a color image, only the first channel (usually red) will be used.

  <li><b>No filtering</b>: if you want to display a low-resolution image, but stretched by a considerable
  amount, you might want to disabled the default filtering applied to OpenGL texture. By default it
  is set to linear, which might produced extremely blurry results in cases like this. To <b>disable
  linear filtering</b>, prefix the path with <tt>nearest:</tt>.

  <li><b>OpenGL texture</b>: it is possible to reuse a texture ID from OpenGL and use to it to paint
  background with it. The syntax for this is: <tt>id(&lt;textureId&gt;)</tt>, where <tt>textureId</tt>
  has to be an integer returned by <tt>glGenTextures()</tt>. <b>If you modify the texture</b> after assigning
  it to a background, especially if its size has changed (since this library will have to cache that
  information), you can refresh its internal state by reassigning the <tt>background</tt> property
  with the same value.

  <p><span class="n">Note</span>: if you want to use the render buffer (FBO) as a texture, be careful
  to get the content of this buffer as a RGB texture and <b>not</b> as RGBA. E.g. using a code like this:
  <pre>SIT_Widget app = ...;
<type>int</type> texId;
<type>int</type> width = <val>1920</val>;
<type>int</type> height = <val>1080</val>;
<com>/* create a texture object */</com>
glGenTextures(<val>1</val>, &amp;texId);
glBindTexture(GL_TEXTURE_2D, texId);
<com>/* set it to RGB 8bpp */</com>
glTexImage2D(GL_TEXTURE_2D, <val>0</val>, GL_RGB8, width, height, <val>0</val>, GL_RGB, GL_UNSIGNED_BYTE, <val>NULL</val>);

<com>/* copy render buffer to it (only grab RGB) */</com>
glCopyTexImage2D(GL_TEXTURE_2D, <val>0</val>, GL_RGB8, <val>0</val>, <val>0</val>, width, height, <val>0</val>);
glGenerateMipmap(GL_TEXTURE_2D);

<com>/* set it as background of a SIT element */</com>
SIT_SetValues(app, SIT_Style|XfMt, <val>"background: id(%d)"</val>, texId, <val>NULL</val>);
 </pre>
</ul>

<p>Here are a few basic examples on how <tt>background:</tt> property works:
<div class="image">
  <img src="images/background_simple.png">
</div>
<p>Each box is exactly 100x100px, the border size is 2px, therefore the content area is 96x96px. The
background image is 64x64px. From left to right, <b>here are the declarations used to produce those
backgrounds</b>:
<ul>
  <li><tt class="dt"><com>background</com>: <atr>url("64x64.png")</atr>;</tt>
  <p>The default origin for the background will be the top left of the padding box (entire box, minus
  border width).
  <li><tt class="dt"><com>background</com>: <atr>url("64x64.png") 32px 0</atr>;</tt>
  <p>Since the content area is 96px, the image 64px and shifted by 32px, it should touch the right border.
  <li><tt class="dt"><com>background</com>: <atr>url("64x64.png") 32px 32px</atr>;</tt>
  <p>Same here, with the height/bottom.
  <li><tt class="dt"><com>background</com>: <atr>url("64x64.png") -32px -32px</atr>;</tt>
  <p>Offset can also be negative.
  <li><tt class="dt"><com>background</com>: <atr>url("64x64.png") 100% 100%;</atr></tt>
  <p>Relative unit, will place the relative position within the image at the (same) relative position
  in the box. Therefore a position of <tt>100% 100%</tt> will place the image in the bottom left corner,
  no matter what the image or box size is. Likewise a position of <tt>50% 50%</tt> will center the
  image, no matter what the size of the image or the box is.
  <li><tt class="dt"><com>background</com>: <atr>url("64x64.png") fixed</atr>;</tt>
  <p>This effect can only be visualized in motion. On a screenshot, it is hard to see what's going on.
  Here the origin of the background is the <b>top left corner of the window</b> (ie: html tag). If
  you were to move the window (the gray rounded rectangle, not the operating system window), the background
  of the last box would appear to be fixed, like if the box would be transparent and show the background
  of what would appear the HTML element.
</ul>

<p>Here are some examples on how to <b>resize the <tt>background-image</tt></b>. It is extremely likely you'll want
to do that at some point: when displaying any graphics, it is recommended to use a higher resolution
image than what it is necessary and scale it down to the device resolution (typically using <tt>Em</tt> unit).
Scaling an image up will almost always give very blurry results.

<div class="image">
  <img src="images/background_size.png">
</div>

<p>The image is 128x64px, the box size is the same as the previous example (content box is 96x96px). <b>Here
are the declarations used to produce the backgrounds</b>:
<ul>
  <li><tt class="dt"><com>background</com>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<atr>url("128x64.png") 50% 50%</atr>;<br><com>background-size</com>: <atr>contain</atr>;</tt>
  <p>The image will be stretched or reduced so that it is entirely visible within the padding box of
  the element. In the image is displayed at &#xbe; of its original size.

  <li><tt class="dt"><com>background</com>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<atr>url("64x64.png") 50% 50%</atr>;<br><com>background-size</com>: <atr>cover</atr>;</tt>
  <p>The image will be stretched so that the entire padding box is covered by the image, while keeping
  the image ratio. In this case, the image is stretched by a factor of 1.5.

  <li><tt class="dt"><com>background</com>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<atr>url("64x64.png")</atr>;<br><com>background-size</com>: <atr>100% 100%</atr>;</tt>
  <p>The image will fill the entire padding box, distorting the ratio of the image if needed.

  <li><tt class="dt"><com>background</com>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<atr>url("64x64.png") center center</atr>;<br><com>background-size</com>: <atr>64px 32px</atr></tt>
  <p>The image is given an explicit size (in this case: half its original size).

</ul>

<p><tt>background-image</tt> can also be <b>assigned to gradients</b>. This library supports 3 types of gradients:
<ul>
  <li><tt class="dt">linear-gradient</tt> and
  <li><tt class="dt">repeating-linear-gradient</tt> here are a few examples:
  <div class="image">
	<img src="images/linear-gradients.png" style="width: 100%">
  </div>
  <p>From left to right, the declarations used to produce those gradients are:
  <ul class="attachp">
	<li><tt class="dt"><com>background</com>: <atr>linear-gradient(to bottom right, yellow, orange, red)</atr></tt>
	<p>Corner gradients are rendered as a square and stretch to fill the content.
	<li><tt class="dt"><com>background</com>: <atr>linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)</atr></tt>
	<p>Simple rainbow colors.
	<li><tt class="dt"><com>background</com>: <atr>repeating-linear-gradient(-45deg, #443 0, #443 9px, #282828 10px, #282828 19px, #443 20px)</atr></tt>
	<p>Repeating gradients are useful to make simple hatch pattern.
	<li><tt class="dt"><com>background</com>: <atr>red linear-gradient(to bottom right, white, transparent)</atr></tt>
	<p>Background color is what defines the color of this gradient.
	<li><tt class="dt"><com>background-image</com>: <atr>linear-gradient(to right, black, rgba(0,0,0,0)),<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linear-gradient(to bottom, rgb(0,224,255), white)</atr></tt>
	<p>Using 2 gradients, it is easy to simulate a SV slice of the HSV color space.
	<li><tt class="dt"><com>background</com>: <atr>linear-gradient(to top right, rgba(255,0,0,0), rgba(0,0,255,1))</atr></tt>
	<p>Even though the starting point is fully transparent, the red component will still be interpolated
	along the way.
  </ul>
  <li><tt class="dt">radial-gradient</tt>
  <div class="image">
	<img src="images/radial-gradients.png" style="width: 100%">
  </div>
  <p>From left to right, the declarations are:
  <ul class="attachp">
	<li><tt class="dt"><com>background</com>: <atr>radial-gradient(ellipse closest-side, rgba(green,0.3), green)</atr></tt>
	<p>Farthest or closest makes no difference with elliptical gradient, since the ellipse will fill
	the content anyway.
	<li><tt class="dt"><com>background</com>: <atr>radial-gradient(circle farthest-side, rgba(255,0,0,0), blue)</atr></tt>
	<p>Gradient is partially clipped.
	<li><tt class="dt"><com>background</com>: <atr>radial-gradient(circle closest-side at 30% 30%, yellow, orange, red)</atr></tt>
	<p>Origin of the gradient will have an impact on the values used for closest and farthest parameters.
	<li><tt class="dt"><com>background</com>: <atr>radial-gradient(circle farthest-corner, orange, red, blue)</atr></tt>
  </ul>
</ul>

<p>There are a <b>few caveats</b> to be aware when using gradients for background:
<ul>
  <li>Radial gradients have 2 rasterization methods: <tt>nanovg</tt> and <tt>SITGL</tt>. <tt>nanovg</tt>
  is used when there are exactly 2 color stops. <tt>SITGL</tt> is used for everything else. The reason
  for this, is that <tt>nanovg</tt> can render gradient on the fly, without the need of a texture. <tt>SITGL</tt>
  will generate an RGBA texture, which is a bit more expensive.

  <p>The rasterization is not completely identical though: <tt>nanovg</tt> will use a sine curve, while
  <tt>SITGL</tt> will use linear interpolation.

  <li>The number of color stops is limited to 8. You can increase that value by changing the size of
  the array for the type <tt>struct Gradient_t</tt> declared in <tt>SIT_CSSStyles.h</tt>.
  <span class="n">XXX</span> should be dynamic, really.
  <li>Gradients cannot be affected by <tt>background-size</tt>, they are hardcoded to always use
  100% 100%. Limiting the size of the gradient can be useful for creating CSS patterns, but in this
  engine it is cheaper to use a dedicated texture.
</ul>

<p>There are a few <b>non standard properties</b> you might be interested:
<ul>
  <li><tt class="dt">-bg-transform</tt> : accept a transformation, similar to the <tt>transform</tt>
  property. The <b>typical use case</b> for this is to rotate the image by 90&deg; steps. Especially useful
  for arrow buttons used in scrollbars and/or numeric entry. The standard CSS way to do this is to
  apply a transformation on the pseudo-element <tt>::before</tt>, with a forced z-index. That is a
  little bit overkill, for what should be a simple affine matrix multiplication.

  <li><tt class="dt">-bg-mod-color</tt>: accept a <b>color specification</b>. If you want to modulate the
  background image with a different color than the text color, you can use this property. The background
  image has to be a mask, otherwise setting this property will have no effects.
</ul>

<h3 id="cssborder"><span>Border properties</span></h3>

<p>Borders are a very important set of properties that you'll probably use extensively when styling
your controls. As such they have a wide variety of properties to handle a decent number of use cases.
Keep in mind that in the box model used by <tt>SITGL</tt>, setting the 
<a href="#geometry">geometric constraints</a> will define the border box of
your elements. This area will then be reduced by the thickness of the border and/or by the padding.

<pre><com>border</com>: <atr>&lt;size&gt; &lt;style&gt; &lt;color&gt;</atr>
<com>border-width</com>: <atr>&lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt;</atr>
<com>border-style</com>: <atr>&lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt;</atr>
<com>border-color</com>: <atr>&lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt;</atr>
<com>border-{top|left|right|bottom}-width</com>: <atr>&lt;dimension&gt;</atr>
<com>border-{top|left|right|bottom}-style</com>: <atr>&lt;style&gt;</atr>
<com>border-{top|left|right|bottom}-color</com>: <atr>&lt;color&gt;</atr>
<com>border-radius</com>: <atr>&lt;topLeft&gt; &lt;topRight&gt; &lt;bottomRight&gt; &lt;bottomLeft&gt;</atr>
<com>border-{top-left|top-right|bottom-right|bottom-left}-radius</com>: <atr>&lt;dimension&gt;</atr>
</pre>

<p>Here are a few examples:
<ul>
  <li><img src="images/border_simple.png" style="vertical-align: top">
  <p>From left to right, here are the CSS declarations used to produce each square:
  <ul>
	<li><tt class="dt"><com>border</com>: <atr>0.1em solid purple</atr></tt>
	<p>Simple uniform border declaration.
	<p><span class="n">Note</span>: thickness keyword like <tt>thin</tt>,
	<tt>medium</tt> or <tt>thick</tt> are not recognized, use <tt>em</tt> unit instead.
	<p><span class="n">Note<sup>2</sup></span>: due to a limitation of nanovg, the minimal thickness
	of the border will be 1px. Even if you specify something smaller like <tt>0.5px</tt> or <tt>0.00001em</tt>,
	the thickness will be clamped to 1px.

	<li><tt class="dt"><com>border</com>: <atr>double 1em</atr></tt>
	<p>The thickness specified will be divided by 3, on the first and last third a solid border will
	be drawn, the middle part remaining untouched.
	<p><span class="n">Note</span>: by default <tt>border-color</tt> will inherit what has been set
	to the <tt>color</tt> property. If nothing has been set, it will use its initial value, which is
	black.

	<li><tt class="dt"><com>border</com>: <atr>0.5em groove</atr>; <com>color</com>: <atr>blue</atr></tt>
	<p>Here the thickness will be divided by 2. The outer half will be drawn using an outset style,
	while the inner half will have an inset style. Here the color of the border is set indirectly
	through the <tt>color</tt> property.

	<li><tt class="dt"><com>border</com>: <atr>0.5em ridge magenta</atr></tt>
	<p><tt>ridge</tt> is similar to <tt>groove</tt>, but inverting the <tt>inset</tt> / <tt>outset</tt>
	style.
	
	<li><tt class="dt"><com>border</com>: <atr>0.3em green inset</atr></tt>,<br>
	    <tt class="dt"><com>border</com>: <atr>0.2em outset yellow</atr></tt>
	<p>The darker and lighter color is derived from the color specified for the border, and by blending it with
	black (#000) or white (#fff) with a ratio of 50%.

  </ul>
  <p>Sadly, <b>there are no dotted or dashed styles</b>, but they can be somewhat emulated using <tt>border-image</tt>
  property instead (although it will give weird results with rounded corners).

  <li><img src="images/border_radius.png" style="vertical-align: top">
  <p>Here are a few examples on how border-radius behave, from left to right:
  <ul>
	<li><tt class="dt"><com>border</com>: <atr>1em solid #1f72c8</atr>; <com>border-radius</com>: <atr>10px</atr></tt>
	<p>The radius always refer to the radius of the outermost border. Then that radius is reduced by the
	thickness to reach the inner border. If that radius becomes negative, it will be clamped to 0.

	<li><tt class="dt"><com>border</com>: <atr>double 1em purple</atr>; <com>border-radius</com>: <atr>50%</atr></tt>
	<p>Vertical radius and horizontal radius are evaluated independently when using relative unit
	(the box is 150px wide and 100px high).

	<li><tt class="dt"><com>border</com>: <atr>0.5em groove green</atr>; <com>color</com>: <atr>#888</atr>; <com>border-radius</com>: <atr>200px/500px</atr></tt>
	<p>If the radius specified is bigger than what could fit within the border box, the radius will
	be distributed evenly among the horizontally/vertical axis.
	<p><span class="n">Note</span>: if a corner with a radius is composed of different styles/colors,
	the arc will always be split at 45&deg;.

	<li><tt class="dt"><com>border</com>: <atr>0.5em inset cyan</atr>; <com>border-radius</com>: <atr>1em</atr></tt>
	<p>Outer radius is 1em and inner radius is 0.5em.

	<li><tt class="dt"><com>border</com>: <atr>0.3em orange solid</atr>; <com>border-radius</com>: <atr>15px</atr>; <com>border-width</com>: <atr>2px 15px</atr></tt>,<br>
	    <tt class="dt"><com>border</com>: <atr>0.2em red solid</atr>; <com>border-radius</com>: <atr>15px</atr>; <com>border-width</com>: <atr>15px 2px</atr></tt>
	<p>Another example of inner radius being reduced to 0, using non-uniform border width this time.
  </ul>

  <li><img src="images/border_edge_cases.png" style="vertical-align: top">
  <p>Finally some edge cases to understand the limits of border rendering, from left to right:
  <ul>
	<li><tt class="dt"><com>border</com>: <atr>1em solid</atr>;<br><com>border-radius</com>: <atr>2em</atr>;<br><com>border-top-width</com>: <atr>0</atr>;<br><com>border-color</com>: <atr>red orange green blue</atr></tt>
	<p>This highlight another limitation about <tt>nanovg</tt> that has been mentioned <a href="#NVGcaveats">here</a>.
	The border forms a shape that gradually tends to a zero-width path: this is a limitation that
	<tt>nanovg</tt> has trouble to deal with, and as a result, the border appears thicker than it should
	be.

	<li><tt class="dt"><com>border</com>: <atr>10px solid</atr>;<br><com>border-radius</com>: <atr>15px</atr>;<br><com>border-top-width</com>: <atr>0</atr>;<br><com>border-color</com>: <atr>red orange green blue</atr></tt>
	<p>Here the radius is smaller than the border width, therefore the inner border ends up as a
	rectangular shape.

	<li><tt class="dt"><com>border</com>: <atr>solid</atr>;<br><com>border-width</com>: <atr>0.1em 0.2em 0.4em 0.8em</atr>;<br><com>border-radius</com>: <atr>15px</atr>;<br><com>border-color</com>: <atr>red orange green blue</atr></tt>
	<p>Border radius with varying border thickness on all 4 sides. Just to mention that this library
	can handle this case gracefully.

	<li><tt class="dt"><com>border</com>: <atr>1em solid</atr>;<br><com>border-radius</com>: <atr>15px</atr>;<br><com>border-color</com>: <atr>red orange green blue</atr>;<br><com>border-top-width</com>: <atr>0</atr></tt>
	<p>Same as 2: radius smaller than border thickness, but using bigger numbers to highlight the effect.

	<li><tt class="dt"><com>border</com>: <atr>solid</atr>;<br><com>border-width</com>: <atr>0.1em 0.8em 0.4em 0.8em</atr>;<br><com>border-color</com>: <atr>red orange green blue</atr></tt>
	<p>Non-uniform border-width, with non-uniform border colors, without radius: this use case should
	be handled without artifact.

	<li><tt class="dt"><com>border</com>: <atr>2em solid green</atr>;<br><com>border-radius</com>: <atr>2em</atr></tt>
	<p>Here the border is so thick that it is fused as a solid polygon. You could achieve the same
	by just specifying a <tt>border-radius</tt> and setting the <tt>background-color</tt>.
  </ul>

</ul>

<h3 id="cssborderimg"><span>Border image properties</span></h3>

<p>Border image properties can be used to generate <b>arbitrary border shapes</b>. Its syntax is a little
bit tedious to remember, so here is a refresher:

<pre><com>border-image</com>:        <atr>&lt;uri&gt; &lt;slice&gt; fill|content-fill / &lt;width&gt; / &lt;outset&gt; &lt;repeat&gt;</atr>
<com>border-image-source</com>: <atr>&lt;uri&gt;</atr>
<com>border-image-slice</com>:  <atr>&lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</atr>
<com>border-image-width</com>:  <atr>&lt;dimension&gt; &lt;dimension&gt; &lt;dimension&gt; &lt;dimension&gt;</atr>
<com>border-image-outset</com>: <atr>&lt;dimension&gt; &lt;dimension&gt; &lt;dimension&gt; &lt;dimension&gt;</atr>
<com>border-image-repeat</com>: <atr>stretch|repeat|round|space   stretch|repeat|round|space</atr>
</pre>

<p>First, the <tt>border-image</tt> property needs a image to work with. Then this image needs to be
sliced using up to 4 numbers (without units). These numbers works similarly to the <tt>border-width</tt>
property: they specify (in this order) the top, right, bottom and left slice width of the image:
<div class="photo">
  <img src="images/border-image-slice.png">
</div>

<p>Then you can specify whether the content area will be filled or left untouched: <tt>fill</tt>
keyword will use the inner section of the border image (marked as region 9 in the image above), and
fill the content of the element using the method specified for <tt>border-image-repeat</tt>.
<tt>content-fill</tt> is an extension that will ensure that <tt>background</tt> will only paint up
to the edge of the border-image. <b>Rationale</b>: the fill method for <b>border-image</b> is a bit
limited compared to what is available for background properties.

<p>Then you can specify a different size to render the border, by giving up to 4 numbers (with units
this time). Otherwise, the border will be rendered at the same size than the image.
<span class="n">Note</span>: be sure that the <b>size you set the <tt>border-image</tt> matches the
size you give to the <tt>border-width</tt> property</b>, otherwise your image will be improperly sliced.

<p>Then, you can apply an <b>offset to shift</b> outward (positive value) or inward (negative value, this is
an extension).

<p>Finally, you can specify how the border will be <b>rendered in the edge regions</b> (marked as 5, 6, 7 and
8 in the image above). Horizontal and vertical fill method can be specified independently. There are
4 methods:
<ul>
  <li><tt>stretch</tt>: the slice of the border image will be <b>stretched to fill the content</b> of the
  element. This is the default behavior if nothing is specified.
  <div class="image">
	<img src="images/border_image_stretch.png">
  </div>
  <li><tt>repeat</tt>: the edge slice will be <b>repeated until the entire border of the element is covered</b>
  by the slice. If the border does not have enough space to fill a integral amount of slice, the
  border image can appear clipped.
  <div class="image">
	<img src="images/border_image_repeat.png">
  </div>
  <li><tt>round</tt>: like repeat, but it will <b>shrink the edge slice</b> of the <tt>border-image</tt> so
  that there will always be an integral count of slice that will be drawn:
  <div class="image">
	<img src="images/border_image_round.png">
  </div>
  <p>Depending on the space left, the border image might appear squished by quite a bit.

  <li><tt>space</tt>: an integral amount of slice will be used to draw the border. Unused space will be
  distributed evenly between slices.
  <div class="image">
	<img src="images/border_image_space.png">
  </div>
</ul>

<p>For reference, the examples above used the following image as the source for <tt>border-image</tt> property:
<div class="photo">
  <img src="images/border-diamonds.png">
</div>

<p>This is an 90 &#xd7; 90px image, the elements border's box size are 160 &#xd7; 100px.

<h3 id="cssoutline"><span>Outline properties</span></h3>

<p>Outline can be seen as an <b>extra border</b>, that won't use any space: in the <tt>SITGL</tt> box model,
outline won't affect the geometry of your control: whatever thickness you use for the outline, the
element will always be the same size.

<p>The main difference with border though, is that you <b>cannot</b> specify a different style for
each side: all sides will always use the same style/color/width.

<pre><com>outline</com>:       <atr>&lt;width&gt; &lt;style&gt; &lt;color&gt; &lt;offset&gt;</atr>
<com>outline-width</com>: <atr>&lt;dimension&gt;</atr>
<com>outline-style</com>: <atr>&lt;style&gt;</atr>
<com>outline-color</com>: <atr>&lt;color&gt;</atr>
</pre>

<p>An <b>extension</b> has been added though: a 4th component can be specified for the <tt>outline</tt> property:
this offset can be used to push the outline border outward (positive dimension) or inward (negative dimension).

<p>Outline will also <b>follow the radius of the border</b>, taking its offset into account:
<div class="photo">
  <img src="images/outline_radius.png">
</div>

<p>The <b>first box</b> has a double border, with an outline offset by a third of the border thickness, giving
the illusion of a triple border. The yellow background shows where the border box extends:
<pre><com>border</com>: <atr>1em double black</atr>;
<com>outline</com>: <atr>0.3em solid black 0.3em</atr>;
<com>border-radius</com>: <atr>50%</atr></pre>

<p>The <b>second box</b> has its outline pushed inward (negative offset), reducing the radius of the
outline accordingly.

<p>That being said, the <b>typical use case for outline</b> is to highlight <b>keyboard focus</b>, using the
<tt>:kbdfocus</tt> pseudo-class.

<h3 id="csstextshadow"><span>Text shadow</span></h3>

<pre><com>text-shadow</com>: <atr>&lt;offsetX&gt; &lt;offsetY&gt; &lt;blurradius&gt; &lt;color&gt;</atr></pre>

<p><b>Text shadow behaves similarly to box shadow</b>, and has a similar purpose: add depth to the text. Multiple
shadows can be specified, separated by comma, they will be rendered from top to bottom, layer per layer.
Consider the following example:
<div class="photo">
  <img src="images/text_shadow.png">
</div>

<p>The <tt>text-shadow</tt> property has been assigned to the following value:
<pre><com>text-shadow</com>: <atr>1px 1px 2px black, 0 0 1em blue, 0 0 0.2em blue;</atr></pre>

<p>The second layer has a blur radius of <tt>1em</tt>, which is way higher than the line height. This
shadow actually overlaps the rows above and below any line of text, but since shadows are rendered layer
per layer (and not line per line), they will not overwrite part of previous text.

<p>Since text shadows are rendered after the border, they can overwrite this part though.

<h3 id="csstext"><span>Text/font properties</span></h3>

<p>Continuing in the rendering stack, we have all the properties that can affect <b>text appearance</b>.

<pre><com>color</com>: <atr>&lt;color&gt;</atr></pre>

<p>The first one is the property defining the <b>color of the text</b>. This property will also define
default color of borders (including outline) if none have been given.

<pre>
<com>font</com>:        <atr>&lt;style&gt; &lt;weight&gt; &lt;size&gt; &lt;family&gt;</atr>
<com>font-style</com>:  <atr>&lt;style&gt;</atr>
<com>font-weight</com>: <atr>&lt;weight&gt;</atr>
<com>font-size</com>:   <atr>&lt;dimension&gt;</atr>
<com>font-family</com>: <atr>&lt;family&gt;</atr>
</pre>

<p>Next is <b>font management</b>. The way fonts are mapped will be described more in detail in the
<a href="#SIT_APP">SIT_APP</a> section. But as a quick summary: association between font file (.ttf)
and CSS properties (family, weight and style) has to be done manually using the <tt>SIT_APP</tt>
control. Therefore the properties <tt>font-style</tt>, <tt>font-weight</tt> and <tt>font-family</tt>
will support as many values as you will configure for the root widget.

<p>Then there are <b>various properties</b> that can change more aspect of the text:
<ul>
  <li><tt class="dt">letter-spacing: &lt;dimension&gt;</tt>
  <p>Specify how far apart individual letters (including space) will be. Negative numbers are allowed:
<div class="image">
  <img src="images/letter_spacing.png">
</div>
  <li><tt class="dt" id="csslineheight"><com>line-height</com>: <atr>&lt;dimension&gt;</atr></tt>
  <p>Specify how <b>far apart individual lines will be</b>.
  By default line will be stacked on top of each other without gap. The number specified will be used as is.
  If you give an absolute number, it will use that number no matter what the practical line height is.
  <p>Therefore, it is strongly advised to use relative unit (ie: percentage). Numbers without unit are
  also allowed, it means the ratio by which the line height will be multiplied, eg: 1.1 is like 110%.

  <li><tt class="dt" id="csstabsize"><com>tab-size</com>: <atr>&lt;integer&gt;</atr></tt>
  <p>Useful only when white spaces are preserved (see <tt>white-space</tt> property). Specify the
  amount of <b>space characters</b> that the tab character (ASCII code 9) will be worth of (width wise).
  Whenever a tab character is found within the text, the text following that character will start
  on the next integral multiple of that width.

  <p>This property is particularly useful for the widget <tt>SIT_EDITBOX</tt>: the value given for
  this property will be honored.

  <li><tt class="dt" id="csstextalign"><com>text-align</com>: <atr>left|right|center|justify</atr></tt>
  <p>How the text will be formatted. Justified text needs to have line wrapped for the effect to be
  visible (ie: last line of a paragraph will always be left aligned).

  <li><tt class="dt"><com>text-decoration</com>: <atr>none|underline|overline|line-through &lt;color&gt; solid|double|wavy</atr></tt>,<br>
  <tt class="dt"><com>text-decoration-color</com>: <atr>&lt;color&gt;</atr></tt>,<br>
  <tt class="dt"><com>text-decoration-style</com>: <atr>solid|double|wavy</atr></tt>
  <p>Various decoration style you might want to apply to your text:
  <div class="photo" style="float: left; text-align: center">
	<img src="images/text_deco_solid.png"><br>
	solid
  </div>
  <div class="photo" style="float: left; text-align: center">
	<img src="images/text_deco_double.png"><br>
	double
  </div>
  <div class="photo" style="float: left; text-align: center">
	<img src="images/text_deco_wavy.png"><br>
	wavy
  </div>
  <p style="clear: left"><span class="n">Caveat</span>: <tt>text-decoration</tt> don't generate any
  shadow from <tt>text-shadow</tt>.

  <li><tt class="dt" id="csstexttrans"><com>text-transform</com>: <atr>none|uppercase|lowercase</atr></tt>
  <p><b>Force case of text</b>. This property is also honored by the widget <tt>SIT_EDITBOX</tt>, and is
  actually a bit more than just a visual effect: characters stored in the edit buffer will also be
  converted to the specified case.

  <li><tt class="dt"><com>vertical-align</com>: <atr>baseline|sub|super|top|middle|bottom|&lt;dimension&gt;</atr></tt>
  <p>Usually only applies to inlines, with the exception of <tt>vertical-align: middle</tt>. This
  can be applied to top level box elements. It will vertically center the text (SIT_Title) property
  with the container. Default value is <tt>baseline</tt> for inlines and <tt>top</tt> for block
  level.

  <li><tt class="dt"><com>word-spacing</com>: <atr>&lt;dimension&gt;</atr></tt>
  <p><b>Space between words</b>, will be added on top of <tt>letter-spacing</tt>.

  <li><tt class="dt"><com>white-space</com>: <atr>normal|nowrap|pre|pre-line|pre-wrap</atr></tt>
  <p>Defines how white-space will be handled for the <tt>SIT_Title</tt> property:
  <ul>
	<li><tt>normal</tt>: space will be collapsed, newlines will be ignored, lines will be wrapped if
	there isn't enough space.
	<li><tt>nowrap</tt>: like normal (spaces collapsed, newlines ignored), but lines will not be wrapped.
	<li><tt>pre</tt>: keep formatting as is (spaces and newlines), don't break lines.
	<li><tt>pre-ine</tt>: collapse space, but only use newlines as line break.
	<li><tt>pre-wrap</tt>: keep formatting as is and break lines if necessary.
  </ul>
</ul>

<p>Finally a few <b>non-standard property</b> exists that are related to text:
<ul>
  <li><tt class="dt"><com>-caret-color</com>: <atr>&lt;color&gt;</atr></tt>
  <p>This property was added before the caret of text edit box were blinking. Back then, it was kind
  of hard to locate, giving it a different color from the text was kind of helpful, although nowadays
  this property is <b>kind of obsolete</b>. The default value for the caret color is the same as the text color.

  <li><tt class="dt"><com>selection</com>: <atr>&lt;color&gt;  &lt;color&gt;</atr></tt>
  <p>This property is mostly useful for the text edit widget: it will set the foreground and
  background <b>color of selected text</b>. By default, the colors will use the same colors used by the
  operating system.
</ul>

<h3 id="cssothers"><span>Other properties</span></h3>

<p>A few miscellaneous properties are left:
<ul>
  <li><tt class="dt"><com>left</com>: <atr>&lt;dimension&gt;</atr></tt>,<br>
	  <tt class="dt"><com>top</com>: <atr>&lt;dimension&gt;</atr></tt>
  <p>Every top level container box has a <tt>position: relative</tt> inherently set. You can <b>nudge
  the location</b> by setting the value of these two properties.

  <li><tt class="dt" style="vertical-align: top"><com>padding</com>: <atr>&lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt;</atr><br>
<com>padding-top</com>: <atr>&lt;dimension&gt;</atr><br>
<com>padding-right</com>: <atr>&lt;dimension&gt;</atr><br>
<com>padding-bottom</com>: <atr>&lt;dimension&gt;</atr><br>
<com>padding-left</com>: <atr>&lt;dimension&gt;</atr></tt>
  <p>Define the amount of <b>space between the content and the border</b>. Remember that
  <a href="#geometry">geometry</a> within <tt>SITGL</tt> will defines the border-box of the element.
  Any padding and border will subtract from this box.

  <li><tt class="dt"><com>opacity</com>: <atr>&lt;real&gt;</atr></tt>
  <p>Define alpha level of all the elements inside the container. <span class="n">XXX</span> doesn't
  handle group transparency at all, so this property is kind of useless.
</ul>

<h2 id="widgets">Widgets/Controls</h2>

<p>This chapter will present <b>what controls are supported by this library</b>, and their expected
behavior. For a complete list you can check the SIT main header (<tt>SIT.h</tt>), most of the attributes
are pretty straightforward. This is a long chapter, which basically describes what parameters the
<tt>SIT_CreateWidget()</tt> and <tt>SIT_SetValues()</tt> functions can take. You can safely skip to
the next chapter, if you do not want to deal with that amount of details now.

<h3 id="SIT_WIDGET"><span>SIT_WIDGET</span></h3>

<p>This is not a real widget (<b>it cannot be directly instantiated</b>), but it contains a few
common properties that are shared with almost all controls. You have already seen a bunch of them,
when talking about <a href="#geometry">geometry management</a>. There are a few more:

<ul>
  <li><tt class="dt">SIT_Title</tt> (<tt class="t">STRPTR</tt>)
  <p>This property can <b>change the text displayed within the container</b> box of a widget. Depending
  on the widget type, this text might be displayed at different places. For exemple, edit boxes use this
  property to store the text being edited, while dialogs use it to set the text within the title bar.

  <li><tt class="dt">SIT_UserData</tt> (<tt class="t">APTR</tt>)
  <p>An <b>arbitrary pointer</b> you want to associate with your widget.

  <li><tt class="dt">SIT_Enabled</tt> (<tt class="t">Bool</tt>)
  <p><b>Enable or disable the control</b>. If it is disabled, all children will also be disabled.
  When re-enabled, the children will get the state they had before.

  <li><tt class="dt">SIT_Visible</tt> (<tt class="t">Bool</tt>)
  <p><b>Show or hide the control</b> (including dialog). By default dialogs are created hidden, to
  give you room to populate them with controls, while controls are created visible.

  <li><tt class="dt">SIT_NextCtrl</tt> (<tt class="t">STRPTR</tt>) <span class="ro">write-only</span>
  <p>This property specifies in which order, controls will be scanned using
  the tab key. You can use the following values for this property (case insensitive):
  <ul>
	<li><tt>NONE</tt>: <b>this control</b> will never receive the focus using the tab key.
	<li><tt>FIRST</tt>: <b>this control</b> be set as the first in the list.
	<li><tt>LAST</tt>: <b>this control</b> be set as the last in the list. <b>This is the default value</b>.
	<li><em>Anything else</em>: will look for a control with that name and use it as the next control
	to focus when pressing the tab key from <b>this control</b>.
  </ul>
  <p>Obviously you shouldn't use these pre-defined names as your control's name if you want to reorder
  the focus ring.

  <li><tt class="dt">SIT_Parent</tt> (<tt>SIT_Widget</tt>) <span class="ro">read-only</span>
  <p>This property is read-only. It can retrieve the <b>parent of the widget</b>. Will be NULL for a
  <tt>SIT_APP</tt> widget.

  <li><tt class="dt">SIT_CtrlType</tt> (<tt class="t">int</tt>) <span class="ro">read-only</span>
  <p>Get the <b>type of the control</b> (second parameter of <a href="#SIT_CreateWidget"><tt>SIT_CreateWidget()</tt></a>).
  This property is read-only.

  <li><tt class="dt">SIT_Name</tt> (<tt class="t">STRPTR</tt>) <span class="ro">read-only</span>
  <p>Get the <b>name of the control</b> (first parameter of <a href="#SIT_CreateWidget"><tt>SIT_CreateWidget()</tt></a>).
  This property is read-only and do not change the value returned.

  <li><tt class="dt">SIT_Style</tt> (<tt class="t">STRPTR</tt>) <span class="ro">write-only</span>
  <p>Set the <b>inline CSS styles</b> of the widget. This property is <b>write-only</b>. You can specify
  any number of css property you want, but syntax must remain valid. This property uses the same error
  recovery than when parsing a complete stylesheet.

  <li><tt class="dt">SIT_TagList</tt> (<tt class="t">KeyVal</tt>)
  <p>This tag is useful if you want to use an array instead of a vararg to pass arguments to
  <tt>SIT_CreateWidget()</tt> or <tt>SIT_SetValues()</tt>. The expected argument is an array of
  <tt>KeyVal_t</tt> structure. It is declared like this:
  <pre><type>typedef struct</type>
{
	<type>int</type> tag;
	<type>union</type> {
		<type>ULONG</type>  val;
		<type>APTR</type>   ptr;
		<type>double</type> real;
	} key;
} KeyVal_t;</pre>

  <p>Depending on the type of the property, you either have to initialize the <tt>val</tt>, <tt>ptr</tt>
  or <tt>real</tt> field of the union (the type expected by a property is available in the <tt>SIT.h</tt>
  header file). The table has to be ended by a <tt>SIT_TagEnd</tt> (<tt class="o">0</tt>) as value for the
  <tt>tag</tt> member. To initialize such a table, you can use the C99
  notation:</p>
  <pre>KeyVal_t my_args[] = {
	{SIT_Title,   {.ptr = <val>"Options"</val>}},
	{SIT_Margins, {.val = SITV_Em(<val>1</val>)}},
	{<val>0</val>,           {.val = SITV_Em(<val>1</val>)}},
	{<val>0</val>,           {.val = SITV_Em(<val>1</val>)}},
	{<val>0</val>,           {.val = SITV_Em(<val>1</val>)}},
	{SIT_TagEnd}
};</pre>
  <p>Take note that any arguments after a <tt>SIT_TagList</tt> will be ignored.</p>
</ul>

<p>Also, for property that expect a String (<tt class="t">STRPTR</tt>) value, you can combine the property
name with the <tt>XfMt</tt> flag. You can then specify a <tt>printf</tt>-like format string as argument
to this property, followed by any argument needed by the format string itself. Like for example:

<pre>SIT_Widget w = SIT_CreateWidget(<val>"main"</val>, SIT_DIALOG, app,
	SIT_Title | XfMt, <val>"XMines <spe>%s</val>"</spe>, levels[game-&gt;level].name,
	<val>NULL</val>
);</pre>

<p>A few more specialized attributes exist, check out <tt>SIT.h</tt> for the complete list.</p>

<h3 id="SIT_APP"><span>SIT_APP</span></h3>

<p>Also <b>not a proper control</b>, you will get it from the <tt>SIT_Init()</tt> function. You can create
more if you want, but only the one provided by <tt>SIT_Init()</tt> will be useful to your application.
You'll want to provide additonal information, especially when it comes to font mapping, as well some
other properties:

<ul>
  <li><tt class="dt" id="SIT_DefSBArrows">SIT_DefSBArrows</tt> (<tt class="t">enum</tt>),<br>
	  <tt class="dt">SIT_DefSBSize</tt> (<tt class="t">int</tt>)
  <p>This 2 properties will give you an opportunity to configure the <b>automatic scrollbars</b> that some
  widget might have to create. The first one is an enumeration that defines where arrow buttons will
  appear:
  <ul>
	<li><tt>SITV_NoArrows</tt>: no buttons, only a scroll bar (this is the default value).
	<li><tt>SITV_ArrowsTopBottom</tt>: up arrow will be on top, down arrow on bottom (respectively
	left/right for horizontal scrollbar).
	<li><tt>SITV_ArrowsTop</tt>: both up and down arrow buttons will be on top (left if horizontal).
	<li><tt>SITV_ArrowsBottom</tt>: both buttons will be on bottom (right if horizontal).
  </ul>
  <p>Then the second property (<tt>SIT_DefSBSize</tt>) will let you set the default width (height if
  horizontal) of the scrollbar. By default this value is set to 1em.

  <li><tt class="dt">SIT_RefreshMode</tt> (<tt class="t">enum</tt>)
  <p>As discussed in the <a href="#SIT_RenderNodes"><tt>SIT_RenderNodes</tt></a> section, this will define
  what this <b>function will be doing each time it is invoked</b>:
  <ul>
	<li><tt>SITV_RefreshAlways</tt>: the entire interface will be redrawn whenever <tt>SIT_RefreshNodes()</tt>
	is called.
	<li><tt>SITV_RefreshAsNeeded</tt>: only when something has changed will the interface be redrawn,
	otherwise it will return (almost) immediately.
  </ul>

  <li><tt class="dt">SIT_LocaleInfo</tt> (<tt>LocaleInfo *</tt>) <span class="ro">read-only</span>
  <p>You can retrieve that property to get some <b>information on the current localization</b> (ie: language)
  currently used by the operating system. Check the section <a href="#i18n">internationalization</a>
  for more information about this property.

  <li><tt class="dt">SIT_CurrentDir</tt> (<tt class="t">STRPTR</tt>) <span class="ro">read-only</span>
  <p>Get the <b>fully qualified path</b> of where the application has been started.

  <li><tt class="dt">SIT_ScreenWidth</tt> (<tt class="t">int</tt>),<br>
	  <tt class="dt">SIT_ScreenHeight</tt> (<tt class="t">int</tt>) <span class="ro">read-only</span>
  <p>These values contains the <b>maximum screen size</b> of the monitor where the application is about
  to start. You might want these values to get the maximum bounds for off-screen framebuffers.

  <li><tt class="dt">SIT_NVGcontext</tt> (<tt class="t">NVGcontext *</tt>) <span class="ro">read-only</span>
  <p>If you want to use nanovg facilities outside of <tt>SITGL</tt> context, you can read this property.
  The context is guaranteed to not change until the application exits, so you just have to grab it once.
  You'll have to initialize the context with <tt>nvgBeginFrame()</tt> and <tt>nvgEndFrame()</tt> yourself
  though.

  <p>If you want to generate graphics within a <tt>SITGL</tt> context, it is advised to register a
  <tt>SITE_OnPaint</tt> callback: a <tt>nanovg</tt> context will be provided, ready to received drawing
  commands (no need to call <tt>nvgBeginFrame()</tt>).

  <li><tt class="dt">SIT_AddFont</tt> (<tt class="t">STRPTR</tt>, <tt class="t">STRPTR</tt>) <span class="ro">write-only</span>
  <p>This is the property to use to <B>map the CSS <tt>font</tt> property to .TTF files</b>. This property is
  expecting two strings as argument, this property can also be used as many times as necessary. The first
  argument must be an encoded font specification and the second is the TTF file to use for this specification.

  <p>The specification is built from the parameters given to the CSS <tt>font</tt> property (or its
  derivatives). This specification is always built the same way to ensure a consistent naming:
  <ol>
	<li>The font name (from <tt>font-family</tt>) is taken as is.
	<li>Then, if <tt>font-weight</tt> is set to <tt>bold</tt>, the string <tt class="o">"-bold"</tt> is appended to that name.
	<li>At last, if <tt>font-style</tt> is set to <tt>italic</tt>, the string <tt class="o">"-italic"</tt> is added.
  </ol>
  <p>For example, giving a <tt>font</tt> property the value <tt>sans-serif italic bold</tt>, will look for a
  TTF font registered for the specification <tt class="o">"sans-serif-bold-italic"</tt>.

  <p>Then you need to specify a TTF font file. There are 2 ways to do so:
  <ol>
	<li><b>Direct link to a TTF file</b>: simply provide a path to a valid TTF file.
	<li><b>Operating system font</b>: if the path does not exist, it will be interpreted as a font
	specification to look in the operating system font registry. This specification must start with
	the family name, then followed by one or more optional attributes: "/bold" or "/italic".
	<p>For example: <tt class="o">"Arial/bold/italic"</tt> will look for the TTF file for this font.
	On Windows, it is usually located in <tt>C:\Windows\fonts\arialbdi.ttf</tt>.
	<p>You can also use the <b>special name</b> <tt class="o">"System"</tt> to request the same font
	that is currently used by most applications.
  </ol>

  <p>Here are a few examples on how to setup font mapping in SITGL:
  <pre><com>/* uses operating system font */</com>
SIT_SetValues(app,
	SIT_AddFont, <val>"sans-serif"</val>,        <val>"Arial"</val>,
	SIT_AddFont, <val>"sans-serif-bold"</val>,   <val>"Arial/bold"</val>,
	SIT_AddFont, <val>"sans-serif-italic"</val>, <val>"Arial/italic"</val>,
	<val>NULL</val>
);
<com>/* uses explicit files */</com>
SIT_SetValues(app,
	SIT_AddFont, <val>"sans-serif"</val>,      <val>"fonts/Roboto-Regular.ttf"</val>,
	SIT_AddFont, <val>"sans-serif-bold"</val>, <val>"fonts/Roboto-Bold.ttf"</val>,
	<val>NULL</val>
);</pre>
  <p>To check if the mapping has been successful, you can grab a nanovg context and try to map the font,
  using a code similar to:
  <pre><kwd>if</kwd> (nvgFindFont(nvg, <val>"sans-serif"</val>) &lt; <val>0</val>)
{
	<com>/* font not found ... try using "System" as a fallback */</com>
}</pre>
  If you get an error, you might want to try with a different font (especially if you used an operating
  system font).

  <li id="SIT_AccelTable"><tt class="dt">SIT_AccelTable</tt> (<tt>SIT_Accel *</tt>)
  <p>This property can be used to <b>register global shortcuts</b>, that can be checked way before dispatching
  keyboard events to individual widgets. The typical use case for this feature is to provide menu shortcuts
  typical of desktop applications, but without the menu. The <tt>SIT_Accel</tt> structure is declared as
  follows:
  <pre><type>struct</type> SIT_Accel_t
{
	<type>int</type>          key;
	<type>int</type>          event;
	<type>STRPTR</type>       target;
	SIT_CallProc cb;
};</pre>
  <p>Each fields has the following meaning:
  <ul>
	<li><tt>key</tt>: a combination of <tt>SITK_...</tt>, representing the <b>shortcut you want to register</b>. For example
	<tt>SITK_FlagAlt + SITK_F4</tt> to register a callback when the key combination <span class="key">Alt+F4</span>
	is pressed.
	<p>Although permitted, you can register single key press as global shortcuts. Like <tt>'S'</tt> is
	a valid value for this field (ie: ASCII code of character S, case does not matter). It is strongly
	advised to prefix the shortcut with a qualifier. Those qualifier starts with <tt>SITK_Flag...</tt>,
	like <tt>SITK_FlagShift</tt> or <tt>SITK_FlagCtrl</tt>.

	<p>The shortcut can be added with the value <tt>SITK_FlagCapture</tt>. Accelerators will then
	be checked before sending keyboard events to widgets, otherwise it will be done after (if the
	event hasn't been processed by a widget).

	<p>Therefore without <tt>SITK_FlagCapture</tt>, a global callback might not be triggered.
	
	<p>The typical use case for capture flag, is to register an exit shortcut, so that you don't have to
	worry about it in your event loop.

	<li><tt>event</tt>: what <b>kind of event</b> this shortcut will trigger. Must an event type,
	ie: <tt>SITE_...</tt>, like <tt>SITE_OnClose</tt> or <tt>SITE_OnActivate</tt>.

	<li><tt>target</tt>: the <b>name of a widget</b>, which will receive the event. You can also set this field
	to <tt class="o">NULL</tt>, in which case the event will be sent to the <tt>SIT_APP</tt> widget.

	<li><tt>cb</tt>: If the callback registered for the event did not process it or the <tt>target</tt>
	field was set to <tt class="o">NULL</tt>, you can register a callback that will be called whenever
	the shortcut is pressed.
  </ul>
  
  <p><span class="n">Note</span>: this property is <b>expecting a array of <tt>SIT_Accel_t</tt> structure</b>,
  whose last entry must have its <tt>key</tt> field set to 0. A typical way to initialize such an array is
  as follows:
  <pre><type>static struct</type> SIT_Accel_t accels[] = {
	{SITK_FlagCapture + SITK_FlagAlt + SITK_F4, SITE_OnClose, <val>NULL</val>},
	{SITK_FlagCapture + SITK_Escape,            SITE_OnClose, <val>NULL</val>},
	{<val>0</val>}
  };
  </pre>
  
  <p><span class="n">Caveat</span>: <b>the array will not be copied</b> by <tt>SITGL</tt>: it will be used
  as is when scanning its entries in the keyboard event dispatching function. That means, do not
  use a locally-allocated array (unless you are in the <tt>main()</tt> function), add the <tt>static</tt>
  keyword.

  <li><tt class="dt" id="SIT_ExitCode">SIT_ExitCode</tt> (<tt><type>int</type> *</tt>)
  <p>You can register an integer that will be written with the value 1 whenever the user requested to
  exit the application (be it through global shortcuts or push button that called the <tt>SIT_Exit()</tt>
  function). The typical use case is to use that variable in the outer-most loop of the main event loop, like this:
  <pre><type>static int</type> exit = <val>0</val>;

SIT_SetValues(app, SIT_ExitCode, &exit, <val>NULL</val>);
FrameSetFPS(<val>60</val>);

<kwd>while</kwd> (! exit)
{
	SDL_Event event;

	<kwd>while</kwd> (SDL_PollEvent(&event))
	{
		<kwd>switch</kwd> (event.type) {
		<com>/* dispatch events */</com>
		}
	}
	
	<com>/* rendering part */</com>

	FrameWaitNext();
}
</pre>

  <li><tt class="dt">SIT_StyleSheet</tt> (<tt class="t">STRPTR</tt>) <span class="ro">write-only</span>
  <p>If for whatever reason you want to <b>reset the entire stylesheet</b> currently used by your application,
  you can set the property to a valid filename, that will replace all the CSS rules currently loaded.
  
  <p>You might want to delete any widgets before, using the <tt>SIT_Nuke()</tt> function.

  <li><tt class="dt">SIT_CompositedArea</tt> (<tt><type>int</type> *</tt>) <span class="ro">read-only</span>
  <p>This property is to know which area(s) are now safe to render when <b>composite rendering</b> is done.
  Check <a href="#annexC">Annex C: advanced rendering API</a> for more information on how to properly
  use that property (it usually involves a bit more than just this property).

</ul>

<h3 id="SIT_DIALOG"><span>SIT_DIALOG</span></h3>

<p>Dialogs are <b>top level windows</b> intended to receive controls in order to process user input. They
also are supposed to be temporary on the screen: at some point they are expected to be closed. If you
want your control to always be present on the screen, simply add them as children of the root widget
(the one returned by <tt>SIT_Init()</tt>).

<p>Dialogs comes in two flavors: <b>normal</b> or <b>plain</b>:

<div class="image vmargin" style="float: left">
  <img src="images/SIT_DIALOG_normal.png" alt="Standard dialog">
  <span class="caption">Standard dialog</span>
</div>
<div class="image vmargin" style="float: left">
  <img src="images/SIT_DIALOG_plain.png" alt="Plain">
  <span class="caption">Plain dialog<br></span>
</div>

<p style="clear: left">In the examples above, here are the declarations that were used:

<pre>
<hdr>dialog</hdr>, <hdr>form</hdr> {
	<com>border-radius</com>:  <atr>0.5em</atr>;
	<com>box-shadow</com>:     <atr>0 0 10px #444</atr>;
	<com>background</com>:     <atr>#f4f4f4</atr>;
	<com>padding</com>:        <atr>2em 0.5em 0.5em 0.5em</atr>
}
<hdr>dialog</hdr> {
	<com>background</com>:     <atr>#303238</atr>
}
<hdr>form</hdr> {
	<com>padding</com>:        <atr>0.5em</atr>
}
<hdr>dialog title</hdr> {
	<com>text-align</com>:     <atr>center</atr>;
	<com>color</com>:          <atr>#aaa</atr>;
	<com>font-weight</com>:    <atr>bold</atr>;
	<com>background</com>:     <atr>linear-gradient(to bottom, #666, #303238 50%, #303238)</atr>;
	<com>border-radius</com>:  <atr>0.5em 0.5em 0 0</atr>;
	<com>vertical-align</com>: <atr>middle</atr>;
	<com>border-bottom</com>:  <atr>2px solid rgba(#000,0.3)</atr>
}
<hdr>dialog client</hdr> {
	<com>padding</com>:        <atr>0.5em</atr>;
	<com>background</com>:     <atr>#efefef</atr>
}
<hdr>dialog close</hdr> {
	<com>font-weight</com>:    <atr>bold</atr>;
	<com>color</com>:          <atr>#d44</atr>;
	<com>text-shadow</com>:    <atr>2px 2px 2px black, -1px -1px 2px white</atr>;
	<com>vertical-align</com>: <atr>middle</atr>;
	<com>text-transform</com>: <atr>uppercase</atr>
}
<hdr>dialog close</hdr>:<pse>hover</pse> {
	<com>color</com>:          <atr>red</atr>
}
<hdr>dialog close</hdr>:<pse>hover</pse>:<pse>active</pse> {
	<com>color</com>:          <atr>red</atr>;
	<com>text-shadow</com>:    <atr>2px 2px 2px #ccc, -1px -1px 2px black</atr>
}
</pre>

<p><b>Normal dialog</b> will have extra children already created for you, with their
attachment setup. You can grab a reference on them and change them if you want. <b>Plain dialog</b> will only
consist of a single child, feel free to add whatever you want. Check the <a href="#selectors">selectors</a>
section to know the name of these parts.


<p>Moreover top level dialog can be modal or modeless. A modal dialog blocks
all input from its parent, it always remain on top of it and does not appear in the task bar. Any attempt
to interact with the parent will not work. A modeless dialog on the other side allows the user to interact
freely between all windows in this mode.

<p>Here are the properties you can set/get on SIT_DIALOG widgets:

<ul>
  <li><tt class="dt">SIT_DialogStyles</tt> (<tt class="t">int</tt>) <span class="ro">create-only</span>
  <p>This tag is a bitfield, that can be combined with the following flags:
  <ul>
	<li><tt class="dt">SITV_Plain</tt>: this is the flag you have to use to create a plain dialog. Otherwise, the
	dialog will be a normal one, with title bar and close button.

	<li><tt class="dt">SITV_Resizable</tt>: if you want your dialog to be resizable, otherwise its
	size will be just enough to accommodate the constraints of your child controls. The area active
	for resizing the dialog will be an area of 0.5em around border and 1em in the corner.

	<p>You might be interested in changing the cursor shape when the mouse cursor is hovering an active
	area. There is an <a href="../examples/exampleSDL.c">example</a> on how to do this using SDL in the
	<tt>examples</tt> folder. Since this is way more work than it is worth, only the SDL and Win32 examples
	have been implemented. In practice, it is strongly advised to <b>avoid using this flag</b> unless
	it is absolutely necessary.

	<p>Since cursor shape has to be handled by the operating system layer (SDL, GLFW, ...), the only help
	you'll be able to get from <tt>SITGL</tt> is a notification as to when you'll need to change it.
	For this, you have to register a callback on the <b>root widget</b> for the event <tt>SITE_OnChange</tt>.
	The <tt>call_data</tt> will be a pointer to a <tt>struct OnChange_t</tt>.

	<p>The <tt>type</tt> field will be set to <tt>SIT_CHANGE_CURSOR</tt> and the <tt>arg</tt> field will
	encode the corner being hovered. It is a bitfield, where bit1 will be set if left edge is hovered,
	bit2 for top edge, bit3 for right edge and bit4 for bottom edge. Obviously, at most 2 bits will
	be set.

	<p>Check out the <tt>examples</tt> folder on how to properly handle this event, even though in
	practice it is better <b>not to use this flag</b>.

	<li><tt class="dt">SITV_NoActivate</tt>: this one is can be used to <b>display a temporary window</b>.
	If you want to open a popup menu from within a dialog, you might not want the parent dialog to
	lose its focus, and thus preventing the title bar from flashing its color from active to inactive
	for a brief moment (assuming the dialog has been themed to reflect those states).

	<li><tt class="dt">SITV_Movable</tt>: will let the user <b>move the dialog</b>. Otherwise it will fixed
	and can only be moved programmatically. The active area for a normal dialog will be its border and
	title (if the dialog is also resizable, only the title bar will be sensitive). For a plain dialog,
	wherever a left-mouse click hasn't been processed by a control, it will trigger a click-drag
	sequence to move the dialog.

	<li><tt class="dt">SITV_Modal</tt>: will prevent any parent controls from <b>receiving user input</b>
	(mouse and keyboard). It will add a 50% black overlay over the entire screen.
	<span class="n">XXX</span> not themable.
  </ul>

  <li><tt class="dt">SIT_AccelTable</tt> (<tt>SIT_Accel *</tt>)
  <p>This tag works the same as the one defined for the <a href="#SIT_AccelTable">SIT_APP</a> widget. The
  idea to provide another accelerator table for a dialog, is that these shortcuts will temporarily override
  the one defined at the <tt>SIT_APP</tt> level.
</ul>

<p>Once a dialog has been created, and controls added, <b>you need to notify the library that the dialog
is ready to be displayed</b>, using the function <tt>void SIT_ManageWidget(SIT_Widget)</tt>.

<hr>

<p>This library also has a crude way to <b>"save" the state of the interface</b>. The typical use case
for this is when you want to display a temporary screen, that will replace everything on screen, but
you don't want to lose everything there is currently, because you'll have to recreate everything once
the temporarily screen is removed. Keep in mind that this feature only works on the dialog level, not
on individual control. For this, there is the following API:

<pre><type>void</type> SIT_ExtractDialog(SIT_Widget w)</pre>

<p>Will remove the dialog from the current tree, but will not free any of its resources, so that it can
added back to the list later, using the following function:

<pre><type>void</type> SIT_InsertDialog(SIT_Widget w)</pre>

<p>This function will also reposition the dialog for you, in case the screen size has changed in the
meantime.

<h3 id="SIT_LABEL"><span>SIT_LABEL</span></h3>

<p>Labels can be either <b>HTML text</b> or consists solely of an <b>image</b> (with some facility to display it at
a reasonable size).

<div class="image vmargin">
  <img src="images/SIT_LABEL.png" alt="4 labels example">
</div>

<p>Labels are very simple controls, not much user interaction can be done with them. By default, label
will be <b>sized so that the entire content is visible, unwrapped</b>. This is not always desirable,
when you have a very long phrase that you want word-wrapped, so that dialog's width remain within tolerable
bounds. To avoid stretching the dialog too much, you can set the width of your label, using the
<tt>SIT_Width</tt> property, the layout manager will be then be able to compute the optimal number of
lines required to display the label unclipped. Note that the opposite does not work: setting the height
to compute the optimal width.</p>

<h4>Label as text</h4>

<p>Setting the <tt>SIT_Title</tt> property will interpret any text as an HTML fragment. Therefore, you
need to be careful when including special characters like <tt>&lt;</tt>, <tt>&gt;</tt> or <tt>&amp;</tt>.
The only entities recognized are <tt>&amp;amp;</tt>, <tt>&amp;lt;</tt>, <tt>&amp;gt;</tt>, <tt>&amp;nbsp;</tt>
and numerical ones like <tt>&amp;#<em>DD</em>;</tt> or <tt>&amp;#x<em>XX</em>;</tt>. Other than that,
simply use UTF-8 text.

<p>You can <b>include HTML tag</b> within the text. You will have to properly style them in your CSS stylesheet.
However, there are a few tags that have a special meaning:
<ul>
  <li><tt class="dt">&lt;img&gt;</tt>
  <p>Use to include an <b>inline image</b>. This tag needs a <tt>src</tt> attribute. Due to code reuse,
  <b class="n"><u>THE IMAGE MUST BE RELATIVE TO WHERE THE STYLESHEET IS</u></b> (not from where the
  program was started). This tag does not nest by default, therefore no need to include a closing tag.
  In CSS (inline or via stylesheet), you can set the CSS property <tt>width</tt> and/or <tt>height</tt>
  to force the size of the image (note: those 2 properties <b>only works on <tt>&lt;img&gt;</tt> tag</b>).

  <p>It is highly likely, you might want to use a higher resolution image and scale it down. If you
  only set the width, the height will be automatically adjusted to keep image's ratio. Same if you
  only set the height, its width will be adjusted accordingly. Of course, you can set both too.

  <li><tt class="dt">&lt;a&gt;</tt>
  <p>This will create a <b>clickable link</b>. You can catch a link activation by registering a
  <tt>SITE_OnActivate</tt> callback on the label. In case your text contains multiple anchors,
  the <tt>call_data</tt> will contain the <tt>SIT_WIDGET</tt> that generated the event.
  
  <p>You can also register a callback on individual <tt>&lt;a&gt;</tt> tag. For this, you'll need to
  add an <tt>id</tt> attribute on the tag, so that you can later get a reference on this particular tag,
  using <tt>SIT_GetById()</tt> function, and register a callback on the value returned instead of
  the label.
  
  <p>If you do not have a callback registered, some default actions will take place:
  <ul>
	<li>If there is an <b>href</b> attribute, it will use that string as an argument to the
	<a href="#OpenDocument"><tt>OpenDocument()</tt></a> function. For example, an <tt>http://</tt>
	link will be opened using the default web browser. A directory will be opened with the Windows
	explorer, ...
	<li>Otherwise, the text content of the link itself will be used as an argument to the same
	function (<span class="n">note</span>: limited to the first 255 characters).
  </ul>

  <li><tt class="dt">&lt;br&gt;</tt>
  <p>Force a <b>line break</b>. This tag does not nest.

  <li><tt class="dt">&lt;xchar&gt;</tt>
  <p>Include a <b>character symbol</b>. In some way, it is similar to an <tt>&lt;img&gt;</tt> tag, except
  its height will automatically match the current font size (its width will then be adjusted accordingly)
  and its color will be modulated using current text color (ie: using CSS <tt>color</tt> property).

  <p>This tag is expecting a <tt>src</tt> attribute and just like the <tt>&lt;img&gt;</tt> tag
  <b class="n"><u>THE IMAGE MUST BE RELATIVE TO WHERE THE STYLESHEET IS</u></b>.

  <p>The typical use case for this tag, is to provide an image in case the font you are using does have
  a special character and you don't want to include an entirely new font just for that character. Note:
  the image should be of much higher resolution than the text, since upscaling bitmap will always look
  extremely blurry.

</ul>

<h4>Label as image</h4>

<p>You might wonder what is the point of having a label solely dedicated to display an image, where
you can just include an <tt>&lt;img&gt;</tt> tag within its title.

<p>The main reason for using this is when the image needs to be <b>dimensioned according to some
geometric constraints</b>. Consider the following example:

<div class="image">
  <img src="images/SIT_LABEL_image.png" alt="constrained image">
  <span class="marker" style="top: -10px; left: -33px">1<span class="liner" style="width: 200px"><span class="lined" style="height: 20px; top: 0; right: 0; left: auto"></span></span></span>
  <span class="marker" style="top: 100px; left: -33px">3<span class="liner" style="width: 50px"></span></span>
  <span class="marker" style="top: 50px; left: 470px">2<span class="linel" style="width: 50px"></span></span>
</div>

<p>This dialog is composed of 3 widgets:
<ol>
  <li>A SIT_LABEL containing one line of text (title).
  <li>A SIT_LISTBOX, with 4 rows, 2 columns.
  <li>A SIT_LABEL used as an image.
</ol>

<p>The problem here, is to know at <b>which size the image needs to be displayed</b> to use the whole vertical
space created by the text: the top/bottom of the image needs to line up with the top/bottom of the text.
But at this point, we don't know the size of the text (worse: depending on word wrapping, it might change
at runtime).

<p>This is where constraint geometry comes to the rescue: the top of the image label is set line up with
the top of the title (using <tt>SITV_AttachOpposite, title, 0</tt> as parameter for <tt>SIT_Top</tt>
property). The bottom attachment is then set to line up with the bottom of the listbox (using
<tt>SITV_AttachOpposite, listbox, 0</tt> as for the <tt>SIT_Bottom</tt> property). Its left and right
attachment are left as is. Obviously the top attachment of the listbox is made relative to the title
label.

<p>Therefore the height of the image will be constrained by the height of the text. Since there was
no constraints on the width, this widget will then assign a width proportional to its height. If the
two other widgets have their left attachment set relative to the image, you now have a fully proportional
layout, that can accommodate almost every situation, with very little effort.

<h4>Label properties</h4>

<p>Here are the properties accepted by this control:
<ul>
  <li><tt class="dt">SIT_ImagePath</tt> (<tt class="t">STRPTR</tt>)
  <p>If this property is set, the label will become an <b>image-only widget</b>, that will be dimensioned
  according to geometric constraints (if there are no constraints, it will simply use the size of the
  image as is: this is usually <b>not</b> what you want).

  <p>To get a text label again, you can set the <tt>SIT_Title</tt> property.

  <p>Note: due to code reuse, <b class="n"><u>THE PATH MUST BE RELATIVE TO WHERE THE STYLESHEET IS</u></b>

  <li><tt class="dt">SIT_LabelSize</tt> (<tt class="t">int</tt>)
  <p>This is used to <b>reserve some space</b> for the label. It is like having an image of the size
  specified for this property, but without having to generate a dummy bitmap. The typical use case for
  this feature is to render the label outside of SITGL control (usually: using an OpenGL draw call).

  <p>The <b>parameter for this property</b> must be supplied with the <tt>SITV_LabelSize(width, height)</tt>
  macro (notice the extra V in its name). The value will be interpreted as pixels, there are no ways
  to specify realtive units.

  <p><span class="n">XXX</span> should use a SIT_CANVAS instead.

  <li><tt class="dt">SIT_Overflow</tt> (<tt class="t">int</tt>)
  <p>Overflow allows you to clip the text if it is bigger that the box of the label. Remember that
  without geometric constraint, label size will be set so that the entire content will be visible. So
  without further additional information, <tt>SIT_Overflow</tt> will do nothing.

  <p>For the overflow to work, you'll have to constraint the width of the label <b>and</b> disable
  word-wrapping using the CSS <tt>white-space</tt> property (typically set to <tt>nowrap</tt>).

  <p>Once this is done, you can select an overflow style:

  <ul>
	<li><tt class="dt">SITV_Multiline</tt>: default value, overflow is disabled.
	<li><tt class="dt">SITV_EllipsisRight</tt>
	<li><tt class="dt">SITV_EllipsisLeft</tt>
	<li><tt class="dt">SITV_EllipsisPath</tt> or <tt class="dt">SITV_EllipsisMiddle</tt>
  </ul>

  <p>Here are some examples of the overflow in action:
  <div class="image">
	<img src="images/SIT_LABEL_overflow.png">
  </div>

  <p><span class="n">Note</span>: text-overflow will always be <tt>...</tt>.

</ul>

<h3 id="SIT_BUTTON"><span>SIT_BUTTON</span></h3>

<p>Push buttons include everything that looks like a button:</p>

<div class="image">
  <img src="images/SIT_BUTTON.png" alt="Push button">
</div>

<p>To produce those visuals, the following CSS styles were used:
<pre>
<hdr>button</hdr> {
	<com>padding</com>:         <atr>0.3em 1.5em 0.2em</atr>;
	<com>border-radius</com>:   <atr>0.2em</atr>;
	<com>background</com>:      <atr>linear-gradient(to bottom, #f2f2f2, #ebebeb 50%, #dbdbdb 50%, #cfcfcf)</atr>;
	<com>border</com>:          <atr>1px solid #707070</atr>;
	<com>color</com>:           <atr>black</atr>;
	<com>text-align</com>:      <atr>center</atr>
}
<hdr>button</hdr>:<pse>active</pse> {
	<com>background</com>:      <atr>linear-gradient(to bottom, #c2e4f6, #c2e4f6 50%, #9ad2f0 50%, #9ad2f0)</atr>;
	<com>box-shadow</com>:      <atr>0 2px 5px #2681af inset, 0 0 2px #333 inset</atr>
}
<hdr>button</hdr>:<pse>disabled</pse> {
	<com>border-color</com>:    <atr>#adb2b5</atr>;
	<com>outline</com>:         <atr>1px solid #fafafa -2px</atr>;
	<com>background</com>:      <atr>#efefef</atr>;
	<com>color</com>:           <atr>#aaa</atr>
}
<hdr>button</hdr>:<pse>kbdfocus</pse> {
	<com>outline</com>:         <atr>1px solid #48d8fb</atr>
}
<hdr>checkbox, radio</hdr> {
	<com>border-radius</com>:   <atr>0.2em</atr>
}
<hdr>checkbox box</hdr> {
	<com>padding</com>:         <atr>0.4em</atr>;
	<com>background</com>:      <atr>linear-gradient(to bottom right, #aeb3b9, #f6f6f6)</atr>;
	<com>border</com>:          <atr>1px solid #aaa</atr>;
	<com>outline</com>:         <atr>1px solid #f8f8f8 -2px</atr>;
	<com>vertical-align</com>:  <atr>middle</atr>
}
<hdr>checkbox</hdr>:<pse>checked</pse> <hdr>box</hdr> {
	<com>background</com>:      <atr>url(mask:checkmark.png) no-repeat 50% 50%,
	                 linear-gradient(to bottom right, #aeb3b9, #f6f6f6)</atr>;
	<com>background-size</com>: <atr>80% 80%, 100% 100%</atr>;
	<com>color</com>: <atr>#4b6097</atr>
}
<hdr>radio</hdr>:<pse>kbdfocus</pse>, <hdr>checkbox</hdr>:<pse>kbdfocus</pse> {
	<com>outline</com>:         <atr>2px solid #48d8fb 0.2em</atr>
}
<hdr>radio box</hdr> {
	<com>border-radius</com>:   <atr>1em</atr>;
	<com>border</com>:          <atr>2px solid #888</atr>;
	<com>padding</com>:         <atr>0.4em</atr>;
	<com>background</com>:      <atr>white</atr>;
	<com>vertical-align</com>:  <atr>middle</atr>
}
<hdr>radio</hdr>:<pse>checked</pse> <hdr>box</hdr> {
	<com>background</com>:      <atr>radial-gradient(circle at 50% 45%, transparent, transparent 35%, rgba(black, 0.5) 35%),
	                 radial-gradient(circle at 30% 30%, #c7ebfd, #0c3d5d)</atr>;
	<com>outline</com>:         <atr>2px solid #ddd -3px</atr>
}
</pre>


<p>Push buttons are divided into 3 groups:</p>
<ol>
  <li><strong>Action button</strong>: to allow user to perform immediate actions.</li>
  <li><strong>Check box</strong>: to enable the selection of any combination of a given set
  of options.</li>
  <li><strong>Radio button</strong>: to select one choice among a mutually exclusive set.
  Semantically similar to the ComboBox.</li>
</ol>

<p>The <b>button type is controlled through the <tt>SIT_ButtonType</tt> property</b>,
which can only be set at creation time, using one of the following values:</p>

<ul>
  <li><tt class="dt">SITV_ActionButton</tt>: this is the default type, usually omitted,
  but given for completeness.</li>

  <li><tt class="dt">SITV_CancelButton</tt>: like <tt>ActionButton</tt>, but will also send
  an <tt>OnActivate</tt> event when pressing the <span class="shortcut">ESC</span>
  key. Unless you return <tt class="o">1</tt> from this event, the dialog associated
  to the button will be closed. Basically, it spares you from writing a callback,
  if the code boils down to:
<pre><type>static int</type> closeWindow(SIT_Widget w, <type>APTR</type> cd, <type>APTR</type> ud)
{
	SIT_CloseDialog(w);
	<kwd>return</kwd> <val>1</val>;
}</pre>
  </li>

  <li><tt class="dt">SITV_DefaultButton</tt>: similar to <tt>CancelButton</tt>, it will
  send an <tt>OnActivate</tt> event when pressing the <span class="shortcut">Enter</span>
  key. There will be no default action.</li>

  <li><tt class="dt">SITV_RadioButton</tt>: semantically very similar to a read-only
  combobox (drop-down list). Using one or the other is a matter of taste
  and/or space available on the interface. If the list of options is short
  it can be useful to display them as radio buttons, as they require less
  mouse gestures.</li>

  <li><tt class="dt">SITV_ToggleButton</tt>: it behaves like a checkbox and/or radio button, but has the
  appearance of an action button.
  <p>The <b>main reason</b> for preferring a toggle button instead of a checkbox
  or radio button is that you won't have to provide additional styling rules, if you already did
  everything for a normal push button.
  <p>You can programmatically control the state of the button using the <tt>SIT_CheckState</tt> property.
  You can also use them as a group, similar to a radio button group, if you assign a value to the
  <tt>SIT_RadioGroup</tt> and <tt>SIT_RadioID</tt> properties.
</ul>

<hr>

<p>The <tt>SIT_Title</tt> property behave like a <a href="#SIT_LABEL">label</a>: you can include HTML
tags, images, ... For example setting the title of a button to
<tt class="xml">"<tag>&lt;b&gt;</tag>Test<tag>&lt;/b&gt;</tag> HTML <tag>&lt;span style=<arg>'color: red'</arg>&gt;&lt;xchar src=<arg>'signin.png'</arg>&gt;&lt;/span&gt;</tag>"</tt>,
will give a button similar to:
<div class="photo">
  <img src="images/SIT_BUTTON_styled.png">
</div>

<p>However, it is not possible to insert arbitrary child controls within buttons. You cannot, for example,
insert a SIT_LISTBOX within the button, to use it as a fancy layout. <b>Keep it simple</b>.

<hr>

<p><b>Check box buttons</b> toggle between the checked and unchecked state. By default label is on the
right. If you want to put it on the left, set the <tt>SIT_AlignHoriz</tt> property to <tt>SITV_AlignRight</tt>
(or in a more mnemotechnical way, the box will be set in the far-most direction described by the property,
with the label being aligned in the same direction). The checkmark in the box is controlled through the
<tt>SIT_CheckState</tt> property.

<p><b>Radio buttons</b> behave similarly to check box, there is only one more property to define into
which set the button belong. Only one button in a given set can be "checked", this policy will be enforced
for you, simply specify the set number using the <tt>SIT_RadioGroup</tt> property (<tt class="t">int</tt>).
Take note that groups are <b>only valid within one level of a hierarchy</b> (i.e: if you put a group
of radio buttons with a group id of 0 as immediate children of a dialog, and another group with the
same id as children of a group box, the library will consider this as two independent groups).

<p>Also, when creating your radio buttons, don't forget to specify which one is checked, otherwise all
will remain unchecked.</p>

<p>To know <b>which radio button in a group is selected</b>, you can either scan the <tt>SIT_CheckState</tt>
property for every buttons in this group (which is rather tedious with lots of buttons), or you can get
some help from this library. There are 2 properties you might be interested in:</p>

<ul>
  <li><tt>SIT_CurValue</tt> (<tt class="t">int *</tt>): this property expect
  a pointer to an integer, that has to stay valid as long as the button is managed.
  The library will store the radio button ID that is currently selected in this
  integer. For this to work, you obviously have to set the <b>same</b> reference
  to <b>every buttons</b> in the group, and not just one of them.<br>
  <strong>Note</strong>: this also work with checkbox buttons, although the
  state (0 or 1) of the checkbox will be stored, not the <tt>RadioID</tt>.</li>

  <li><tt>SIT_RadioID</tt> (<tt class="t">int</tt>): this is the value you want
  to store in the reference set using the previous attribute. If you do not set
  this property, a default one will be chosen for you: it is the ordinal
  position of the button within the group, starting at 0.

  <p>Note that the radio button whose <tt>RadioID</tt> match the value currently
  stored in the <tt>SIT_CurValue</tt> pointer, will be checked automatically, you
  don't have to manually set the <tt>SIT_CheckState</tt> property.</p>
</ul>

<hr>


<p>Button <b>activation/state change is notified through the <tt>SITE_OnActivate</tt> event</b>. The <tt>call_data</tt>
for checkbox and radio button will actually be an integer indicating the state of the button: unchecked
(<tt class="o">0</tt>) or checked (<tt class="o">1</tt>). Note that radio buttons that got automatically
unchecked in the set won't get any event notification.

<p>Also take note that setting programmatically the property <tt>SIT_CheckState</tt>
on radio buttons or check boxes <strong>will not</strong> trigger your event handler.
Mutual exclusivity policy will still be enforced on radio buttons though.

<div class="bgtip" style="width: 70%; margin: auto"><p><b>Note:</b>
buttons also respond to <tt>SITE_OnClick</tt> event.
<p>Using <tt>SITE_OnActivate</tt> or <tt>SITE_OnClick</tt> depends on what type of feedback you are
going to provide to the user: if you are only giving <b>visual feedback</b>, you should register events
with <tt>SITE_OnActivate</tt>. If you are providing <b>sound feedback</b>, you should use
<tt>SITE_OnClick</tt>, and not even bother providing a CSS activated style (<tt>:active</tt>).
</div>

<h3 id="SIT_FRAME"><span>SIT_FRAME</span></h3>

<p>Frame or group box are a way to organize your controls to help users recognize
related features. It can be seen as a label with an etched border:</p>

<div class="image">
  <img src="images/SIT_FRAME.png" alt="Group box">
</div>

<p>Here are the CSS styles used for this control:
<pre>
<hdr>fieldset</hdr> {
	<com>border</com>:        <atr>2px solid #888</atr>;
	<com>border-radius</com>: <atr>0.5em</atr>;
	<com>color</com>:         <atr>#06c</atr>
}
</pre>

<p>Frames are one of the few controls that act as container for other controls, they can be given as
<tt>parent</tt> parameter of the <tt>SIT_CreateWidget()</tt> function. They behave exactly as dialogs
in terms of geometry management, they can be seen as dialog within the dialog: the <tt>SIT_Margins</tt>
related properties applies, <tt>SITV_AttachForm</tt> attachment is relative to frame's border (and not
the dialog), and unless explicitly set, their size will be set so that all controls within the frame
are visible.</p>

<p>The frame widget has no specific properties and fire no events. Margins will be set so that they will
leave about 5 pixels from each borders, which might be a little tight. Also take note that border itself
is about 3 pixels wide (it depends on theme setting, but does not vary that much). Although discouraged,
remember that margins can be overridden using negative offset for <tt>SITV_AttachForm</tt>.</p>



<h3 id="SIT_EDITBOX"><span>SIT_EDITBOX</span></h3>

<p>Edit box can be used to enter almost any form of text. The capabilities of this widget is very
close to what you would expect from a typical <b>text editor</b>: support for multi-line text, selection
using mouse and keyboard, clipboard, undo/redo, word/character wrapping, insert/replace mode, tab can
be used as character, right/left/center/justified alignment, ...

<p>Also care has been given when it comes to <b>memory management</b>: this widget can be configured so
that no memory allocation will be done during its lifetime (only in the initialization phase), and
thus can deal with user-provided memory buffer as storage.

<div class="image">
  <img src="images/SIT_EDITBOX.png" alt="Plain edit box">
</div>

<p>Here are the styles used for the controls in the screenshot above:
<pre>
<hdr>editbox</hdr> {
	<com>padding</com>:         <atr>0.3em 0.1em 0.3em</atr>;
	<com>background</com>:      <atr>white</atr>;
	<com>border</com>:          <atr>1px solid #666</atr>
}
<hdr>editbox spin.up</hdr> {
	<com>background</com>:      <atr>url(mask:arrowup.png) 60% 50% no-repeat, rgba(black, 0.1)</atr>;
	<com>color</com>:           <atr>#aaa</atr>;
	<com>background-size</com>: <atr>70% 35%, 100% 100%</atr>;
}
<hdr>editbox spin.down</hdr> {
	<com>background</com>:      <atr>url(mask:arrowdown.png) 60% 50% no-repeat, rgba(black, 0.1)</atr>;
	<com>color</com>:           <atr>#aaa</atr>;
	<com>background-size</com>: <atr>70% 35%, 100% 100%</atr>;
}
<hdr>editbox spin.up</hdr>:<pse>active</pse> {
	<com>background</com>:      <atr>url(mask:arrowup.png) 60% 50% no-repeat, rgba(black, 0.7)</atr>;
	<com>color</com>:           <atr>#ccc</atr>
}
<hdr>editbox spin.down</hdr>:<pse>active</pse> {
	<com>background</com>:      <atr>url(mask:arrowdown.png) 60% 50% no-repeat, rgba(black, 0.7)</atr>;
	<com>color</com>:           <atr>#ccc</atr>
}
<hdr>editbox vscroll thumb</hdr> {
	<com>background</com>:      <atr>#ccc</atr>;
	<com>border</com>:          <atr>0</atr>;
	<com>outline</com>:         <atr>0</atr>;
	<com>border-radius</com>:   <atr>0</atr>
}
</pre>

<p><span class="n">Note</span>: the styles applied to the scrollbar thumb are mostly to cancel the
default styles defined <a href="#SIT_SCROLLBAR">here</a>

<h4 id="edittypes">Edit types</h4>

<p>Text boxes are divided into 3 main categories:
<ol>
  <li><strong>Text input</strong>: using single line or multi-line editing.</li>
  <li><strong>Integer</strong>: will include a spin control to browse through numbers.</li>
  <li><strong>Password</strong>: also known as protected entry: editing capabilities will be limited
  for security reasons.</li>
</ol>

<p>This is controlled through the property <tt>SIT_EditType</tt> <b>at creation time</b>, which can be
assigned to one of the following values:

<ul>
  <li><tt class="dt">SITV_TextBox</tt>
  <p><b>Default value</b> for this property: it will create a single-line edit box.
  <span class="key">Enter</span> key will do nothing. If text extends beyond visible area, it will be
  scrolled so that the cursor remain visible. Also tab character will be ignored, it will simply be used
  to move the keyboard focus to the next control in the chain.

  <li><tt class="dt">SITV_MultiLineEdit</tt>
  <p><b>Allow for full editing capability</b>: <span class="key">Enter</span> will break lines, tab
  characters will be inserted as is, and correctly rendered. A vertical scrollbar will be automatically
  added if text extends beyond vertical space available (but no horizontal scrollbar will be: it is
  advised to enable automatic word wrapping for multi-line text edit).

  <p>This widget is designed to handle a moderate amount of text, usually below 100Kb. Editing
  multi-megabyte files will certainly cause performance issues. Internally the text is stored as
  a contiguous memory buffer: entering a character at the beginning will requires all the characters
  that follow to be moved.
  
  <p><b>The typical use case</b> for this control is to edit a few kilobytes of text at a time.

  <li><tt class="dt">SITV_Password</tt>
  <p><b>Protected entry</b>: will display bullets in place of what the user types. Clipboard operations
  cut and copy will be disabled, but paste will work. Undo/redo will also be disabled, to avoid spreading
  sensitive information all over the memory. Edit buffer will also be zeroed when the widget will be
  destroyed.

  <p><span class="n">Note</span>: when finalized, the control will clear the clipboard if something was
  pasted in the editbox.

  <li><tt class="dt">SITV_Integer</tt>,
	  <tt class="dt">SITV_Float</tt>,
	  <tt class="dt">SITV_Double</tt>
  <p>A <b>single-line</b> text box for <b>numeric entry</b> that include a spin control on its right
  side. Usually this control is expecting you to provide a buffer where the binary representation of
  the number will be written, ie: either a pointer to an <tt class="t">int</tt>, <tt class="t">float</tt>
  or <tt class="t">double</tt>. The edit box does not forbid invalid characters, it will just try its best
  to convert whatever was given by the user to the format you requested.

  <p>Of course, you can still do the conversion yourself, by retrieving a pointer to the edit buffer
  and converting it manually. This will be required, if you want to enter more fancy numbers (like
  monetary amount, using unusual decimal/thousands separators).

  <p>Internally, all numeric inputs use a <tt class="t">double</tt> to represent the number. Remember
  that double precision datatype can be mapped <b>without loss of precision</b> to all the integers
  between 0 and around +/- 10<sup>15</sup> (2<sup>53</sup>), which largely covers 32bit integers and even
  a good chunk of 64bit integers. The conversion will be done through the <tt>strtod()</tt> function,
  which does not handle localization: decimal separator must be . (period) and there must be no
  thousand separators. Exponential numbers works, ie: <tt>1e6</tt> will be converted to 1,000,000.

  <p>For <tt>SITV_Integer</tt> edit box, if the range of possible values is short, you might consider
  using a <a href="#SIT_SLIDER">SIT_SLIDER</a> instead.
</ul>

<h4 id="editcss">CSS styling</h4>

<p>Although the content area is entirely managed by the control, it will honor a few <b>CSS properties</b>
related to text appearance (besides the obvious ones like <tt>color</tt> or <tt>font</tt>):

<ul>
  <li><tt class="dt"><a href="#csstextshadow">text-shadow</a></tt>
  <p>This property will be honored, but be aware that the text in this control is rendered line by line,
  top to bottom (and not layer per layer like for labels). If a shadow extends past the previous line,
  it will overwrite some text.

  <li><tt class="dt"><a href="#csstabsize">tab-size</a></tt>
  <p>Define the size of tab as a multiple of the space character width. By default this value is set to 4,
  which means that a tab character will use up to 4 times the width of a space character.

  <li><tt class="dt"><a href="#csslineheight">line-height</a></tt>
  <p>This property can be used to give more space between lines of text.

  <li><tt class="dt"><a href="#csstextalign">text-align</a></tt>
  <p>All 4 alignment styles (left, center, right and justified) are honored by the control. Right alignment
  is usually for numeric input and justified only works for multi-line text edit, with word-wrapping enabled.

  <li><tt class="dt"><a href="#csstexttrans">text-transform</a></tt>
  <p>You can use this property to enforce a certain case within the text edit. Contrary to CSS in web
  browsers, this is <b>not just a cosmetic feature</b>. The edit buffer will contain exactly what's
  displayed on the screen: that is, automatically converted to upper or lower case (more often than
  not, this is what you want anyway).

</ul>

<p>And that's it (for example <tt>text-decoration</tt>, <tt>word-spacing</tt> and <tt>letter-spacing</tt>
are not supported).

<h4 id="editmem">Memory management</h4>

<p>Like said in the introduction, this control provide a fine grain control over how memory is allocated:
you can choose to let the control manage memory all by its own (and use as much as needed), or provide
your own buffers and/or force its internal buffer to be of fixed size (and thus only requiring a single
allocation at the start).

<p>Here are the properties you can use to configure memory management:

<ul>
	<li><tt class="dt">SIT_EditLength</tt> (<tt class="t">int</tt>) <span class="ro">create-only</span>
	<p>This property will ensure that the edit buffer will not contain more than the <b>bytes</b> (not
	characters) specified for this property. This control will be smart enough not to store partial UTF-8
	sequences. Also, the edit buffer will <b>always be NULL-terminated</b>, therefore the actual number of
	character bytes that can be written will be one less than the amount specified here.

	<p>C-strings being what they are, any C program usually contains lots of fixed-sized buffer where
	allocating strings of potentially unlimited length would be a complete waste of memory. <tt>SITGL</tt>
	acknowledge that it is a reality, and has first class support for it.

	<p>If this property is set to 0 or left unspecified, the edit buffer will be re-allocated as necessary.

	<li><tt class="dt">SIT_EditBuffer</tt> (<tt><type>char</type> []</tt>) <span class="ro">create-only</span>
	<p>This property will only be taken into account, if <tt>SIT_EditLength</tt> has been assigned with a
	positive value. If the edit buffer is fixed, you might be interested in <b>providing your own buffers</b>,
	because otherwise at some point, you'll have to get the edit buffer and copy it to your own buffer
	anyway. You have to make sure that the buffer can hold as many bytes as was specified for the
	<tt>SIT_EditLength</tt> property.
	
	<li><tt class="dt">SIT_MaxUndo</tt> (<tt class="t">int</tt>) <span class="ro">create-only</span>
	<p>Similarly to the edit buffer, <b>the undo/redo buffer can also be of fixed sized</b>. If more operations
	have to be added to the undo/redo buffer when there is not enough room, older operations will simply
	be discarded. If the undo/redo operation itself is too big for the buffer, it will simply not be
	recorded at all.

	<p>To <B>disable the undo/redo</b> feature entirely, you can give any value below 16. 16 bytes is barely
	enough to store one edit and most of the edits will be discarded because of lack of space.

	<p>Fixed size buffer is useful for single line edit: unless otherwise specified, undo buffer for
	numeric entries will be limited to 128 bytes (which is around 10 edits).

	<p>The undo buffer is smart enough to not store single character edits at a time. If you enter
	a stream of character, one after the other, it will be stored as one edit in the undo buffer (and
	use exactly 8 bytes). Same when deleting/replacing characters: as long as an operation is made
	on contiguous characters, it will be stored as one operation in the undo buffer. In case of
	delete/replace, the characters deleted will also have to be stored in the buffer, and thus will
	require a bit more space.

	<li><tt class="dt">SIT_MaxLines</tt> (<tt class="t">int</tt>) <span class="ro">create-only</span>
	<p>This property only makes sense for multi-line text. It will <b>constrain the maximum number of lines</b>
	(including soft lines due to word wrapping) that the user will be able to enter. The typical use
	case is to allow multi-line editing, without requiring a vertical scrollbar. That way you can limit
	the edit area to what is visible on screen and no more.

	<p>This is actually not as perfect as it sounds: due to different resolution, you'll probably have
	to adjust the font size at some point. The problem is that text width is not completely proportional
	to the font size, due to rounding occurring at the character level. This is particularly bad when
	dealing with small font size.

	<p>The only way to reasonably deal with this, is to compute the ideal font size before displaying
	a multi-line text widget with a fixed number of lines. It not that difficult, but still requires
	more work that just setting a value for this property.

</ul>

<h4 id="editprop">Editbox properties</h4>

<p>Here are the other properties you can use that are specific to edit boxes:

<ul>
  <li><tt class="dt">SIT_Title</tt> (<tt class="t">STRPTR</tt>)
  <p>The title property is used to set or get the content of the edit box. Keep in mind that cursor
  position will be reset to 0 when setting this property. Also, just like for other controls, when getting
  the value, you'll get the raw pointer that is used internally to store the text. <b>Do not modify</b>
  anything: any modification will lead to undefined behavior.

  <p><span class="n">Note</span>: end of line will be converted to <tt class="s">'\n'</tt> (ie: newline,
  line feed, LF or ASCII code 10). If you provide text with Windows line ending (<tt class="s">"\r\n"</tt>), they will
  be automatically converted to <tt class="s">'\n'</tt>, and thus, when you'll read that buffer back,
  they will still use the LF character.

  <p>The only character that cannot be entered in the buffer is the NUL byte (because it is used as an
  end of buffer marker almost everywhere in the code). Other than that, any (valid) sequence of UTF-8 is
  permitted, that includes characters from the ASCII range 01 to 31. They will be rendered
  in reverse video, like this:
  <div class="image">
	<img src="images/SIT_EDITBOX_specialchar.png">
  </div>

  <p>Obviously, characters code 9 (tab) and 10 (newline) will be handled as they should. Character
  code 13 (CR) will be converted to newline (LF, ASCII code 10).

  <p>At some point, you might want to get the text as it is formatted on screen (ie: convert soft
  line break into normal line break). For this, you can use the following function:
  <pre><type>int</type> SIT_TextGetWithSoftline(SIT_Widget, <type>STRPTR</type> buffer, <type>int</type> max);</pre>
  The return value indicates how many bytes are needed to store the buffer unclipped, no matter what
  was given as arguments to this function. If you want to be sure to get everything, you should call
  this function a first time with <tt>max</tt> set to <val>0</val>.

  <li><tt class="dt">SIT_StartSel</tt>, <tt class="dt">SIT_EndSel</tt> (<tt class="t">int</tt>)
  <p>These properties allow you to set the cursor (if you specify only one of them) or the part of
  text being selected (if you specify both, with different values). If you select text, the position
  of the cursor will be the value given for <tt>SIT_EndSel</tt>. Both arguments must specify the <b>offset
  in bytes</b> where you want to put the selection and/or cursor. If you specify out of range values,
  they will be clamped to the length of the text.

  <p><span class="n">Note</span>: to have any visual feedback, you need to set the focus on the control <b>before</b> setting
  these properties (using <tt>SIT_SetFocus()</tt>), otherwise for single-line edit, the default
  behaviour when it gets the focus, is to select all the text and place the cursor at the end
  (undoing whatever you provided earlier).

  <li><tt class="dt">SIT_CurValue</tt> (<tt class="t">int *</tt> or <tt class="t">float *</tt> or <tt class="t">double *</tt>)
  <p>This one is only meaningful for numeric types. Its argument must be a pointer
  to a <strong>valid reference</strong> to an integer/float/double, depending on the type of control
  you created. The current value represented by the control will be stored at the location pointed 
  by this reference. Obviously, do not give a reference to a local variable, it will corrupt your stack.
  
  <p>The initial value for this property will be used to set the content of the edit box. In that case,
  the value given to <tt>SIT_Title</tt> (if any) <b>will be ignored</b>.
  
  <p><span class="n">Note</span>: the conversion to text will use a <tt>printf()</tt> derived function
  with the <tt class="s">"%f"</tt> format specifier. That means: no localization support and numbers
  will be written with all digits (no exponent).

  <li><tt class="dt">SIT_RoundTo</tt> (<tt class="t">int</tt>)
  <p>Only useful for numeric types and especially <tt>SITV_Float</tt> or <tt>SITV_Double</tt>. Due to
  limited precision of <tt class="t">float</tt> and <tt class="t">double</tt> types, you very rarely
  want to display all the fractional digits encoded in those types, because it will be mostly rounding
  error.
  
  <p>For example, if you create a <tt>SITV_Float</tt> edit box with a <tt>SIT_ScrollPos</tt> containing the
  value <tt class="o">0.1</tt>, the value displayed without rounding will be <tt class="o">0.100000001490116</tt>.
  To prevent this, you can set this property to round the number at the specified number of fractional digits.

  <li><tt class="dt">SIT_PlaceHolder</tt> (<tt class="t">STRPTR</tt>)
  <p>This property will <b>display a grayed text</b> over the box if nothing is entered by the user yet.
  This text is also handled by this control, and will honor the CSS property <tt>text-align</tt>.
  The color of the placeholder text will be the same color as the normal text, but the alpha channel
  will be divided by 2.

  <p>For multi-line text, the placeholder will sit at the top. This property is mostly designed for
  single-line edits.

  <li><tt class="dt">SIT_TabStyle</tt> (<tt class="t">int</tt>)
  <p><b>How the tab character should be handled</b> (ASCII code 9). You can use one of the following
  enumeration values:
  <ul>
	<li><tt>SITV_TabEditNormal</tt>: Tab will be <b>inserted as is</b> in the edit buffer and behave
	like you would expect from a typical text editor.

	<li><tt>SITV_TabEditToSpace</tt>: Whenever a tab character is present in a text fragment, it will
	be <b>converted to the number of space characters</b> required to reach the next integral multiple
	of <tt>tab-size</tt>.

	<p>Obviously, if characters are then inserted before, the number of spaces introduced previously
	<b>won't be adjusted</b> to reflect the new column position. Also, for the effect to work, you'll
	have to use a monospace font.

	<p>Despite these shortcomings, there is one <b>very good reason why you might want to use this mode</b>:
	if the text being entered in the widget will have to be rendered by your own engine (to be used
	as decals for example), properly rendering tab character might be too much of a hassle to deal with.
	Using space instead could be a decent compromise in that situation.

	<p>Keep in mind that tab processing is done by <tt>SITGL</tt>, and the code to render them
	is not exposed to any public functions (the rendering is way too dependent on internal structures
	from the text edit widget anyway). Also, <tt>nanovg</tt> has no facilities to render them.

	<li><tt>SITV_TabEditForbid</tt>: if the limitations of <tt>SITV_TabEditToSpace</tt> are too problematic,
	you can simply <b>forbid any tab character</b> from appearing in the edit buffer. In that case, if the
	user presses the tab key, it will be used to move the keyboard focus to the next control in the chain.

  </ul>
  
  <p><span class="n">Note</span>: by default, single-line edit will use <tt>SITV_TabEditForbid</tt> and
  multi-line edit will use <tt>SITV_TabEditNormal</tt>. This property lets you override this.

  <li><tt class="dt">SIT_WordWrap</tt> (<tt class="t">int</tt>)
  <p><b>How lines should be wrapped</b> if they happen to reach the limit of the horizontal space available. There
  are 3 possibile choices:
  <ul>
	<li><tt>SITV_WWNone</tt>: no wrapping at all will be made. The content of the edit buffer will
	then scroll left and/or right to make sure the cursor remain visible.
	<li><tt>SITV_WWChar</tt>: lines will be split at arbitrary characters position, as much as can fit
	in the horizontal space available.
	<li><tt>SITV_WWWord</tt>: lines will only be split at word boundaries. What defines a boundary is
	hardcoded within the control and cannot be changed. Also to prevent infinite loop, if a word cannot
	fit within the horizontal space, it will be split at the character level instead.
  </ul>
  
  <p><span class="n">Note</span>: obviously for single-line edit the value for this property will be forced
  to <tt>SITV_WWNone</tt>, with no way to change it.

  <li><tt class="dt">SIT_MinValue</tt> (<tt class="t">double</tt>),<br>
	  <tt class="dt">SIT_MaxValue</tt> (<tt class="t">double</tt>),<br>
	  <tt class="dt">SIT_StepValue</tt> (<tt class="t">double</tt>)
  <p>These properties only make sense for numeric inputs. They allow you to configure the <b>range permitted
  by the control</b>. <tt>SIT_StepValue</tt> control by what amount the spin buttons will change the value.
  Spin buttons can also be controlled using the Up/Down arrow keys. The default values for range are
  +/- infinity and the default step value is 1.

  <p><b class="n">DANGER</b>: take particular attention that these properties needs a <tt class="t">double</tt>
  argument. If you are using the <tt>SIT_SetValues()</tt> or <tt>SIT_CreateWidget()</tt> functions,
  be careful that the numbers you give are promoted to <tt class="t">double</tt>. For example:
  <pre><com>/* <span class="e">this code contains an error</span> */</com>
<type>int</type> fps = <val>60</val>;
SIT_Wiget num = SIT_CreateWidget(<val>"fps"</val>, SIT_EDITBOX, parent,
	SIT_EditType, SITV_Integer,
	SIT_CurValue, &amp;fps,
	SIT_MinValue, <val>10</val>,
	SIT_MaxValue, <val>200</val>,
	<val>NULL</val>
);

<com>/* <span class="ok">this is the correct way</span> */</com>
SIT_Wiget num = SIT_CreateWidget(<val>"fps"</val>, SIT_EDITBOX, parent,
	SIT_EditType, SITV_Integer,
	SIT_CurValue, &amp;fps,
	SIT_MinValue, <val>10.</val>,
	SIT_MaxValue, <val>200.</val>,
	<val>NULL</val>
);</pre>
  <p>The difference is subtle, but those extra dots will make the difference between a working program
  and one that crashes. If you use the <tt>SIT_CreateWidgets()</tt> function and specify these parameters
  as text, you won't have to worry about these details.

</ul>

<h4 id="editevents">Events</h4>

<p>The main event reported by text boxes that you might be interested in is <tt><b>SITE_OnChange</b></tt>.
This event will be fired whenever the content of the edit buffer has changed. The <tt>call_data</tt>
for this event will be the UTF-8 string that you can also get by reading the <tt>SIT_Title</tt> property.
By the time the event is fired, the changes will have already been committed, therefore it won't be
possible to cancel them. And, as usual, don't try to modify the content of this buffer, you'll cause
undefined behavior all over the place.

<p>If you want to change the text of the control at this point, you can do safely using the <tt>SIT_Title</tt>
property. Keep in mind, that cursor position will be reset to 0.

<p>You also might want to catch some keystrokes (like cursor keys, function keys, ...) while the focus
is in the editbox. You can register a <tt>SITE_OnRawKey</tt> callback, and process events you might be
interested in. Don't forget to return 1 to signal that you've processed the event and do not want it
to be given to the edit box again. That being said, <b>a better way to catch certain keystrokes</b> is to
register a global <a href="#SIT_AccelTable">accelerator table</a>, either at the dialog or at the application level.



<h4 id="editkbd">Keyboard shortcuts</h4>

<p>Just for reference, here are almost all the keyboard shortcuts, that are built-in this control:
<ul>
  <li><span class="key">&#x25C4;</span>, <span class="key">&#x25B2;</span>, <span class="key">&#x25BA;</span>, <span class="key">&#x25BC;</span>: move cursor around.
  <li><span class="key">Shift + &#x25C4;</span>, <span class="key">Shift + &#x25B2;</span>, <span class="key">Shift + &#x25BA;</span>, <span class="key">Shift + &#x25BC;</span>: move cursor and selection around.
  <li><span class="key">Ctrl + &#x25C4;</span>, <span class="key">Ctrl + &#x25BA;</span>: move cursor to previous/next word.
  <li><span class="key">Shift + Ctrl + &#x25C4;</span>, <span class="key">Shift + Ctrl + &#x25BA;</span>: move cursor and selection to previous/next word.
  <li><span class="key">Ctrl + A</span>: select all.
  <li><span class="key">Ctrl + C</span>: copy selection to clipboard.
  <li><span class="key">Ctrl + V</span>: paste text from clipboard.
  <li><span class="key">Ctrl + X</span>: copy to clipboard and delete text (ie: cut).
  <li><span class="key">Ctrl + Y</span>: redo last undone operation.
  <li><span class="key">Ctrl + Z</span>: undo last operation.
  <li><span class="key">Insert</span>: toggle between insert/replace mode.
  <li><span class="key">Ctrl + Del</span>: delete word following cursor.
  <li><span class="key">Ctrl + Backspace</span>: delete word before cursor.
  <li><span class="key">PageUp</span>, <span class="key">PageDown</span>: move cursor to the previous/next page.
  <li><span class="key">Ctrl + Home</span>: move cursor to the very start of text.
  <li><span class="key">Shift + Ctrl + Home</span>: move cursor and selection to the start of text.
  <li><span class="key">Ctrl + End</span>: move cursor to the very end of text.
  <li><span class="key">Shift + Ctrl + End</span>: move cursor and selection to the end of text.
</ul>

<h3 id="SIT_COMBOBOX"><span>SIT_COMBOBOX</span></h3>

<p>ComboBox is a way to let the user choose one entry among a list of choices:

<div class="image">
  <img src="images/SIT_COMBOBOX.png" alt="Drop down list">
</div>

<p>Here are the styles that were defined for this control:
<pre>
<hdr>combobox</hdr> {
	<com>background</com>:      <atr>white</atr>;
	<com>border</com>:          <atr>0.1em solid #aaa</atr>;
	<com>padding</com>:         <atr>0.3em 0.5em</atr>
}
<hdr>combobox arrow</hdr> {
	<com>background</com>:      <atr>url(mask:arrowdown.png) 50% 50% no-repeat,
	                 linear-gradient(to bottom, #f2f2f2, #ebebeb 50%, #dbdbdb 50%, #cfcfcf)</atr>;
	<com>background-size</com>: <atr>50% 25%, 100% 100%</atr>;
	<com>border</com>:          <atr>0.1em solid #aaa</atr>;
	<com>outline</com>:         <atr>rgba(white, 0.5) 0.1em solid -0.2em</atr>;
	<com>margin</com>:          <atr>0.1em</atr>;
	<com>padding</com>:         <atr>0 0.4em</atr>
}
<hdr>combobox arrow</hdr>:<pse>active</pse> {
	<com>background</com>:      <atr>url(mask:arrowdown.png) 50% 50% no-repeat, #c2e4f6</atr>;
	<com>border</com>:          <atr>0</atr>;
	<com>box-shadow</com>:      <atr>0 2px 5px #2681af inset, 0 0 2px #333 inset</atr>;
	<com>outline</com>:         <atr>0</atr>
}
<hdr>popup</hdr> {
	<com>border</com>:          <atr>0.1em solid #aaa</atr>;
	<com>background</com>:      <atr>white</atr>;
	<com>padding</com>:         <atr>6px</atr>
}
</pre>

<p>The <b>point of interest</b> is the use of the <tt>margin</tt> property. This is actually a hack to
offset the border box inward.

<hr>

<p>ComboBox has <b>two operating modes</b>: one in which the selected entry is editable (this is actually what
got referred as "ComboBox"), and one where it is read only (which is usually referred as drop down list).
The way to create one type or another is through the property <tt>SIT_ReadOnly</tt>.

<p>To manage items within this list, there are two methods available. The first method is to use the
generic tag/value model, through the property <tt>SIT_InitialValues</tt>. The expected argument is a
string, encoding the items as a tab (ASCII code 9) separated list, e.g.:
<tt class="o">"First item<spe>\t</spe>Second item<spe>\t</spe>Third item"</tt>.
This method is well suited when the number of items is fixed and does not vary during the lifetime of
the ComboBox. If it is not the case, you might be interested in the second method.

<p>Since generic interface can sometimes be tedious, a few specialized functions are available:

<ul>
  <li><tt class="dt"><type>int</type> SIT_ComboInsertItem(SIT_Widget, <type>int</type> index, STRPTR item, APTR rowtag);</tt>
  <p>Insert an item at the zero-based index specified (the library will make
  a copy of the string). You can also provide <tt class="o">-1</tt> as the
  index to insert the item at the end of list.
  <tt>rowtag</tt> is an arbitrary pointer you may want to associate with the
  item. Note that this value cannot be set, nor retrieved using the generic
  tag/value interface. The return value will be the index at which the item
  has been inserted, or <tt class="o">-1</tt> in case of error.

  <li><tt class="dt"><type>int</type> SIT_ComboDeleteItem(SIT_Widget, <type>int</type> index);</tt>
  <p>Remove an item from the list. If <tt>index</tt> is negative or out of
  range, it will delete the last item of the list. Return value is the index
  of the item that has been deleted.

  <li id="ComboGetRowTag"><tt class="dt">APTR SIT_ComboGetRowTag(SIT_Widget, <type>int</type> nth, STRPTR * label);</tt>
  <p>Allows you to retrieve the row tag associated with an item. If item
  is negative, it will retrieve the row tag of the currently selected
  item. If <tt>label</tt> is not <tt class="o">NULL</tt>, the text of the
  item will also be stored at the location pointed by <tt>label</tt>. The
  content of this string is read-only, do not modify it.
</ul>

<p>Remember that both methods can be mixed: usually, you initialize the ComboBox through
<tt>SIT_InitialValues</tt>, and then later modify the list through the specialized functions. Also,
setting the property <tt>SIT_InitialValues</tt> will remove all existing items before inserting the
new ones.

<p>You can modify the current selected item using <tt>SIT_SelectedIndex</tt> attribute. By default,
if you add items to a combobox/drop down list, it will select the first entry. To prevent this behavior
(and keep the text entry blank), explicitly set this property to <tt class="o">-1</tt>.

<p>There is one specific events reported by the ComboBox: <tt>SITE_OnChange</tt>. If will be sent
whenever the selected item has changed. The <tt>call_data</tt> can be cast to an integer, to get the
item number



<h3 id="SIT_LISTBOX"><span>SIT_LISTBOX</span></h3>

<p>Listbox are a way to display a list using two display formats: report view or icon view.

<div style="margin-left: 40px">
<div class="image" style="display: inline-block; margin: 5px">
  <img src="images/SIT_LISTBOX_report.png" alt="Listbox with column header">
  <span class="caption">Report view</span>
</div>

<div class="image" style="display: inline-block; margin: 5px">
  <img src="images/SIT_LISTBOX_icon.jpg" alt="Listbox using icon view">
  <span class="caption">Icon view <dim>(images are from wikipedia)</dim></span>
</div>
</div>

<p>Here are the styles used for these controls:
<pre>
<com>/* report view */</com>
<hdr>table</hdr> {
	<com>border</com>:             <atr>1px solid #aaa</atr>;
	<com>background</com>:         <atr>white</atr>
}
<hdr>table td</hdr> {
	<com>padding</com>:            <atr>2px 6px</atr>
}
<hdr>table td</hdr>:<pse>checked</pse> {
	<com>background-color</com>:   <atr>selback</atr>;
	<com>color</com>:              <atr>selfore</atr>
}
<hdr>table th</hdr> {
	<com>border</com>:             <atr>1px solid #aaa</atr>;
	<com>border-right-color</com>: <atr>white</atr>;
	<com>padding</com>:            <atr>4px</atr>;
	<com>background</com>:         <atr>linear-gradient(to bottom, white, white 50%, #f7f8fa 50%, #f1f2f4)</atr>;
}
<hdr>table th dim</hdr> {
	<com>color</com>:              <atr>#888</atr>
}

<com>/* icon view */</com>
<hdr>listbox</hdr> {
	<com>border</com>:             <atr>1px solid #aaa</atr>;
	<com>background</com>:         <atr>white</atr>;
	<com>padding</com>:            <atr>0.3em</atr>
}
<hdr>listbox td label</hdr> {
	<com>padding</com>:            <atr>0.2em</atr>;
	<com>text-align</com>:         <atr>center</atr>
}
<hdr>listbox td</hdr>:<pse>checked</pse> <hdr>label</hdr> {
	<com>background-color</com>:   <atr>selback</atr>;
	<com>color</com>:              <atr>selfore</atr>
}
<hdr>listbox thead</hdr> {
	<com>text-align</com>:         <atr>center</atr>;
	<com>padding-bottom</com>:     <atr>5px</atr>;
	<com>border-bottom</com>:      <atr>1px solid black</atr>;
	<com>font-weight</com>:        <atr>bold</atr>
}
</pre>

<p>The first thing you need to be aware, is that both mode are kind of mutually exclusive: you cannot
switch from one to the other (at least easily), therefore the view mode is (almost) create only.

<h4 id="listreport">Managing columns (report view)</h4>

<p>There are 3 properties to handle this: <tt>SIT_ColumnNames</tt>, <tt>SIT_ColumnWidths</tt> and
<tt>SIT_ColumnAlign</tt>. Only <tt>ColumnNames</tt> is mandatory, it is a tab-delimited list of names, e.g:
<tt class="o">"Name<spe>\t</spe>Address<spe>\t</spe>Server"</tt>. It is this
property that will defined how many columns your list will have. <tt>ColumnAlign</tt> is also a tab
separated list indicating the alignment for the given column, among: <tt>L</tt> for left (default),
<tt>R</tt> for right and <tt>C</tt> for center, e.g: <tt class="o">"L<spe>\t</spe>R<spe>\t</spe>C"</tt>
(<span class="n">Note</span>: <b>case is sensitive</b>).
If you give less items than columns, remaining columns will have a left alignment, and if you give
more, remaining items will be ignored.

<p><tt>ColumnWidths</tt> is optional and can be used to <b>constraint the way space is distributed</b> across
columns, and keep it that way even when the listbox is resized. It is also a tab-separated list of
numbers and/or star (<tt>*</tt>). The star can also optionally be prefixed by a number. The width of
the column will be proportional to width of the listbox and the "weight" of the column. The weight is
the number before the star, or if there is no number, 1 will be assumed.

<p>For example a <tt>ColumnWidths</tt> set to <tt class="o">"*<spe>\t</spe>*<spe>\t</spe>*"</tt>
will set the width of all columns to be of equal width. If you ever make your listbox resizeable, you
will see the width of your columns expand or shrink evenly as you change the width of the list. Now
if you specified a value of <tt class="o">"2*<spe>\t</spe>*<spe>\t</spe>*"</tt>
for this property, the first column will have twice the space of the two remaining columns.

<p>If you do not set this property, the initial width of your columns, will be the minimal width to
display the label header and all the list items. You can use the dedicated function <tt>SIT_ListSetColumn()</tt>
to adjust that afterward.

<p>For example, the report table was created using the following code:
<pre>SIT_Widget list = SIT_CreateWidget(<val>"list"</val>, SIT_LISTBOX, diag,
	SIT_MinHeight,        SITV_Em(<val>2</val>),
	SIT_Height,           SITV_Em(<val>10</val>),
	SIT_ColumnNames,      <val>"Name<spe>\t</spe>Diameter &lt;dim&gt;(km)&lt;/dim&gt;<spe>\t</spe>Mass &lt;dim&gt;(earth)&lt;/dim&gt;<spe>\t</spe>Distance &lt;dim&gt;(AU)&lt;/dim&gt;"</val>,
	SIT_ColumnAlign,      <val>"L<spe>\t</spe>R<spe>\t</spe>R"</val>,
	SIT_LeftAttachment,   SITV_AttachForm,
	SIT_RightAttachment,  SITV_AttachForm,
	SIT_BottomAttachment, SITV_AttachForm,
	SIT_Top,              SITV_AttachWidget, label, SITV_Em(<val>0.2</val>),
	<val>NULL</val>
);</pre>

<p>You can still <b>change various parameters of any columns at runtime</b>, using this
specialized function:

<pre><type>Bool</type> SIT_ListSetColumn(SIT_Widget, <type>int</type> col, <type>int</type> width, <type>int</type> align, <type>STRPTR</type> label);</pre>

<p>Where each parameters have the following meaning:

<ul>
  <li><tt>col</tt>: the 0-based column number you want to alter its properties.</li>
  <li><tt>width</tt>: the new width of the column. You can also use the special
  value <tt>DontChange</tt> to let the width of the column as it is currently.
  Alternatively, you can also use <tt>AutoArrange</tt> to compute the optimal
  width to display both header and list items. Any numeric value, will set the
  width to the specified number of pixels.
  <li><tt>align</tt>: the alignment for this column: <tt class="o">'L'</tt> for
  left, <tt class="o">'R'</tt> for right, <tt class="o">'C'</tt> for center and
  <tt>DontChange</tt> to leave the alignment as it is.
  <li><tt>label</tt>: the new label for the column or <tt>DontChangePtr</tt> to
  leave it as it is.
</ul>

<p>You can also use the dedicated properties, but attributes for all columns
will have to be specified in one <tt>SIT_SetValues()</tt> call.

<h4 id="listitems">Managing items</h4>

<p>Items are managed through dedicated functions. First, there is one function to
<b>insert items in the list</b>:

<pre><type>int</type> SIT_ListInsertItem(SIT_Widget w, <type>int</type> row, <type>APTR</type> rowTag, ...);</pre>

<p>Each parameter have the following meaning:

<ul>
  <li><tt>row</tt>: 0-based index where you want to insert your row. Use a
  negative number to insert at the end of the list.

  <li><tt>rowTag</tt>: an arbitrary pointer you may want to associate with the item. You can also use
  the special value <tt>SITV_CategoryRow</tt> to indicate that this is a group separator (see below).

  <li><tt>...</tt>: NULL-terminated list of strings, one for each column. This
  function will only read your arguments up to the number of columns there is in
  the listbox, so as a permitted shortcut, you can omit the NULL if you gave the
  same number of strings than there are columns.
  
  <p><span class="n">Note</span>: the text will be interpreted as an HTML fragment, similar to a
  <a href="#SIT_LABEL">label</a>. If that's not enough, you can embed more complex elements in each
  cell using another API (see next section).
</ul>

<p><b>The return value</b> will be the row index at which the item was inserted, so that it can be
manipulated using the various other functions.

<p>To <b>delete one row</b>, you can use the following function:

<pre><type>void</type> SIT_ListDeleteRow(SIT_Widget w, <type>int</type> row);</pre>

<p><tt>row</tt> is the 0-based index of the row you want to delete. You can use the special value
<tt class="o">-1</tt> to delete the last row of the list. You can also use <tt>DeleteAllRows</tt>,
<b>to delete all the rows at once</b>.

<p>To <b>modify a cell</b> of the listbox, there is the following function:

<pre><type>void</type> SIT_ListSetCell(SIT_Widget w, <type>int</type> row, <type>int</type> col, <type>APTR</type> rowTag, <type>int</type> align, <type>STRPTR</type> text);</pre>

<p>The following values can be assigned to each parameters:

<ul>
  <li><tt>row</tt>: the 0-based index of the row you want to modify. Use a
  negative value to modify the last item.

  <li><tt>col</tt>: 0-based index of the cell's column you want to set the
  text. This parameter is only meaningful if you are going to change the
  text of the cell. Otherwise, the value given for this parameter will be
  ignored.

  <li><tt>rowTag</tt>: the new tag you want to set for the row or <tt>DontChangePtr</tt>
  for leaving this value as it is. As with the <tt>image</tt> parameter, the
  <tt>rowTag</tt> will always be set on the first column, no matter what you
  gave for the column number.

  <li><tt>align</tt>: use the character <tt class="o">'L'</tt>, <tt class="o">'C'</tt> or
  <tt class="o">'R'</tt> to set the alignment on this cell. Or simply <tt>DontChange</tt>, if you
  don't want to change anything.

  <li><tt>text</tt>: label to set the targeted cell. You can use the  special value <tt>DontChangePtr</tt>
  to not modify anything.

</ul>

<h4 id="listembed">Embedding controls</h4>

<p>By default, all the items of a listbox cell are supposed to be <a href="#SIT_LABEL">labels</a>. If
that's not enough (especially in icon view, this is quite restrictive), you can build more complex
items, using other controls as basic building blocks.

<p><b>First</b>, you'll have to insert an item in list using the <tt>SIT_ListInsertItem()</tt> function,
but as for the text of the cell, you need to use the special value <tt>SITV_TDSubChild</tt>. That way,
the libary will prepare the cell to receive additional controls.

<p><b>Second</b>, each cell of a table acts as its own container. You can ask for a pointer on this
container using the following function:

<pre>SIT_Widget SIT_ListInsertControlIntoCell(SIT_Widget w, <type>int</type> row, <type>int</type> col);</pre>

<p><tt>row</tt> and <tt>col</tt> are the 0-based index of the cell you want to insert custom controls
in it. For icon view, <tt>col</tt> will be ignored, so you can pass any value.

<p>If the return value is not NULL, you can then start inserting control uisng the standard functions
like <a href="#SIT_CreateWidget"><tt>SIT_CreateWidget()</tt></a> or <a href="#SIT_CreateWidgets"><tt>SIT_CreateWidgets()</tt></a>.

<p><b>Third, you have to notify the listbox</b> once you are done inserting controls in a cell, using the
following function:
<pre><type>void</type> SIT_ListFinishInsertControl(SIT_Widget list);</pre>

<p>Where <tt>list</tt> is a <b>pointer to a SIT_LISTBOX widget</b> (not the pointer returned by
<tt>SIT_ListInsertControlIntoCell()</tt>).

<p>For example, the icon view in the example above, was created using a code like this:

<pre><type>static STRPTR</type> planets[] = {<val>"Mercury"</val>, <val>"Venus"</val>, <val>"Earth"</val>, <val>"Moon"</val>, <val>"Mars"</val>, <val>"Jupiter"</val>, <val>"Saturn"</val>, <val>"Uranus"</val>, <val>"Neptune"</val>};
<type>int</type> i;
<kwd>for</kwd> (i = <val>0</val>; i &lt; DIM(planets); i ++)
{
	SIT_Widget td;
	<type>char</type>       iconPath[<val>64</val>];
	td = SIT_ListInsertControlIntoCell(list, SIT_ListInsertItem(list, <val>-1</val>, (<type>APTR</type>) <val>1</val>, SITV_TDSubChild), <val>0</val>);
	sprintf(iconPath, <val>"planets/%s.png"</val>, planets[i]);
	SIT_CreateWidgets(td,
		<val>"&lt;label name=icon imagePath="</val>, iconPath, <val>"left="</val>, SITV_AttachPosition, SITV_AttachPos(<val>50</val>), SITV_OffsetCenter, <val>"&gt;"</val>
		<val>"&lt;label name=wname title="</val>, planets[i], <val>"top=WIDGET,icon left=FORM right=FORM&gt;"</val>
	);
	SIT_ListFinishInsertControl(list);
}</pre>

<p>Widget's names don't have to be unique among all cells. Geometry of controls will be computed so
that it will be as compact as the constraint will allow. You can still force the width of the item,
but it is strongly discouraged, especially in icon view, where items can flow from row to row depending
on how much space there is.

<h4 id="listicon">Icon view</h4>

<p>There are a few aspects to keep in mind when using the icon view. First of all, <b>all items in icon
view will share the same width</b>, because the number of items per row will depend on how much horizontal
space there is available. Adding or deleting items can change that maximum.

<p>Height can differ from item to item, but the <b>height of a row</b> will always be the maximum height of
all the items in the row.

<p>Therefore, there are two boxes per cell: <b>item box</b> and <b>cell box</b>. Item box is necessarily
smaller or equal to the cell box (which is not necessarily true in list view). You might be interested
to control how an item is positioned within the cell box. By default items will be placed on the top
left corner, but you can select another one, using one of these methods:

<ul>
  <li>The default horizontal alignment can still be set using the <tt>SIT_ColumnAlign</tt> property.
  Obviously, only one column needs to specified.

  <li>For a finer control, you can use the function <tt>SIT_ListSetCell()</tt>. The align parameter
  can also be used to specify both the horizontal and vertical centering in icon view. The first 8bit
  of this parameter will specify the horizontal alignment, the next 8bit can be filled with the vertical
  alignment using the character <tt class="o">T</tt>, <tt class="o">M</tt>, <tt class="o">B</tt>. For
  example:
  <pre>SIT_ListSetCell(list, row, col, DontChangePtr, (<val>'B'</val> &lt;&lt; <val>8</val>) | <val>'R'</val>, DontchangePtr);</pre>
  <p>This will set the alignment for this cell to bottom right. <span class="n">Note</span>: the order
  for the alignment letters does not matter actually. You could have used
  <tt>(<val>'R'</val> &lt;&lt; <val>8</val>) | <val>'B'</val></tt>, and it would have worked too.

  <p>Technically, you could use multi-character constant for this parameter, but their use has been
  discouraged by most compilers for whatever reasons (ie: alignment could be simplified as <tt class="o">'BR'</tt>,
  but you'll probably get a warning from the compiler).
</ul>

<h4 id="listcat">Category separator</h4>

<p>This is a feature that only works with listbox in icon view. It allows you to add a visual separator
between group of icons:

<div class="image" style="display: inline-block">
  <img src="images/SIT_LISTBOX_category.jpg" alt="Listbox with categories">
  <span class="caption">Category separator</span>
</div>

<p>You can create a category separator using the default function for inserting items:

<pre><type>int</type> SIT_ListInsertItem(SIT_Widget w, <type>int</type> row, <type>APTR</type> rowTag, ...);</pre>

<p>You just have to set the <tt>rowTag</tt> parameter to <tt>SITV_CategoryRow</tt>. Since icon view
can only have one column, the vararg part should only contain one string (which will be interpreted
as an HTML label).

<p>The <b>important aspect to keep in mind</b> about category separators is that they behave almost like regular
items. The way you "add" items in one particular group, is simply by inserting the items in the "correct"
row.

<p>A bit of <b>automatic house-keeping</b> will be done for you with these items:
<ul>
  <li>Unless there are more than 2, category separators will be initially hidden.
  <li>If a category has no items, it will stay hidden until some are added.
  <li>Deleting an item, will hide (but not delete) the category if it becomes empty.
</ul>

<p>The drawback of using category separators is that you need to maintain extra house keeping on your
side, to know where they are. You can still check if an item at a given row is a category separator,
by retrieving the <tt>SIT_RowTag(row)</tt> property.

<p>For the <b>purpose of CSS styling</b>, category separators will be created with the tag name
<tt>&lt;thead&gt;</tt>.

<h4 id="listprop">Listbox properties</h4>

<p>A few more specialized properties exist to help you manage listbox:

<ul>
  <li><tt class="dt">SIT_ListBoxFlags</tt> (<tt class="t">int</tt>)
  <p>A bitfield that can be initialized with the following flags:
  <ul>
	<li><tt class="dt">SITV_SelectMultiple</tt> : multiple items can be selected by the user. Use
	Ctrl + click to select more of Shift + click to select a group.
	<li><tt class="dt">SITV_SelectAlways</tt> : always try to keep at least one item selected.
	<li><tt class="dt">SITV_SelectNone</tt> : display-only list box, no interaction possible.
	<li><tt class="dt">SITV_NoHeaders</tt> : only meaningful when creating a list box in report view,
	it will hide the column headers of the list box. Note: you will still have to initialize the column
	through the <tt>SIT_ColumnNames</tt> properties, but the text width will not influence the width
	of the columns.
	<li><tt class="dt">SITV_DoSort</tt> : only works in report view: allow user to click on headers to
	change the sorting of the list box. <span class="n">Note</span>: once a sort column has been set,
	inserting new items will ignore the row number.
  </ul>
  <p>By default, this property is set to 0.

  <li><tt class="dt">SIT_Title</tt> (<tt class="t">STRPTR</tt>)
  <p>You can use this property to display a <b>placeholder when there are no items</b> currently in the list.
  The message will be hidden as soon as there is at least one item to display.

  <li><tt class="dt">SIT_SortColumn</tt> (<tt class="t">int</tt>)
  <p>Allows you to programmatically set the column used for sorting items. If the integer is positive
  or 0, the specified column will be used to sort items in ascending order. If the integer is negative,
  the <tt>-n-2</tt> will be sorted in descending order (i.e: to sort first column in descending order,
  specify <tt>-2</tt>).
  
  <p>Alternatively, you can also use the macro <tt>SITV_SortColumn(column, direction)</tt> to set this
  property.

  <li><tt class="dt">SIT_SelectedIndex</tt> (<tt class="t">int</tt>)
  <p>Set or get currently selected row. -1 will be returned if none are selected. If you try to set
  an index out of range, it will be clamped between the minimum and maximum row number. In case of
  multi-selection is allowed, this will give you the index of the last item selected.

  <li><tt class="dt">SIT_RowSel(row)</tt> (<tt class="t">int</tt>)
  <p>Set or get selection state of a row. If the list is single-selection only, it will automatically
  deselect the previously selected item. This tag is actually a macro, where you have to give the
  0-based row number as argument, like this:
  <pre>SIT_SetValues(list, SIT_RowSel(<val>0</val>), True, <val>NULL</val>);</pre>

  <li><tt class="dt">SIT_RowTag(row)</tt> (<tt class="t">APTR</tt>)
  <p>This tag allows you to set or get an arbitrary pointer to the given row. It works like the previous
  one: you have to specify the row you want to modify as argument to the tag name.

  <li><tt class="dt">SIT_MakeVisible</tt> (<tt class="t">int</tt>) <span class="ro">write-only</span>
  <p>Will bring into view the n<sup>th</sup> item by scrolling the content of list by the minimum
  amount required. Item number is 0-based and will be clamped to the min/max number of items if given
  an index outside of the permitted range.

  <li><tt class="dt">SIT_ItemCount</tt> (<tt class="t">int</tt>) <span class="ro">read-only</span>
  <p>Can be used to retrieve the number of items in the list. For report view, this will contain the
  number of rows. For icon view, it will be all the items that has been added (<b>not including</b>
  category separators).

  <li><tt class="dt">SIT_CellPaint</tt> (<tt>SIT_CallProc</tt>)
  <p>A sort of hack to <b>quickly change the foreground/background of any cell</b> in the listbox. This trick
  is actually quite cheap though: it requires no memory allocation or expensive parsing. The <tt>call_data</tt>
  parameter will be a pointer to the following structure:
  <pre><type>struct</type> SIT_OnCellPaint_t
{
	<type>uint8_t</type> fgColor[<val>4</val>];
	<type>uint8_t</type> bgColor[<val>4</val>];
	<type>int</type>     rowColumn; <com>/* 0 based */</com>
};
</pre>
  <p><tt>rowColumn</tt> encodes the column and row of the cell in one field: first 8 bits encode the
  column, next 24bits contain the row number (all 0-based).

  <p>If you want to change the foreground color or background color, simply give a RGBA value in the
  corresponding field. A color will be considered non default if the alpha value is greater than 0.

</ul> 

<h4 id="listevents">Events</h4>

<p>Here is the list of specific events sent by listbox:</p>

<ul>
  <li><tt class="dt">SITE_OnActivate</tt>
  <p>This event is triggered whenever the user <b>double-click on an item or use the <span class="key">Enter</span>
  key</b>. The <tt>call_data</tt> parameter will be the <tt>rowTag</tt> given when the item was inserted. If you
  want to know the row being selected, you can read property <tt>SIT_SelectedIndex</tt> (if multi-selection
  is enabled, this will only return the last user-selected row).

  <li><tt class="dt">SITE_OnChange</tt>
  <p>This event is sent whenever the <b>selection</b> of the listbox <strong>has changed</strong>. The
  <tt>call_data</tt> parameter is the same as <tt>SITE_OnActivate</tt>.

  <li><tt class="dt">SITE_OnSortColumn</tt>
  <p>If you enabled the flag <tt>SIT_DoSort</tt> for the property <tt>SIT_ListBoxFlags</tt>, you can
  register a callback for this event to be notified whenever the sort column is about to change. If
  you return <tt class="o">1</tt>, the list will be reordered using this column as key. If you return
  <tt class="o">0</tt>, the sort will be cancelled and the current key column will be kept as is.

  <p>The <tt>call_data</tt> parameter will be the column that <b>will be used</b> as key for sorting
  (it is not yet set at this point).

  <li><tt class="dt">SITE_OnSortItem</tt>
  <p>This one is triggered whenever two items have to be compared. The <tt>call_data</tt>
  parameter is a pointer to a <tt>SIT_OnSort</tt> structure, which is declared like this:
  <pre><type>typedef struct</type>
{
	<type>APTR</type> item1;
	<type>APTR</type> item2;
	<type>int</type>  column;
} SIT_OnSort;</pre>
  <p>Where each field will be initialized the following way:
  <ul>
	<li><tt>item1</tt>, <tt>item2</tt>: the <tt>rowTag</tt> that was given when
	items were inserted.</li>
	<li><tt>column</tt>: the 0-based index of the column to sort.
  </ul>
  <p>The return code of the callback has to be from the following set of enums:
  <ul>
	<li><tt>SIT_SortBefore</tt> (<tt class="o">-1</tt>): <tt>item1</tt> should be before <tt>item2</tt>.
	<li><tt>SIT_SortEqual</tt> (<tt class="o">0</tt>): <tt>item1</tt> is equal to <tt>item2</tt>.
	<li><tt>SIT_SortAfter</tt> (<tt class="o">1</tt>): <tt>item1</tt> should be after <tt>item2</tt>.
	<li><tt>SIT_SortAlpha</tt> (<tt class="o">2</tt>): ask the library to perform a case-insensitive
	lexicographic ordering based on the current text there is in the cells of each item.
	<li><tt>SIT_SortBinary</tt> (<tt class="o">3</tt>): like <tt>SIT_SortAlpha</tt>, but do not
	take case into consideration.
	<li><tt>SIT_SortNumeric</tt> (<tt class="o">4</tt>): consider the text of each item to be
	<b>decimal integers</b>, and use them to sort the rows (if you want to sort fractional numbers,
	you'll have to do it manually).
	<li><tt>SIT_SortAlphaNum</tt> (<tt class="o">5</tt>): mix between alpha and numeric, this sorting
	method is best intended for filenames, where files like these (in lexicographic order):
	<pre>File1.exe     File10.exe      File2.exe     File40.exe    File5.exe</pre>
	Will be sorted like this:
	<pre>File1.exe     File2.exe       File5.exe     File10.exe    File40.exe</pre>
  </ul>
  <p><span class="n">Note</span>: you do not have to handle the ascending/descending order: this will
  be done automatically for you.

  <p>The only caveat when you handle the sorting yourself is to be careful to
  return a value in the range [-1, 1]. That means you cannot use the return
  value of function like <tt>strcmp()</tt>, or return the result of a subtraction
  to compare two integers. You'll have to split the comparison to return a specific
  code for each case, using something like this:
  <pre><type>static int</type> OnSortFiles(SIT_Widget w, APTR cd, APTR ud)
{
	SIT_OnSort * sort = cd;
	<type>int</type>          diff = ((FileInfo)sort-&gt;item1)-&gt;ts - ((FileInfo)sort-&gt;item2)-&gt;ts;
	<kwd>if</kwd> (diff &lt; <val>0</val>) <kwd>return</kwd> -<val>1</val>;
	<kwd>if</kwd> (diff &gt; <val>0</val>) <kwd>return</kwd>  <val>1</val>;
	<kwd>return</kwd> <val>0</val>;
}</pre>
  <p><b>The default behavior</b> for sorting items is <tt>SIT_SortAlpha</tt>.
</ul>

<h4 id="listkbd"><span>Keyboard shortcuts</span></h4>

<p>Just for reference, here are the keyboard shortcuts, that are built-in this control:

<ul>
  <li><span class="key">&#x25C4;</span>, <span class="key">&#x25B2;</span>, <span class="key">&#x25BA;</span>, <span class="key">&#x25BC;</span>: move selected item. Left and right keys only work in icon view.
  <li><span class="key">Shift + &#x25C4;</span>, <span class="key">Shift + &#x25B2;</span>, <span class="key">Shift + &#x25BA;</span>, <span class="key">Shift + &#x25BC;</span>:
  extend the selection of items, if the list has been configured to allow multiple items to be selected.
  <li><span class="key">PgUp</span>, <span class="key">PgDown</span>: move to the selected item one page up or down.
  <li><span class="key">Home</span>, <span class="key">End</span>: move to the selected item to the first/last in the list.
  <li><em>text</em>: any text typed will be used to perform a look ahead search among all items, starting from current
  item selected up to the end. If nothing is found, the search will restart at the beginning up to the cursor position.
  <p>The look ahead text will be reset whenever the selected item has changed or when the list just received the keyboard
  focus.

</ul>



<h3 id="SIT_CANVAS"><span>SIT_CANVAS</span></h3>

<p>Canvas is a generic control, where you have to handle all by yourself, like keyboard, mouse and
repainting. Even though it sounds easy, you'll quickly find out that it involves a lot of work to
handle all use cases.

<h4>Handling mouse events</h4>

<p>Mouse events include mouse click/release (which include mouse wheel) and mouse movements. Mouse clicks
are reported using <tt>SITE_OnClick</tt> notification, which include any button pressed or released,
mouse movement are notified by <tt>SITE_OnMouseMove</tt>. It not that unusual to use the same callback
for both events, especially since they use the same datatype for the <tt>call_data</tt> parameter: a
pointer to a <tt>SIT_OnMouse_t</tt> structure. It is declared this way:

<pre><type>struct</type> SIT_OnMouse_t     <com>/* note: sizeof (struct SIT_OnMouse_t) must be 8 */</com>
{
	<type>enum</type>                 <com>/* to get debug symbols, while limiting the size of this field to 8bit */</com>
	{
		SITOM_ButtonLeft,
		SITOM_ButtonMiddle,
		SITOM_ButtonRight,
		SITOM_ButtonWheelUp,
		SITOM_ButtonWheelDown
	}	button:<val>8</val>;
	<type>enum</type>
	{
		SITOM_ButtonPressed,
		SITOM_ButtonReleased,
		SITOM_Move,
		SITOM_CaptureMove
	}	state:<val>8</val>;
	<type>unsigned</type> flags:<val>16</val>;  <com>/* SITK_Flag* : qualifier keys held before mouse event */</com>
	<type>int16_t</type>  x, y;      <com>/* relative to top left corner of control */</com>
};</pre>

<p><tt>button</tt>, <tt>x</tt> and <tt>y</tt> are pretty straightforward, <tt>flags</tt> is a bitfield
to know which qualifiers were held while generating the mouse event, and <tt>state</tt> can take the
following values:

<ul>
  <li><tt>SITOM_ButtonPressed</tt>: the button is being pressed.
  <li><tt>SITOM_ButtonReleased</tt>: the button is released (never reported for
  mouse wheel).
  <li><tt>SITOM_Move</tt>, <tt>SITOM_CaptureMove</tt>: two similar events. They
  are fired whenever the mouse has moved. <tt>SITOM_Move</tt> is only reported
  when the mouse is over the control. To get notification outside, you need to
  initiate a captured move.
</ul>

<p>To initiate a captured move in order to get mouse move notifications outside widget bounding box,
you need to return an integer greater than 1 from your callback, and only in response to mouse button
press (return code will be ignored for any other type).

<p>If the user presses a mouse button within the widget and you <b>absolutely want the release notification</b>,
you need to start a captured move, even if you don't care about mouse move events. If you don't, whenever
the user initiates a click, there will be no guarantee than the release notification will happen over
your control.

<h4>Handling keyboard</h4>

<p>Keyboard events are reported through <tt>SITE_OnVanillaKey</tt> and <tt>SITE_OnRawKey</tt> notifications.
<tt>call_data</tt> will point to a <tt>SIT_OnKey</tt> structure. Its definition is:

<pre><type>typedef struct</type>
{
	<type>int</type>  keycode;  <com>/* Unicode code point [1 - 0x10FFFF] */</com>
	<type>int</type>  flags;    <com>/* SITK_Flag* */</com>
	<type>char</type> utf8[<val>6</val>];
}   SIT_OnKey;</pre>

<p><tt>utf8</tt> field will be valid only for <tt>SITE_OnVanillaKey</tt> event, it is a null-terminated
string representing the character being produced by the combination of key pressed. <tt>flags</tt> are
the qualifier (<tt>SITK_FlagShift</tt>, <tt>SITK_FlagCtrl</tt>, ...) that have been held while generating
the event. <tt>keycode</tt> is either the unicode code point for a vanilla key or one of the <tt>SITK_*</tt>
enumeration for a raw key report (because obviously there is no unicode code point for such keys).

<p>Both events are subject to the auto-repeat feature, i.e: after holding a key for a while, you'll
get repeated events at interval (if enabled by the windowing framework).

<p>If you <tt class="k">return</tt> <tt class="o">1</tt> in any of your keyboard callback, the event
will stop being processed for anything else, like cursor or tab keys for control navigation,
<span class="shortcut">Esc</span> or <span class="shortcut">Return</span> for activating default
push buttons. Take note that this does not include menu accelerators that are processed way
before the event is being dispatched.


<h4>Rendering custom elements</h4>

<p>If you want to leverage some of the rendering capabilities of SITGL, when it comes to CSS styling,
you can create hidden elements (<tt>SIT_Visible</tt> set to <tt class="o">False</tt>), then set
their size manually and finally render them using the <tt>SIT_RenderNode(SIT_Widget);</tt>. This 
function will ignore the <tt>SIT_Visible</tt> state and so will the CSS styling. For example, to draw
a grid like this:

<div class="image">
  <img src="images/SIT_CANVAS_grid.png">
</div>

<p>You can allocate one cell and set its border and background, then repeats as many calls to
<tt>SIT_RenderNode()</tt> to draw them in a grid-like pattern (you'll have to set the <tt>SIT_X</tt>,
<tt>SIT_Y</tt> attribute before calling the function).

<p>The number of geometric shapes to render will be exactly the same with this method as it is by allocating
as many elements as there are cells.

<p>Check out the <a href="#annexC">Annex C: Advanced rendering API</a>, for more information on how to
use this.



<h3 id="SIT_SCROLLBAR"><span>SIT_SCROLLBAR</span></h3>

<p>Scroll bars are typically required when you want to display a document that could not fit in a given
area. You can then display horizontal and/or vertical scroll bars along the view to allow the user to
jump to other parts of the document.

<div class="image">
  <img src="images/SIT_SCROLLBAR.png" alt="Scroll bar">
</div>

<p>Here are the CSS styles used for the control in the screenshot above:

<pre>
<hdr>hscroll, vscroll</hdr> {
	<com>background-color</com>: <atr>#efefef</atr>
}
<hdr>vscroll thumb</hdr> {
	<com>background</com>:       <atr>url(gripV.png) 50% 50% no-repeat,
	                  linear-gradient(to right, #f2f2f2, #ebebeb 50%, #dbdbdb 50%, #cfcfcf)</atr>;
	<com>outline</com>:          <atr>1px #9b9b9b solid -1px</atr>;
	<com>border-radius</com>:    <atr>2px</atr>
}
<hdr>hscroll thumb</hdr> {
	<com>background</com>:       <atr>url(grip.png) 50% 50% no-repeat,
	                  linear-gradient(to bottom, #f2f2f2, #ebebeb 50%, #dbdbdb 50%, #cfcfcf)</atr>;
	<com>outline</com>:          <atr>1px #9b9b9b solid -1px</atr>;
	<com>border-radius</com>:    <atr>2px</atr>
}
<hdr>arrow.left</hdr>:<pse>active</pse>,
<hdr>arrow.right</hdr>:<pse>active</pse>,
<hdr>arrow.down</hdr>:<pse>active</pse>,
<hdr>arrow.up</hdr>:<pse>active</pse> {
	<com>color</com>:            <atr>#ccc</atr>;
	<com>background-color</com>: <atr>#444</atr>
}
<hdr>arrow</hdr> {
	<com>background</com>:       <atr>#efefef url("mask:arrowup.png") no-repeat 50% 50%</atr>;
	<com>background-size</com>:  <atr>50% 50%</atr>;
	<com>color</com>:            <atr>#666</atr>
}
<hdr>arrow.down</hdr> {
	<com>-bg-transform</com>:    <atr>rotate(180deg)</atr>
}
<hdr>arrow.left</hdr> {
	<com>-bg-transform</com>:    <atr>rotate(90deg)</atr>
}
<hdr>arrow.right</hdr> {
	<com>-bg-transform</com>:    <atr>rotate(-90deg)</atr>
}
</pre>

<p>The following properties control the behavior of the scroll bar:
<ul>
  <li><tt class="dt">SIT_HorizScroll</tt> (<tt class="t">Bool</tt>) <span class="ro">create-only</span>
  <p>Scroll bar can be horizontal or vertical. By default, they are vertical, unless
  you set the property <tt>SIT_HorizScroll</tt> to <tt class="o">True</tt>.

  <li><tt class="dt">SIT_ArrowType</tt>  (<tt class="t">enum</tt>) <span class="ro">create-only</span>
  <p>Let you choose where arrow buttons will appear around the scroll bar, including not appearing at
  all. It is the same values and semantics than can be set for the property <a href="#SIT_DefSBArrows"><tt>SIT_DefSBArrows</tt></a> on
  the <tt>SIT_APP</tt> widget. If this property is not set, the one defined at the <tt>SIT_APP</tt>
  level will be used instead. Default value for both properties is <tt>SITV_NoArrows</tt>.

  <li><tt class="dt">SIT_MinValue</tt>, <tt class="dt">SIT_MaxValue</tt> (<tt class="t">int</tt>)
  <p>Default values for these properties are 0 and 100 respectively. This is the range the progress bar
  will report (minus <tt>SIT_PageSize</tt>). Usually, you leave the minimal value alone and set the
  maximum to the total length of your document.

  <li><tt class="dt">SIT_PageSize</tt> (<tt class="t">int</tt>)
  <p>This is the size of the visible part of your document. It will define the size of the scroll bar's
  thumb. Note that values reported by the scroll bar, will then be: [<tt>SIT_MinValue</tt> &ndash;
  (<tt>SIT_MaxValue</tt> - <tt>SIT_PageSize</tt> + 1)].

  <li><tt class="dt">SIT_LineHeight</tt> (<tt class="t">int</tt>)
  <p>The amount the thumb will move when clicking on an arrow button. Default is 1.

  <li><tt class="dt">SIT_ScrollPos</tt> (<tt class="t">int</tt>)
  <p>The position of the thumb.

  <li><tt class="dt">SIT_WheelMult</tt> (<tt class="t">int</tt>)
  <p>How many lines (<tt>SIT_LineHeight</tt>) the scroll position will change when using the mouse wheel.
  Default value is 3, meaning 3 times the value given for <tt>SIT_LineHeight</tt>.

</ul>

<p>The event <tt>SITE_OnScroll</tt> will be fired whenever the position of the thumb has changed. The
<tt>call_data</tt> can be cast to an <tt class="t">long</tt> integer to get thumb's position.




<h3 id="SIT_SLIDER"><span>SIT_SLIDER</span></h3>

<p>Sliders, like scrollbar, allow the user to choose an integer among a certain
range. But unless scrollbars, which are intended to display the relative size
of a view within a larger part, the purpose of a slider is to point to a
particular integer.

<div class="image">
  <img src="images/SIT_SLIDER.png" alt="Slider">
</div>

<p>Here are the CSS styles used for this control:
<pre>
<hdr>slider</hdr> {
	<com>box-shadow</com>:    <atr>0.1em 0.1em 0.4em #111 inset</atr>;
}
<hdr>slider thumb</hdr> {
	<com>border-radius</com>: <atr>2px</atr>;
	<com>background</com>:    <atr>linear-gradient(to bottom, #f2f2f2, #ebebeb 50%, #dbdbdb 50%, #cfcfcf)</atr>;
	<com>outline</com>:       <atr>1px #9b9b9b solid -1px</atr>;
}
<hdr>gauge</hdr> {
	<com>background</com>:    <atr>rgba(selback, 0.5)</atr>;
}
<hdr>slider</hdr>:<pse>kbdfocus</pse> {
	<com>outline</com>:       <atr>2px solid rgba(selback, 0.6)</atr>;
}
</pre>

<p>The slider shares most of its properties with the scroll bar:
<ul>
  <li><tt class="dt">SIT_MinValue</tt>, <tt class="dt">SIT_MaxValue</tt> (<tt class="t">int</tt>)
  <p>Set the range of values that will be reported. Default values are 0 and 100.

  <li><tt class="dt">SIT_PageSize</tt> (<tt class="t">int</tt>)
  <p>The amount the slider's thumb will move when clicking inside the slider's gauge.
  But unlike the scrollbar, this will not modify the size of the thumb, nor reduce the range of values
  being reported.

  <li><tt class="dt">SIT_SliderPos</tt> (<tt class="t">int</tt>)
  <p>The position of the thumb (it is actually an alias of the property <tt>SIT_ScrollPos</tt>).
  
  <li><tt class="dt">SIT_BuddyEdit</tt> (<tt>SIT_Widget</tt>)
  <p>Pointer to an edit box or label whose content will indicate the current
  position of the slider. Changing the value of the edit box will also update the slider position.

  <li><tt class="dt">SIT_ThumbThick</tt> (<tt class="t">int</tt>)
  <p>Will set the width of the thumb. Can be specified in pixel of <tt>Em</tt> unit. Default value is
  <tt>SITV_Em(0.5)</tt>.

  <li><tt class="dt">SIT_ThumbHeight</tt> (<tt class="t">int</tt>)
  <p>Set the height of the thumb. Default value is <tt>SITV_Em(1)</tt>.

  <li><tt class="dt">SIT_GaugePadding</tt> (<tt class="t">int</tt>)
  <p>How much padding the gauge will have on top and bottom. Half the value specified will be given
  to the top and bottom. Default value is <tt>SITV_Em(0.5)</tt>.

</ul>

<p>Sliders, like scrollbars, report any change in its value through the <tt>SITE_OnScroll</tt> event.
And like scrollbars, <tt>call_data</tt> can be cast to an integer to get the current thumb position.



<h3 id="SIT_PROGRESS"><span>SIT_PROGRESS</span></h3>

<p>Progress are a way to let the user know about the advancement of a lengthy operation:

<div class="image" style="display: inline-block; margin-left: 40px">
  <img src="images/SIT_PROGRESS.png" alt="Plain progress bar">
  <span class="caption">Progress bar with slider</span>
</div>

<p>Here are the CSS styles used to produce the control (progress bar only):
<pre>
<hdr>progress</hdr> {
	<com>background</com>:     <atr>linear-gradient(to bottom, #f7f7f7, #d9d9d9 50%, #cbcbcb 50%, #d3d3d3)</atr>;
	<com>vertical-align</com>: <atr>middle</atr>;
	<com>text-align</com>:     <atr>center</atr>;
	<com>border</com>:         <atr>1px solid #bbb</atr>;
	<com>color</com>:          <atr>#777</atr>;
}
<hdr>progress bar</hdr> {
	<com>background</com>:     <atr>radial-gradient(ellipse, transparent, rgba(#000,0.2)),
	                linear-gradient(to bottom, #cdffcd, #9cedab 50%, #00d128 50%, #1ce233)</atr>;
	<com>color</com>:          <atr>white</atr>
}
</pre>

<p><b>Point of interest</b>: the text within the progress bar will be drawn twice: once in the background,
and once for the bar itself (clipped to its size). That how a different color for the text that overlaps
the bar is achieved.


<p>Properties associated with progress bars are not that different from sliders or scroll bars:

<ul>
  <li><tt class="dt">SIT_MinValue</tt>, <tt class="dt">SIT_MaxValue</tt> (<tt class="t">int</tt>)
  <p>The range of values you want to set the progress bar. Default values are 0 and 100.

  <li><tt class="dt">SIT_ProgressPos</tt> (<tt class="t">int</tt>)
  <p>Will set the progress indicator at the specified position. Like with slider it is an alias for
  <tt>SIT_ScrollPos</tt> (if you are using the serialized interface, you must use <tt class="o">"progressPos"</tt>
  to set this property though).

  <li><tt class="dt">SIT_Title</tt> (<tt class="t">STRPTR</tt>)
  <p>You can <b>draw a caption over the progress bar</b>. This title will be used as a format string for one
  of the <tt>printf</tt> family of functions. One argument will be given after that format string: the
  integer representing the current progress value, it up to you to format this number however you like,
  including not display it at all.
  
  <p>It is advised to keep this property <b>relatively short</b>, like for example: <tt class="o">"<spe>%d%%</spe>"</tt>
  (remember that to include a percent sign in a <tt>printf</tt> format string, you have to double it).
  Note that, the text has to be inside the progress bar. If you want it outside, you'll have to create
  a label and keep it in sync with the progress whenever you modify the latter. Also the type of argument
  will be <tt class='t'>int</tt>.
  
  <p><span class="n">Note</span>: if your title include the sequence <tt class="o">"%%"</tt>, the value
  displayed at this location will adjusted to be in the range 0 - 100, no matter what you specified for
  <tt>SIT_MinValue</tt> and <tt>SIT_MaxValue</tt>. That way your progress bar can have a greater precision
  than what is displayed in the title.
</ul>

<p>Progress bars report no specific events.




<h3 id="SIT_TAB"><span>SIT_TAB</span></h3>

<p>Tab controls become handy when your interface grow to the point where it is hard to fit everything
in one dialog window and where you don't want to use separate sub-dialog to present the options to the
user:

<div class="image">
  <img src="images/SIT_TAB.png" alt="Single line tab">
</div>

<p>Here are the styles used for this control:
<pre>
<hdr>tab</hdr> {
	<com>padding</com>:       <atr>5px</atr>;
	<com>color</com>:         <atr>black</atr>;
	<com>background</com>:    <atr>white</atr>;
	<com>border</com>:        <atr>1px solid #898c95</atr>
}
<hdr>tab pane</hdr> {
	<com>background</com>:    <atr>linear-gradient(to bottom, #f2f2f2, #ebebeb 50%, #dbdbdb 50%, #cfcfcf)</atr>;
	<com>border</com>:        <atr>1px solid #898c95</atr>;
	<com>border-bottom</com>: <atr>0</atr>;
	<com>padding</com>:       <atr>3px 10px</atr>;
	<com>outline</com>:       <atr>1px solid rgba(white, 0.5) -2px</atr>
}
<hdr>tab pane</hdr>:<pse>active</pse> {
	<com>background</com>:    <atr>white</atr>;
	<com>padding</com>:       <atr>5px 10px</atr>
}
</pre>

<p>Placing control within a specific tab, can be done using two methods:</p>
<ol>
  <li><b>Automatic</b>: by setting the property <tt>SIT_TabOrder</tt> to n<sup>nth</sup> tab you want
  the the control to appear in. <b>Tabs are numbered starting from 1</b>. A small inconsistency to the
  usual 0-based indexing, because 0 is actually a special value, that will be described below.

  <p>By setting this property, the layout manager will then be able to automatically set the
  <tt>SIT_Visible</tt> property according to the selected tab.

  <li><b>Manual</b>: visibility of controls within tab can be manually managed by <b>giving 0 as the
  parameter for the <tt>SIT_TabOrder</tt> property</b> (which is the default value when creating controls
  as children of tabs). This special value means that the control will be visible on all tabs. If you
  want to hide it, you will have to catch the <tt>SITE_OnChanged</tt> event and reorganized your controls
  here.

  <p>A typical use case for this method is when the controls within the tabs are always the same: you
  usually don't want to duplicate all controls for each tab, you just create them once and adjust
  their content as the selected tab change.
</ol>

<p>It is actually possible to mix both methods: remember that setting <tt>SIT_TabOrder</tt> property
is only a way to automatically set the <tt>SIT_Visible</tt> attribute on each child controls.

<p>A few more properties are available to manage tabs:
<ul>
  <li><tt class="dt">SIT_TabStr</tt> (<tt class="t">STRPTR</tt>) <span class="ro">create-only</span>
  <p>Specify the initial list of tabs. It is a tab (ASCII code 9) separated list of names. e.g:
  <tt class="o">"First&nbsp;tab<spe>\t</spe>Second&nbsp;tab<spe>\t</spe>Third&nbsp;tab"</tt>.

  <li><tt class="dt">SIT_TabActive</tt> (<tt class="t">int</tt>)</dt>
  <p>Get/set the current selected tab (0-based index).

  <li><tt class="dt">SIT_TabCount</tt> (<tt class="t">int</tt>)</dt> <span class="ro">read-only</span>
  <p>Get the number of tabs currently defined in this control.

  <li><tt class="dt">SIT_TabSpace</tt> (<tt class="t">int</tt>)</dt>
  <p>Define the spacing between tabs (XXX should be done using CSS though).
</ul>

<p>To alter the list of tabs, you can also use the specialized function <tt>SIT_TabSplice()</tt>. Its
prototype is defined like this:

<pre><type>void</type> SIT_TabSplice(SIT_Widget w, <type>int</type> pos, <type>int</type> del, ...)</pre>

<p>It works similarly to the javascript <tt>Array.splice()</tt> method: you can delete some tabs, starting
at a given index, then add some other, by specifying a NULL-terminated list of strings.

<p>The event <tt>SITE_OnChange</tt> is fired whenever the selected tab changed. The <tt>call_data</tt>
can be converted into an integer to get the tab that has been selected (0-based index). Note that
auto-visibility of children controls is also managed through a callback of this type.
If you register your own callback for this event, do not return <tt class="o">1</tt>, otherwise the auto-visibility
will not be triggered.</p>




<h3 id="SIT_TOOLTIP"><span>SIT_TOOLTIP</span></h3>

<p>Tooltips are usually small popup windows that attempt to provide contextual
help to the user:

<div class="image">
  <img src="images/SIT_TOOLTIP.png" alt="Tooltip">
</div>

<p>This tooltip has been styled with the following declarations:
<pre>
<hdr>tooltip</hdr> {
	<com>background</com>:  <atr>#ffffe1</atr>;
	<com>color</com>:       <atr>black</atr>;
	<com>padding</com>:     <atr>0.3em</atr>;
	<com>white-space</com>: <atr>pre</atr>;
	<com>border</com>:      <atr>1px solid black</atr>;
	<com>box-shadow</com>:  <atr>3px 3px 4px -4px #333</atr>
}
</pre>

<p>Tooltips can be created using two different methods:</p>

<ul>
  <li><strong>Manually</strong>: using a standard <tt>SIT_CreateWidget()</tt> function
  call. That way, you will have access to all the tooltip styles/options, although you
  will have to do a separate function call.

  <li><strong>Automatically</strong>: using <tt>SIT_ToolTip</tt> property on the
  control you want to attach the tooltip. This property is actually available on the
  base <tt>SIT_Widget</tt> class, so that it can be used on every kind of control.
  It is a string that will be displayed as the body text of the tooltip. The drawback
  is that you won't be able to customized its behavior.
</ul>

<p>If you decide to create your tooltips manually, you will be able to customize their behavior
using the following properties:

<ul>
  <li><tt class="dt">SIT_DisplayTime</tt> (<tt class="t">int</tt>)
  <p>How long the tooltip will be displayed, in <b>milliseconds</b>. Default value is 10,000.

  <li><tt class="dt">SIT_DelayTime</tt> (<tt class="t">int</tt>)
  <p>How long the mouse needs to be idle over the target for the tooltip to popup, in <b>milliseconds</b>.
  Default value is 1,000. You can use the special value <tt>SITV_TooltipManualTrigger</tt>: the tooltip
  can only be showed by explicitly setting its <tt>SIT_Visible</tt> property to <tt class="o">True</tt>.

  <li><tt class="dt">SIT_ToolTipAnchor</tt>  (<tt class="t">int</tt>)
  <p>An enumeration that can be assigned to one of the following values:
  <ul>
	<li><tt>SITV_TooltipNearParent</tt>: the tooltip will remain at a fixed position near the parent
	object it has been assigned to. The position will depend on the space available around the control.

	<li><tt>SITV_TooltipFollowMouse</tt>: usually moving the mouse ever so slightly will hide the tooltip
	immediately. With this style the tooltip will be displayed for as long as it was specified for the
	property <tt>SIT_DelayTime</tt>, while the position of the tooltip will follow the mouse cursor.
  </ul>
</ul>


<p>Tooltips <b>can also be controlled manually</b>. For example, if you want to display a tooltip over
an item that is currently pointed by the user within the scene of your engine, the standard mechanism
to display them is way too simplistic to be usable.

<p>If you don't want to deal with complicated text layout (and all the boilerplate related to life time
management), it is still possible to use them in this situation. First, <b>create a tooltip</b>, with
a delay time set to <tt>SITV_TooltipManualTrigger</tt>:
<pre>
SIT_Widget tooltip = SIT_CreateWidget(<val>"blockinfo"</val>, SIT_TOOLTIP, app,
	SIT_ToolTipAnchor, SITV_TooltipFollowMouse,
	SIT_DelayTime,     SITV_TooltipManualTrigger,
	SIT_DisplayTime,   <val>10000</val>,
	<val>NULL</val>
);</pre>

<p>The tooltip has been created in the root node (ie: the one returned by <tt>SIT_Init()</tt>). At this
point the tooltip is hidden. <b>If you want it to be displayed</b>, you can use the following code:

<pre>SIT_SetValues(tooltip,
	SIT_Title,       <val>"This is the text of the tooltip."</val>,
	SIT_Visible,     <val>True</val>,
	SIT_DisplayTime, SITV_ResetTime,
	<val>NULL</val>
);</pre>

<p>The special value <tt>SITV_ResetTime</tt> is to ensure that if this tooltip was already displayed
somewhere else, the time it will remain on screen will be reset to what was configured at creation.

<p>This code should be executed whenever the <b>object highlighted has changed</b>. It is not necessary
to run it everytime the mouse has moved. The tooltip position will be automatically updated whenever
you provide mouse events through the <tt>SIT_ProcessMouseMove()</tt> function (and thanks to the
<tt>SITV_TooltipFollowMouse</tt>).

<p>If there are no objects being pointed, and you want to <b>immediately hide the tooltip</b>, simply
use the following code:
<pre>
SIT_SetValues(tooltip, SIT_Visible, <val>False</val>, <val>NULL</val>);
</pre>

<p>Also keep in mind, that at any given time, <b>only one tooltip can be displayed</b>. This is hardcoded in
the various event processing functions, that any attempt to display a certain tooltip, will close the
one currently displayed, if any.



<h3 id="SIT_HTMLTAG"><span>SIT_HTMLTAG</span></h3>

<p>This is a special type of widget, that do not have any visual output by default. The purpose is to
reuse some rendering capabilities of <tt>SITGL</tt>, that you would have to redo entirely otherwise,
like border/background rendering, text layout, ...

<p>In some way this type is very similar to <a href="#SIT_CANVAS">SIT_CANVAS</a>, the main difference
being that the name of the widget will also be assigned to the tag name (and thus will affect CSS selectors).

<p>Check out the <a href="#annexC">Annex C: Advanced rendering API</a>, for more information on how to
use this.


<h3 id="SIT_FILESELECT"><span>SIT_FILESELECT</span></h3>

<p>This dialog allows you to <b>select a file</b> to load and/or save. On Windows, the dialog is actually
a native widget:

<div class="image" style="display: inline-block">
  <img src="images/SIT_FILESELECT.png" alt="File chooser">
  <span class="caption">File chooser (windows)</span>
</div>

<p>The way this control is supposed to be used differs slightly from the previous types we have seen
so far. Actually when managing the dialog, it will enter into a modal event loop, and the return code
of the <tt>SIT_ManageWidget()</tt> function will indicate whether or not the user has confirmed or
cancelled its selection. If confirmed, you can check some properties to know what the selection was.

<p><span class="n">XXX</span> that's going to mess up timer.

<p>A few properties are available to customize this dialog:

<ul>
  <li><tt class="dt">SIT_Filters</tt> (<tt class="t">STRPTR</tt>)
  <p>Let you configure the list of available filters in the drop down list at the bottom of the dialog.
  It is a string specifying one filter per line (<tt>\n</tt> delimited). A filter is composed of an
  arbitrary name followed by tab (ASCII code 9) and then a semi-colon separated list of DOS wildcard.
  For example:
  <pre><val>"C/C++ files<spe>\t</spe>*.c;*.h;*.cpp;*.hpp<spe>\n</spe>"
"Any<spe>\t</spe>*"</val></pre></dd>

  <li><tt class="dt">SIT_SelFilter</tt> (<tt class="t">int</tt>)
  <p>Zero-based index within filter list that will be initially selected.

  <li><tt class="dt">SIT_InitPath</tt> (<tt class="t">STRPTR</tt>)
  <p>Initial path whose content will be displayed (UTF-8 encoded). <strong>The last
  part of this path</strong> will be used to pre-fill the file selection entry. If you
  want it to remain blank, add a final slash/anti-slash to your path.

  <li><tt class="dt" id="SIT_DlgFlags">SIT_DlgFlags</tt> (<tt class="t">int</tt>)
  <p>Bit field that can be composed of the following flags:
  <ul>
	<li><tt>SITV_FileSave</tt>: the label of the dialog will reflect a save
	operation. Otherwise they will reflect a load operation.</li>

	<li><tt>SITV_FileMultiSelect</tt>: allow the user to select multiple files.</li>

	<li><tt>SITV_FileMustExist</tt>: ensure the file exists before returning
	from the event loop.</li>

	<li><tt>SITV_FileWarnOverwrite</tt>: warn the user that the selection will
	be overwritten.</li>
  </ul>
</ul>

<p>Once your control has been created, you usually manage it just like you would with a normal dialog.
Remember that the function will only return when the dialog has been closed one way or another. If the
user confirmed its selection, you can check the properties <tt>SIT_SelPath</tt> and <tt>SIT_NbSelect</tt>
to know which paths have been selected and how many. If more than one file has been selected, they will
be appended one after the other (separated by a 0 byte).

<p>A typical usage would be:

<pre><type>int</type> handle_file(SIT_Widget w, <type>APTR</type> cd, <type>APTR</type> ud)
{
	<type>static</type> SIT_Widget file;

	<kwd>if</kwd> (file == <val>NULL</val>)
		file = SIT_CreateWidget(<val>"fileselect"</val>, SIT_FILESELECT, ud,
			SIT_Filters,   <val>"C/C++ files<spe>\t</spe>*.c;*.h;*.cpp;*.hpp<spe>\n</spe>"
			               "Any<spe>\t</spe>*"</val>,
			SIT_SelFilter, <val>1</val>,
			SIT_DlgFlags,  SITV_FileMultiSelect | SITV_FileMustExist,
			<val>NULL</val>
		);

	<kwd>if</kwd> (SIT_ManageWidget(file))
	{
		<type>STRPTR</type> path;
		<type>int</type>    nb;

		SIT_GetValues(file, SIT_SelPath, &amp;path, SIT_NbSelect, &amp;nb, <val>NULL</val>);

		<kwd>while</kwd> (nb &gt; <val>0</val>)
		{
			fprintf(<val>stderr</val>, <val>"file selected = <spe>%s\n</spe>"</val>, path);
			path = strchr(path, <val>0</val>) + <val>1</val>;
			nb --;
		}
	}
	<kwd>return</kwd> <val>1</val>;
}</pre>

<p>Take note that the control's object has been declared as static, and
is only created once and reused whenever the user trigger this callback.
This is to save a few settings that will be restored the next time the
dialog is displayed again, like:</p>
<ul>
  <li>Current directory selected.</li>
  <li>Filter selected.</li>
  <li>Position/dimension</li>
</ul>

<p>Memory for this control will actually be freed, when its parent dialog
gets closed.</p>



<h3 id="SIT_DIRSELECT"><span>SIT_DIRSELECT</span></h3>

<p>The directory selection control allows the user to navigate within local drives and choose a specific
folder. As with the <tt>SIT_FILESELECT</tt> control, this is a native widget on Windows:

<div class="image" style="display: inline-block">
  <img src="images/SIT_DIRSELECT.png" alt="Dir chooser">
  <span class="caption">Directory chooser (windows)</span>
</div>

<p>Its usage is very similar to the <tt>SIT_FILESELECT</tt> control. There are 2 properties you might
be interested to set when creating this kind of control:

<ul>
  <li><tt>SIT_InitPath</tt>: the initial branch to display. It has to be a
  fully qualified path. If case the user confirms its selection, this
  property will be overwritten by the selected path.</li>

  <li><tt>SIT_Title</tt>: the text to display above the tree view.</li>
</ul>

<p>Here's a typical usage:</p>
<pre><type>static</type> SIT_Widget dir;

<kwd>if</kwd> (dir == <val>NULL</val>)
	dir = SIT_CreateWidget(<val>"dirsel"</val>, SIT_DIRSELECT, parent,
		SIT_Title,    <val>"Select your destination path"</val>,
		SIT_InitPath, <val>"C:/Projects/SITGL"</val>,
		<val>NULL</val>
	);

<kwd>if</kwd> (SIT_ManageWidget(dir))
{
	<type>STRPTR</type> path;
	SIT_GetValues(dir, SIT_InitPath, &amp;path, <val>NULL</val>);
	fprintf(<val>stderr</val>, <val>"path selected = <spe>%s\n</spe>"</val>, path);
}</pre>

<p>Note that although the <tt>SIT_InitPath</tt> has been initialized with
forward-slash path, if the user ever confirms its selection, this property
will use backslash instead.</p>

<h2 id="miscfunc">Miscellaneous functions</h2>

<p>There are a few functions that will be useful for your application at some point and that have not
been mentionned so far in this document:

<ul>
  <li><tt class="dt">SIT_Widget SIT_GetFocus(<type>void</type>);</tt>,<br>
	  <tt class="dt"><type>void</type>       SIT_SetFocus(SIT_Widget);</tt>
  <p>Use these functions to set or get the widget that has the keyboard focus. Typical use case: if
  your dialog has a single text edit, you might want to set the keyboard focus here.

  <li><tt class="dt"><type>void</type> SIT_Exit(<type>int</type> code);</tt>
  <p>Initiate a graceful exit. Obviously, you will have to setup the <a href="#SIT_ExitCode"><tt>SIT_ExitCode</tt></a>
  property in order to catch the this, otherwise this function is mostly useless.

  <li><tt class="dt"><type>void</type> SIT_Log(<type>int</type> level, <type>STRPTR</type> fmt, ...);</tt>
  <p>This function will display a message in a <b>separate window</b> (from the operating system).
  This function can actually be called very early, even before the <tt>SITGL</tt> has been initialized.
  That's actually the main purpose of this function: notify the user of problems before you can display
  them on screen. Once <tt>SITGL</tt> has been initialized, it is advised to display the message within
  the application.

  <p><tt>level</tt> can be one of the following values:
  <ul>
	<li><tt>SIT_CRITICAL</tt>: unrecoverable error happened, <tt>SITGL</tt> will then perform a non-graceful
	exit after (ie: shader compilation failed).
	<li><tt>SIT_ERROR</tt>: an error, but recoverable (typical: file being asked is not found).
	<li><tt>SIT_INFO</tt>: not necessarily an error, but might be important enough to notify the user,
	so that it can fix it later.
  </ul>

  <p><tt>fmt</tt> can be a printf-like format strings, with potential aguments following.


  <li><tt class="dt"><type>STRPTR</type> SIT_GetFromClipboard(<type>int</type> * size);</tt>
  <p>Try to retrieve the text currently stored in the clipboard. The returned string will always be
  <tt class="o">NULL</tt>-terminated and UTF-8 encoded, unless the clipboard did not contain any
  textual information. In that case <tt class="o">NULL</tt> will be returned.
  
  <p><b>The string will be dynamically allocated</b>, and you'll have to free it yourself when not
  needed anymore. On Windows, if you are using the same runtime than <tt>SITGL</tt>, you can use
  the standard <tt>free()</tt> function, if unsure, use <tt>SIT_Free()</tt>.

  <p><tt>size</tt> is the size in bytes of buffer returned (including the final NUL byte). This
  parameter can be <tt class="o">NULL</tt> if you don't care about this.


  <li><tt class="dt"><type>Bool</type> SIT_CopyToClipboard(<type>STRPTR</type> text, <type>int</type> size);</tt>
  <p>Copy the supplied UTF-8 text into the clipboard. A copy of the text will be made. <tt>size</tt>
  is the <b>amount of bytes</b> you want to copy from the string. You can specify <tt class="o">-1</tt> to
  copy everything up to the <tt class="o">NULL</tt> byte.

  <li><tt class="dt"><type>void</type> SIT_Free(<type>APTR</type> pointer);</tt>
  <p>Memory management within <tt>SITGL</tt> has been carefully crafted so that explicitly freeing
  memory is reduced to the absolute minimum. There are a few functions that have to return dynamicly
  allocated resources and where the lifetime of those resources are not in the control of <tt>SITGL</tt>.
  For these cases, you'll have to free the resources yourself using this method.

  <p>As of writing this, all the resources dynamically allocated are strings.


  <li><tt class="dt">SIT_Action SIT_ActionAdd(SIT_Widget w, <type>double</type> start_ms, <type>double</type> end_ms, SIT_CallProc, <type>APTR</type> ud);</tt>
  <p>Add an asynchronous action to be called (potentially repeatedly) at a later time. Your callback
  won't be called until the control has been given back to <tt>SITGL</tt>, through the function
  <tT>SIT_RenderNodes()</tt>. <span class"n">Note</span>: the <tt>w</tt> is kind of useless, it is simply
  a parameter that will be given back to your callback as its first argument.

  <p>The callback will be called repeatedly (ie: each frame) as long the current time falls between
  <tt>start_ms</tt> and <tt>end_ms</tt>. If <tt>end_ts</tt> falls behind the current time, the asynchronous
  action will be removed. The <tt>call_data</tt> can be seen as a boolean, that will be set to
  <tt class="o">True</tt> if it the <b>last time this callback will be triggered</b>.

  <p>The return value of the callback has a special meaning though:
  <ul>
    <li>negative value: immediately remove the action from the list. Your callback won't be called again
	after this.
	<li>zero: keep going, change nothing.
	<li>positive value: shift the time interval by this amount of milliseconds (both <tt>start_ms</tt>
	and <tt>end_ms</tt>).
  </ul>

  <p>The return value in an opaque pointer that represents the action. It will be valid as long as you
  didn't cancel the action explicitely (see next function) or the callback hasn't been notified of its
  last execution.

  <li><tt class="dt"><type>Bool</type> SIT_ActionReschedule(SIT_Action act, <type>double</type> start_ms, <type>double</type> end_ms);</tt>
  <p>You can extend the life time of an asynchronous action with this function. Even though its main
  purpose is usually to cancel one. For this, simply use <tt class="o">-1</tt> as for the <tt>start_ms</tt>
  and <tt>end_ms</tt> parameter. If you kept a reference on the <tt>SIT_Action</tt> object, time to clear
  it now.

</ul>

<h2 id="extractrl">Extra widgets</h2>

<p>This section will list a few widgets that are available as separate source files to be compiled with
your main program. They are implemented using no more than what has been explained so far, they do not
make use of private datatypes from SIT. They are also a good source to get a feel of the typical design
patterns used by this library.

<p>The source code for these widgets is located in the <tt>examples</tt> directory. They have the same
requirement as for compiler support than <tt>SITGL</tt>.

<h3 id="propfactory"><span>Property factory</span></h3>

<p>This library has a crude but small mechanism to <b>add extra properties</b> that can be recognized
by the functions <tt>SIT_SetValues()</tt> and <tt>SIT_GetValues()</tt>. The problem when designing custom
controls, is that it is usually quite common to have lots of parameters for the user/programmer to fiddle
with. You can still write your own functions for handling this part, but you'll quickly find out that
the only easy way to deal with lots of properties is using a <em>vararg</em> interface, similar to the
<tt>SIT_SetValues()</tt> or <tt>SIT_GetValues()</tt> functions, because:

<ul>
  <li>You do not have to remember the order in which to pass arguments.</li>
  <li>You can set/get any subset of all the available properties.</li>
  <li>There is provision to "bufferize" modification of properties (ie:
  setting several properties can still result in a single internal update).</li>
</ul>

<p>The drawback of this mechanism is that it does not work with the functions <tt>SIT_CreateWidget()</tt>,
<tt>SIT_CreateWidgets()</tt> and <tt>SIT_SetAttributes()</tt>, although it is still better than nothing,
or having to write your own mechanism.

<p>To implement custom attributes for your control, you'll first have to <b>define custom tags</b>, that
will be recognized as such by functions <tt>SIT_SetValues()</tt> and <tt>SIT_GetValues()</tt>. User-defined
tags starts with the value <b><tt>SIT_TagUser</tt></b> or higher. Usually, you just have to declare
your attributes that way:
<pre><type>enum</type>
{
	MyAttribute1 = SIT_TagUser,
	MyAttribute2,
	MyAttribute3
	<com>/* ... */</com>
};</pre>

<p>Then you have to <b>register a callback</b> for a <tt>SITE_OnSetOrGet</tt> notification. It will be
triggered whenever the user wants to get <strong>or</strong> set a custom attribute (both actions are
directed to the same callback). The call data is defined this way:
<pre><type>struct</type> SIT_OnVal_t
{
	<type>int</type>       stage;
	<type>int</type>       tag;
	<type>APTR</type>      ptr;
	<type>va_list</type> * vararg;
};</pre>

<p>There are only two fields you might be interested in:
<ul>
  <li><tt>stage</tt>: what action is requested by user. Either <tt>SITV_Set</tt>,
  <tt>SITV_Get</tt> or <tt>SITV_PostProcess</tt> (more on these later).</li>
  <li><tt>tag</tt>: the tag id.</li>
</ul>

<p><tt>ptr</tt> and <tt>vararg</tt> are managed through the use of macros. Let's first see what the
callback is expected to do according to current stage:

<ul>
  <li><tt class="dt">SITV_Get</tt>
  <p>The user wants to <b>get the value of an attribute</b>. You will have to use the macro <tt>SIT_SET(cd, val, type);</tt>
  (meaning you have to set the user variable). Where <tt>cd</tt> is the second argument (<tt>call_data</tt>)
  of your callback, <tt>val</tt> is the value you want to return to the user (and not a pointer to it).
  <tt>type</tt> is the type of the value. Note: <tt>val</tt> will only be evaluated once, you can use
  complex expression, even though it is a macro.

  <p>If resources must be allocated for the value, it is strongly recommended to not let the user
  handle the deallocation of it. Since it is your control that allocates the memory, it is best if
  it is also yours that frees it. This can be implemented by some sort of caching mechanism,
  with the added benefit of being able the return later the same value if asked again.

  <p>Return code is not meaningful for this stage.

  <li><tt class="dt">SITV_Set</tt>
  <p>The user ask to <b>modify the value of a given tag</b>. You can use the macro <tt>SIT_GET(cd, type);</tt>
  to get the value given by the user (this will be the actual value, not a pointer to it). Be careful
  with strings, this will be the original buffer provided by the user, it is strongly advised to make a copy.

  <p>Also, even if your property is read-only, it is advised to use the <tt>SIT_GET</tt> macro,
  to prevent user error, because of the way vararg works in C.

  <p>If the return code is positive, it will mean that you want to be notified once all arguments to
  <tt>SIT_SetValues()</tt> have been processed. That way, you can process modifications in one pass.

  <li><tt class="dt">SITV_PostProcess</tt>
  <p>If you returned a positive integer during a <tt>SITV_Set</tt> stage, another one will be triggered.
  If you ever intend to do some post-processing, the easiest way to handle this is to modify your internal
  datatypes along with a bitfield that give some hints as to what part has been modified during the
  <tt>SITV_Set</tt> stage. Once in the post-process stage, analyze that bitfield and modify part of
  the interface that needs refresh. Return value is ignored for this stage.
</ul>

<h4>Managing related properties</h4>

<p>Sometimes, it will happen that two or more properties are related in some way: if you
set one property, one or more has also to be set in the same call. The problem in this
case, is that you'll have no control over the order that arguments have been passed by
the user. Still, there is at least 3 ways to handle this case. From the easiest, to the
hardest:</p>

<ol>
  <li><b>Use macros</b>: that way you can force the order of the arguments. For example, if
  <tt>MyAttribute1</tt> must be set before <tt>MyAttribute2</tt>, simply define a macro like
  this:
  <pre><def>#define </span><inc>MyAttribute2(param1)    MyAttribute1, param1, SIT_TagUser+100</span></pre>
  <p>Here we used a private tag definition (<tt>SIT_TagUser+100</tt>: out of the reach of any
  auto-completion tool of a typical IDE) to be sure it is not directly set
  by the user. Then, you can use it that way:</p>
  <pre>SIT_SetValues(ctrl, MyAttribute3, <val>123</val>, MyAttribute2(<val>456</val>), <val>789</val>, <val>NULL</val>);</pre>
  <p>Which breaks a little bit the tag/value model, but it is still acceptable. This method
  have been used in SIT for the tags <tt>SIT_RowTag</tt> and <tt>SIT_RowText</tt>, for example.</p>
  </li>

  <li><b>Transmit parameters into a struct/object</b>: thay way you are guaranteed to get all
  parameters needed at once. This is often not as convenient as having individual properties,
  or even just a macro.</li>

  <li><b>Manage individual property</b>: this one can be tedious to write. Since you have no
  guarantee in the order of parameters, it is advised to process them in the <tt>SITV_PostProcess</tt>
  stage, while marking in the <tt>SITV_Set</tt> stage, which parameters have been set (if you've done
  your homework correctly, <tt>user_data</tt> parameter of this callback should point to an
  object where you can store this kind of information). Once in the post-process stage, try
  to honor the request of user with whatever information has been provided.</li>
</ol>

<p>Remember that within the SIT library, all properties have been carefully chosen to not depend
on the order in which arguments are passed. It would be quite error prone to introduce such a
constraint this late in the game. Also, use the method best suited for the job: no need to
implement a 2-stage property processing, if there is nothing that can be done if all properties
have not been set. In this case, a macro is probably the way to go.

<h3 id="filechooser"><span>File chooser</span></h3>

<p>The stock <a href="#SIT_FILESELECT">file chooser</a> dialog is based on a native widget. If you want
to have a more integrated solution, you might be interested in this implementation. As you can see,
it is implemented using nothing more than stock widgets from this library:

<div class="image">
  <img src="images/SIT_FILECHOOSER.png">
</div>

<p>Its usage is pretty straightforward, there is only one public functions:
<pre>SIT_Widget FSOpen(SIT_Widget parent, STRPTR initdir, SIT_CallProc cb, APTR ud, int flags);</pre>

<p>Each arguments have the following meaning:
<ul>
  <li><tt>parent</tt>: which dialog the file chooser will be the child of.
  <li><tt>initdir</tt>: initial directory to display. If <tt class="o">NULL</tt>, the current working
  directory will be used. If the path provided is relative, it will be made absolute.
  <li><tt>cb</tt>: a callback triggered when the user confirm or cancel its selection.
  <li><tt>ud</tt>: the user data parameter that will be transmitted to the callback.
  <li><tt>flags</tt>: the same flags that can be specified for the <a href="#SIT_DlgFlags">SIT_DlgFlags</a>
  property.
</ul>

<p>The return value will be the pointer to the top level dialog containing all the controls of the
file chooser. At this point, the dialog has not been managed yet. This is to give you a chance to modify
the layout and/or content of some of the control (see below).

<p>If not <tt class="o">NULL</tt>, you have to call the function <tt>SIT_MangeWidget()</tt> on the
returned value at some point in order for the dialog to appear on screen.

<p>The callback will receive the fully qualified path (or paths) as for the <tt>call_data</tt> parameter.
Here is how you can retrieve all the paths with the <tt>SIT_FileMultiSelect</tt> flag set:
<pre><type>static int</type> selectFile(SIT_Widget w, <type>APTR</type> cd, <type>APTR</type> ud)
{
	<kwd>if</kwd> (cd)
	{
		<type>STRPTR</type> p;
		<com>/* this will work even without the SIT_FileMultiSelect flag */</com>
		<kwd>for</kwd> (p = cd; *p; p = strchr(p, <val>0</val>) + <val>1</val>)
			fprintf(stderr, <val>"file selected = <spe>%s\n</spe>"</val>, p);
	}
	<kwd>else</kwd> fprintf(stderr, <val>"cancelled<spe>\n</spe></val>");
	<kwd>return</kwd> <val>1</val>;
}</pre>

<p>In this callback, it is up to you to save some parameters from this dialog. The typical information
you might want to get is:
<ul>
  <li><b>Current directory</b>: you can retrieve the current directory, so that you can provide it again
  the next time you call <tt>FSOpen()</tt>, using a code like this:
  <pre><type>STRPTR</type> curdir;
SIT_GetValues(SIT_GetById(w, <val>"curdir"</val>), SIT_Title, &amp;curdir, <val>NULL</val>);</pre>
  <p>Where <tt>w</tt> is the first parameter of the callback. <span class="n">Note</span>: the memory
  containing the path will be free()'ed right after your callback finishes. <b>You have to copy the
  content of this buffer elsewhere</b>.
  <li><b>Dialog dimension</b>: you might want to save the dimension and/or position of the dialog.
  It is advised to let the library position the dialog, in case the screen dimension have changed since
  it was retrieved. To get the dimension, simply use a code similar to:
  <pre><type>int</type> with, height;
SIT_GetValues(w, SIT_Width, &amp;width, SIT_Height, &amp;height, <val>NULL</val>);</pre>
  <p>And save those somewhere safe, and apply them back on the value returned by <tt>FSOpen</tt>, just
  before calling <tt>SIT_ManageWidget()</tt>.
</ul>

<p>If you need more fancy features, the easiest way is to simply hack directly the source code.

<h3 id="colorchooser"><span>Color chooser</span></h3>

<p>There are no color chooser in the list of stock widgets, but it is relatively easy to develop one.
Here is a simple implementation, that will <b>allow you to select an RGB color</b> using the HSV color space:

<div class="image">
  <img src="images/SIT_COLORCHOOSER.png">
</div>

<p>This utility will display the HSV color space split into 2 parts: left part show a slice of the 
saturation/value space, and right part is the hue selection. The input button let you copy/paste color
name/value: it uses the same function that is used by <tt>SITGL</tt> to parse color value, therefore
you can enter value like: <tt>blue</tt>, <tt>pink</tt>, <tt>#123456</tt>, <tt>rgb(255,20,20)</tt>, ...
If the value was parsed successfully, it will always be converted to <tt>#RRGGBB</tt> format.

<p>Its usage is very similar to the <a href="#filechooser">file chooser</a> widget. There is only one
public function to instanciate this control:
<pre>SIT_Widget CCOpen(SIT_Widget parent, DATA8 rgb, SIT_CallProc cb, <type>APTR</type> ud);</pre>

<p>Where each parameters have the following meaning:
<ul>
  <li><tt>parent</tt>: which dialog it will be derived from.
  <li><tt>rgb</tt>: initial color that will be displayed.
  <li><tt>cb</tt>: a callback triggered when the user confirm its selection. <tt>call_data</tt> will
  point to an array of 4 <tt class="t">uint8_t</tt>, containing, in that order, the red, green, blue
  and the value 255 (ie: fully opaque) of the selected color.
  <li><tt>ud</tt>: the user data parameter that will be transmitted to the callback.
</ul>

<p>Like with the file chooser, the return value is the pointer to the dialog containing all the controls
of the color chooser. At this point you can change some values and/or use <tt>SIT_ManageWidget()</tt>
to immediately display the window.


<h3 id="vt100"><span>Console window</span></h3>

<p>This widget can be seen as a <b>read-only version of the <tt>SIT_EDITBOX</tt> control</b>, with some extra
styling support (colors and fonts). The typical use case for this control is to implement a console output
for your engine. Usually, when building your application for release, the standard output (ie:
<tt>printf</tt> or <tt>cout</tt>) will not be available. If you still want to keep a log accessible
somewhere, you might be interested by this widget.

<p>Note: <b>for debugging purpose, don't use that widget</b>. Simply use the standard output/error stream.
The reason being that if something goes wrong with your program, it is going to be hard to access the
buffer content, especially if your program is stopped in a debugger breakpoint. That problem can be
easily solved by using your terminal output.

<p>The purpose of this widget is to be used by the final user, like dumping a chat log or a way to
dump some command output.

<div class="image">
  <img src="images/VT100.png">
</div>

<h4 id="vt100init">Initialization</h4>

<p>One of the key aspect of this widget is that the amount of bytes used for the content buffer is <b>fixed</b>: at some point
after adding enough text, earlier lines will be automatically discarded. Unbound growth is never desirable
for a widget like this.

<p>Text is actually stored in a ring buffer, so that when earlier entries have to be discarded, the whole
buffer don't need to be shifted. Therefore adding text should be done at a constant speed, no matter how
big the content buffer is or how many bytes have been added so far.

<p>This widget has to be derived from a <a href="#SIT_CANVAS"><tt>SIT_CANVAS</tt></a>, that <b>you have
to create beforehand</b>. Additionally, you can also create a <a href="#SIT_SCROLLBAR"><tt>SIT_SCROLLBAR</tt></a>,
<b>as a child of the <tt>SIT_CANVAS</tt></b>, in order to scroll the content, in case there is more than
what can be displayed on screen. This scroll bar needs to be created in a vertical orientation, since
the text will be wordwrapped (or, at your choice, character wrapped), a horizontal scrollbar will be
completely useless.

<p>Scrollbar is optional though, you are free to implement your own scrolling behavior, since there is
an API to manually set the top visible line (and keyboard shortcuts will work fine without it).

<p>This is the typical code to create the necessary widgets:

<pre>SIT_CreateWidgets(diag,
	<val>"&lt;canvas name=output left=FORM right=FORM top=FORM bottom=FORM&gt;"
	"  &lt;scrollbar name=scroll top=FORM bottom=FORM right=FORM,,NOPAD visible=0&gt;"
	"&lt;/canvas&gt;"</val>
);</pre>

<p>Take note, that the scrollbar has been initially set to hidden and anchored on the right side of the
canvas. There are only 2 ways to position the scroll bar though: on the right side or left side. If placed
anywhere else, the scrollbar will overwrite some content at some point.
<p><span class="n">Note</span>: if the scrollbar is attached on the left, you might want to add a bit
of padding on the right to prevent the text from being flushed against the scrollbar. You can do this
by specifying a dimension for the property <tt>SIT_RightOffset</tt>. Even though, the right attachment
should left to <tt>None</tt>, you can still assign an offset to it (the geometry layout will of course
ignore that offset).

<p>Once the widgets have been created, you need to <b>give their ownership to the console widget</b>, using
the following function:
<pre><type>void</type> VTInit(SIT_Widget canvas, SIT_Widget scroll);</pre>

<h4 id="vt100prop">Custom properties</h4>

<p>After that, the widget will be ready to receive text and/or configured using the custom properties.
These properties can be set/retrieved <b>on the canvas widget</b> (not the scrollbar though):

<ul>
  <li><tt class="dt">VT_AddText</tt> (<tt class="t">STRPTR</tt>) <span class="ro">write-only</span>
  <p>This is the property you can use to add text to the console. It only accepts a <tt class="o">NULL</tt>-terminated
  string as input (and as always, UTF-8 encoded). <tt>printf</tt>-like format are not supported, although
  creating a wrapper is simple enough as to be left as a exercise for the user.
  
  <p>The text can have format specifiers to change the text color, background or font. A format specifier
  uses the following syntax:
  <pre><val>"<spe>\x1b</spe>["</val> <em>FORMAT</em> <val>"m"</val></pre>
  <p>Where <tt>FORMAT</tt> is a semi-colon separated list of numbers. The numbers that can be used are:
  <ul>
    <li>0: cancel all custom styles and colors.
    <li>1: start text in bold.
    <li>2: stop using bold font.
    <li>4: start underline style.
    <li>24: stop underline.
    <li>30~37: change foreground color to color index 0~7 (from <tt>VT_Palette</tt>).
    <li>90~97: change background color to color index 0~7.
    <li>40~47: change foreground color to color index 8~15.
    <li>100~107: change background color to color index 8~15.
  </ul>
  <p>In case you are wondering where this syntax comes from, they are a subset of the
  <a href="https://www2.ccs.neu.edu/research/gpc/VonaUtils/vona/terminal/vtansi.htm#colors">VT100
  escape sequences</a>. For example:
  <pre><val>"<spe>\x1b</spe>[1mHello<spe>\x1b</spe>[0m <spe>\x1b</spe>[36;4mworld<spe>\x1b</spe>[0m !"</val></pre>
  <p>Will generate something similar to:
  <div class="image">
    <img src="images/VT100_output.png">
  </div>
  <p>Whenever a format specifier is added to the text, that format will be used until another format
  cancels it.

  <p>There are 2 other format specifiers available:
  <ol>
    <li><tt class="dt"><val>"<spe>\x1b</spe>["</val> <em>NUMBER</em> <val>"s"</val></tt>

    <p>This form is used to add a variable space width. The width of the character will be <b>number
    of pixels</b> specified in the format. The typical use case is to right/center align text. In the
	first screenshot, the first column of numbers (with an orange background) were aligned this way.
	It will require some work on your side though: you'll have to measure the text using <tt>nanovg</tt>
	before being able to add it.

    <li><tt class="dt"><val>"<spe>\x1b</spe>["</val> <em>NUMBER</em> <val>"i"</val></tt>
    <p>The second form is to add an indent <b>after a soft line-break</b>. It is similar to the CSS
	<tt>text-indent</tt> attribute, except it will be applied on subsequent lines instead on the first.
	The typical use case for this feature is to group content that is related. In the first screenshot,
	the indent has been setup so that the text is wrapped just after the timestamp: that way it is very
	clear when a line is the continuation of another.

	<p>Again, you'll have to do some work on your side beforehand, even though it should be no more
	than a few lines of code.
  </ol>

  <p><span class="n">Caveat</span>: When adding text, format specifier needs to be added in one chunk.
  For example:
  <pre><com>/* this won't switch the text to bold blue color */</com>
SIT_SetValues(canvas, VT_AddText, <val>"<spe>\x1b</spe>["</val>, <val>NULL</val>);
SIT_SetValues(canvas, VT_AddText, <val>"1;31mHello world"</val>, <val>NULL</val>);

<com>/* this will work */</com>
SIT_SetValues(canvas, VT_AddText, <val>"<spe>\x1b</spe>[1;31mHello world"</val>, <val>NULL</val>);</pre>


  <li><tt class="dt">VT_Palette</tt> (<tt><type>uint8_t</type> [<val>64</val>]</tt>)
  <p>An array of 64 bytes, specifying 16 colors using the RGBA notation. The default palette should
  be good enough for a dark background. If you want to use it on a light background, you should swap
  the first and last color. Remember, that it is still possible to specify some <tt>text-shadow</tt>
  to be sure the text remains readable on any background.

  <li><tt class="dt">VT_MaxBuffer</tt> (<tt class="t">int</tt>) <span class="ro">create-only</span>
  <p><b>How many bytes the content buffer will hold</b> before reusing older bytes once it is full. Default
  value is <b>64Kb</b>. On a typical log file, lines are between 50 to 100 bytes, therefore that buffer
  size should be enough for about 1000 lines (<span class="n">Note</span>: keep in mind that format
  specifiers are also stored in this buffer).

  <p>That buffer won't be allocated in one chunk. Actually, if you never add any text, nothing will be
  allocated at all.

  <li><tt class="dt">VT_TabSize</tt> (<tt class="t">int</tt>)
  <p>This will set the <b>width of tab character</b> (ASCII code 9) in multiple of space character
  (ASCII code 32). Default value is <b>4</b>. Valid values are between 2 and 100.

  <li><tt class="dt">VT_TopLine</tt> (<tt class="t">int</tt>)
  <p><b>Set the top visible line</b>. Whatever value is given, it will be clamped to what is physically
  possible with the console. It means, that if you want to always display the bottom of the log, simply
  give a very large number.

  <p>The top line will be kept as is even if new content is added, to prevent the view from jumping all
  over the place when you are reading earlier lines. You can force the control to always show the last
  lines that have been added, simply by setting this property to a very large number. This is 
  the <b>initial value</b>: the content will be scrolled to always display the end of the buffer.

  <li><tt class="dt">VT_TotalLines</tt> (<tt class="t">int</tt>) <span class="ro">read-only</span>
  <p>Retrieve the <b>total number of lines</b> currently stored in the content buffer. That number will
  also include the number of soft-lines due to character/word wrapping. This property is useful if you
  want to implement your own scrolling behavior.

  <li><tt class="dt">VT_SelLength</tt> (<tt class="t">int</tt>) <span class="ro">read-only</span>
  <p><b>Length of text currently selected</b>, including <tt class="o">NULL</tt> byte. Therefore, if
  length is less or equal to 1, nothing is selected.

  <li><tt class="dt">VT_SelBuffer(max)</tt> (<tt class="t">STRPTR</tt>) <span class="ro">write-only</span>
  <p><b>Copy current text selected</b> into the buffer provided. This macro require an argument that specify
  the amount of bytes the buffer can hold. If the buffer is too small, the text will be truncated. As
  long as there is at least one byte available, the buffer will always be <tt class="o">NULL</tt>-terminated
  and multi-byte characters should not be split in the middle.

  <p><span class="n">Note</span>: formatting attributes <b>will not</b> be copied, only the text will.

  <li><tt class="dt">VT_LinePadding</tt> (<tt class="t">int</tt>)
  <p>You can specify how far part apart each lines will be. By default lines are stack on top of each other
  without any gap.

  <li><tt class="dt">VT_WordWrap</tt> (<tt class="t">int</tt>)
  <p>How lines should be wrapped: 0 for character wrapping or 1 for word wrapping (default).

  <li><tt class="dt">VT_MarkText</tt> (<tt class="t">STRPTR</tt>)
  <p>Will highlight <b>all occurrences of the text</b> given as argument. Formatting attributes <b>and
  case</b> will be ignored when comparing search text and buffer content. Also, a single space in the
  search string can match multiple spaces in the console buffer. Tab and spaces are considered to be
  space characters (newlines are not though).

  <p><span class="n">Note</span>: the text will be limited to the first 31 characters, and cannot span
  multiple lines.

  <li><tt class="dt">VT_MarkFgBg</tt> (<tt class="t">int</tt>)
  <p>Color to use for highlighting occurrences. You have to specify both foreground (lower 4bits)
  and background (higher 4bits), or use the macro <tt>VT_FGBG()</tt>. Default value is 8 for foreground
  and 15 for background, which is dark gray on yellow background using the default palette.

</ul>

<h4 id="vt100css">Styling</h4>

<p>The content area is mostly managed by this control, however, it will honor a few CSS properties:
<ul>
  <li><tt class="dt">text-shadow</tt>
  <p>Shadow text will be rendered line per line, which means you kind of have to avoid text shadow
  overlaping previous line, because it can overwrite some text. Also, since you cannot specify a
  text-shadow per background color, you should always add an alpha component to the shadow color.

  <li><tt class="dt">line-height</tt>
  <p>Use this property to make thicker lines. The difference between <tt>line-height</tt> and
  <tt>VT_LinePadding</tt> is that <tt>line-height</tt> will also affect background color (including
  selection), whereas line padding won't. In the first screenshot, <tt>line-height</tt> was set to
  <tt class="o">1.1</tt> and <tt>VT_LinePadding</tt> to <tt class="o">1</tt>.
</ul>

<h4 id="vt100kbd">Keyboard shortcuts</h4>

<p>If the canvas has the keyboard focus, the following shortcuts will be available. Remember that you
can also use the function <tt><a href="#SIT_ApplyCallback">SIT_ApplyCallback()</a></tt>, to redirect
keyboard events to this control (typical use case: redirect some events from a single line edit box).

<ul>
  <li><span class="key">Home</span>, <span class="key">End</span>: move visible area to top/bottom.
  <li><span class="key">PgUp</span>, <span class="key">PgDown</span>: scroll up/down one page.
  <li><span class="key">&#x25b2;</span>, <span class="key">&#x25bc;</span>: scroll up/down one line.
  <li><span class="key">Ctrl+A</span>: select all text.
  <li><span class="key">Ctrl+C</span>: copy selection to clipboard.
  <li><span class="key">Ctrl+F</span>: use current selection as the word to highlight.
  <li><span class="key">Ctrl+G</span>: select next occurrence of word.
  <li><span class="key">Ctrl+L</span>: clear entire content.
  <li><span class="key">Ctrl+V</span>: paste clipboard into content buffer.
</ul>

<h2 id="i18n">Internationalization</h2>

<p>Internationalization refers to everything required for an application to <em>speak</em> in a different
language than the one it was originally written for. This includes lots of concepts, like date and number
formatting, currency, left-to-right or right-to-left writings, input methods, and of course, messages
displayed by your application. For the sake of simplicity, we will only explain the latter point:
translating messages of your application.

<p><tt>SITGL</tt> uses a method similar to the <tt>gettext()</tt> interface, but with some simplifications.
You can read an extensive documentation of gettext on <a href="http://www.gnu.org/software/gettext/manual/gettext.html">FSF website</a>,
especially chapters 1, 3, 4 and 11.</p>

<p>To quickly sum up: <tt>gettext</tt> acts as a dictionary, but instead of words, it will be entire
sentences (messages) from your program. The core of the API is composed of one function:

<pre><type>char</type> * gettext(<type>char</type> * msg);</pre>

<p>You give it one message and it returns the translated version using the current locale (or in case
of the <tt>SITGL</tt>: the translation file you loaded prior to translate any message). If the translation
was not found, it will simply return the first argument you provided. So without further action, gettext
act as a light-weight no-op.

<h3 id="localeinfo"><span>Locale information</span></h3>

<p>Before you can translate anything, you'll first need to know what is the current language of the
operating system. You can always later provide a menu to let the user select its own language, but
the first time the application is launched, it is advised to use the preferred language. Also take
note that changing messages of an application after it has started is usually way too much work,
not really worth the effort.

<p>The locale information is actually stored in the <tt>SIT_App</tt> widget, into the property
<tt>SIT_LocaleInfo</tt>. The content of this property is a pointer to a <tt>LocaleInfo</tt> structure.
You can find its definition in the main header <tt>SIT.h</tt>:

<pre><type>struct</type> LocaleInfo_t        <com>// Example:</com>
{
	STRPTR nlsLang;        <com>// Fran&ccedil;ais</com>
	STRPTR nlsCountry;     <com>// France</com>
	STRPTR engLang;        <com>// French</com>
	STRPTR engCountry;     <com>// France</com>
	STRPTR iso3166;        <com>// FR_fr</com>
	STRPTR currency;       <com>// &euro;</com>
	STRPTR currencyName;   <com>// Euro</com>
	STRPTR currencyCode;   <com>// EUR</com>
	STRPTR shortDate;      <com>// dd/MM/yyyy</com>
	STRPTR longDate;       <com>// dddd d MMMM yyyy</com>
	STRPTR decimalSep;     <com>// ,</com>
	STRPTR months[<val>12</val>];     <com>// janvier, f&eacute;vrier, ...</com>
	STRPTR abbrMonths[<val>12</val>]; <com>// janv., f&eacute;vr., ...</com>
	STRPTR weekDays[<val>7</val>];    <com>// lundi, mardi, ...</com>
	STRPTR abbrWeek[<val>7</val>];    <com>// lun., mar., mer., ...</com>
	STRPTR langCode;       <com>// 040C</com>
	STRPTR intlPrefix;     <com>// 33</com>
};
</pre>

<p>This structure is particularly important to know how to uniquely get the name of the language, in
order to name your language file accordingly. In this case, it is advised to use the ISO 3166 country
code, since it is guaranteed to be unique and only use ASCII charset. The other fields might contain
unicode characters.

<h3 id="msgextract"><span>Automating message extraction</span></h3>

<p>Maintaining multiple translation files is usually a tedious process, so it better has to be automated
as much as possible. The first step into translating an application is to prepare the messages of your
program as described in <a href="http://www.gnu.org/software/gettext/manual/gettext.html#Preparing-Strings">section
4.3: Preparing Translatable Strings</a>.

<p>The only difference is that the function to extract a message from the catalog is named <tt>LangStr()</tt>
instead of <tt>gettext()</tt>, and both are usually abridged <tt>_()</tt> to limit the overhead of
translation.

<p>For example, to translate the Hello world program given in <a href="#helloworld">chapter 4: Getting Started</a>,
you only have to modify the label creation, with the following line:

<pre>SIT_CreateWidgets(app, <val>"&lt;label name=hello title="</val> _(<val>"Hello, world!"</val>), <val>"&gt;"</val>);</pre>

<p><span class="n">Note</span>: since you'll need locale information to load the correct language file,
and since this information is only available at the <tt>SIT_APP</tt> level, that means any errors occurring
before a successful <tt>SIT_Init()</tt> cannot be translated with this module. <span class="n">XXX</span>
should be decoupled really.

<p>You'll have to mark all of your message that way. Once it is done, you can use the <tt>msgextract</tt>
utility to extract them in one shot, and update/create every translation file. You can find it in the
<tt>examples</tt> folder of the SIT distribution. The way this utility works is through an INI configuration
file. A typical configuration for extracting messages from C source files is:

<pre><type>Lang</type>=lang
<spe>[1]</spe>
<type>Folder</type>=*.c
<type>Prefix</type>=_("
<type>Suffix</type>=<val>"<spe>\"</spe>)"</val></pre>

<p>The following keywords can be specified:
<ul>
  <li><tt>Lang</tt>: must the first keyword of this file. Indicate where language files will be updated.
  <li><tt>Folder</tt>: an optional path followed by a MS-DOS wildcard, use to filter files to be scanned
  for messages to be extracted and merged with language files.
  <li><tt>Prefix</tt>: the starting string that mark the beginning of a message to extract.
  <li><tt>Suffix</tt>: the string that mark the end of the message.
</ul>

<p>If your configuration was named "<tt>msgextract.ini</tt>", you can then simply initiate message extraction
with the following commands (otherwise you'll have to provide the configuration file as the first argument):

<pre><com>C:\Project\HelloWorld&gt;</com>mkdir lang

<com>C:\Project\HelloWorld&gt;</com>touch lang\FR_fr.po

<com>C:\Project\HelloWorld&gt;</com>msgextract
parsing .\Hello.c...
1 file processed for message translation.
FR_fr.po updated: 1 added, 0 commented, 0 untouched.

<com>C:\Project\HelloWorld&gt;</com>
</pre>

<p>The way <tt>msgextract</tt> works is to extract every strings from each folder directive of every
section within the configuration file (in case your application is spread over multiple directories).
It will then load each translation files from the <tt class="t">Lang</tt> folder, and add messages that
are missing in catalog and comment those that are no more referenced. That's why we created an empty
language file before starting the extraction. The resulting file <tt>lang\FR_fr.po</tt> looks like:

<pre><com># NEW MESSAGES</com>
<kwd>msgid</kwd> <val>"hello, world"</val>
<kwd>msgstr</kwd> <val>""</val></pre>

<p>Which is basically empty. You'll now have to fill every <tt class="k">msgstr</tt> directive that have
an empty string associated (remember to have your file encoded in UTF-8). Here we choose to use the
ISO 3166 code for french, so a possible translation would be:

<pre><kwd>msgid</kwd> <val>"hello, world"</val>
<kwd>msgstr</kwd> <val>"bonjour, tout le monde"</val></pre>

<p>For the <tt>LangStr()</tt> function, an empty string is the same as a missing string: the original
pointer you provided will be returned in that case. Once this language file has been filled, you can
then load it at the beginning of the application (or at least, before calling the <tt>LangStr()</tt>
function).

<p>Note that PO files parsed by the <tt>UtilityLib</tt> provide an extension: it allows you to include
another translation file through the <tt>#include</tt> directive. This directive must be followed by
the path of the file, without quote, relatively to language file where the directive is in. A over-typical
application for this is to have catalogs for countries with the same basic language, but with small
variations, like British english versus American english, or french versus Canadian french, etc...

<h3 id="loadmsgs"><span>Loading translation file</span></h3>

<p>Once your language file is done, you can load it. Here, there is a little simplification compared
to the original <tt>gettext()</tt>: <tt>gettext</tt> package handle two file formats: the portable
object format (PO: the one you edit to translate your messages) and the machine object (MO: the one
loaded by your application), which is a compiled form of the PO file. The utility library can actually
load PO files directly, there is no need for MO files at all. This is done through this function:

<pre>Lang LangParse(STRPTR path);</pre>

<p>The path (UTF-8 encoded) will have to be built using the locale information from the <tt>SIT_APP</tt>
widget and the convention you use earlier to create your translation file. Since we use the ISO 3166 code,
the hello world application can now be updated that way to include full support for internationalization:

<pre><com>/*
 * exampleSDL.c : small example showing how to integrate SITGL with SDL
 *
 * Written by T.Pierron, May 2020
 */</com>

<def>#include </def><val>&lt;stdio.h&gt;</val><def>
#include </def><val>&lt;SDL/SDL.h&gt;</val><def>
#include </def><val>"nanovg.h"</val><def>
#include </def><val>"SIT.h"</val>

<def>#define</def><inc> SCREENWIDTH  500</inc><def>
#define</def><inc> SCREENHEIGHT 200</inc>
<type>int</type> main(<type>int</type> nb, <type>char</type> * argv[])
{
	<com>/* initialization is identical */
	/* ... */

	/* this is what is needed to activate translation */</com>
	LocaleInfo info;
	<type>char</type> path[<val>32</val>];

	SIT_GetValues(app, SIT_LocaleInfo, &amp;info, <val>NULL</val>);
	sprinf(path, <val>"lang/<spe>%s</spe>.po"</val>, info->iso3166);
	LangParse(path);

	SIT_CreateWidgets(app, <val>"&lt;label name=hello title="</val>, _(<val>"Hello, world!"</val>), <val>"&gt;"</val>);

	<com>/* remaining is identical */
	/* ... */</com>
}
</pre>

<p>In that case, we don't care about the return code of <tt>LangParse</tt>, because if it succeeds,
<tt>SITGL</tt> will keep a reference, and if it fails, all function call to <tt>LangStr()</tt> will
return the  first argument. We used the abridged form of this function in the example above: the
<tt>_</tt> function is defined like this:

<pre>#define _(str)              LangStr(NULL, str)</pre>


<h3 id="advi18n"><span>Advanced features</span></h3>

<p>There are a few more features to be aware in order to be to able to handle real world applications.

<h4>Dummy strings</h4>

<p>When writing an application, it often arrives that a few static tables are declared in the global
scope, that contains some strings that you want to be translated:

<pre><type>static STRPTR</type> errorMsgs[] = {
	<val>"<spe>%s</spe> cannot be loaded"</val>,
	<val>"need opengl 3+, missing function <spe>%s</spe>"</val>,
	<val>"nanovg context creation failed"</val>,
	<val>"cannot locate file <spe>%s</spe>"</val>
};
</pre>

<p>The items of such tables cannot be enclosed by <tt>_()</tt>, in order to be automatically recognized
by the <tt>msgextract</tt> tool. To still allow this tool to extract all messages to be translated,
there is a special macro that actually does nothing but permits the <tt>msgextract</tt> tool to do its
work:

<pre><spe>#define	D_(str)             str</spe></pre>

<p>Since a typical configuration for <tt>msgextract</tt> is to extract everything between <tt>_("</tt>
and <tt>")</tt>, this simple macro does the job. However, your structure won't be translated: after
reading your language file, you'll have to manually modify each field that got marked. You usually
only have to do this at startup. For menu structure, like the one above, you can use the following code:

<pre><kwd>for</kwd> (i = <val>0</val>; DIM(errorMsgs); i ++)
	errorMsgs[i] = _(errorMsgs[i]);</pre>

<p>Remember that despite we used the abridged version of <tt>LangStr()</tt>, it won't be recognized by
the <tt>msgextract</tt> utility, because it has been configured to extract everything between <tt>_("</tt>
and <tt>")</tt>. You might also notice that since we are overwriting the global structure, this type
of construct does not allow changing the language at runtime.

<h4>Handling plural form</h4>

<p>Plural usually involve displaying a quantified noun, while trying to have a grammatically correct
sentence for every possible values. Back in the days nobody gave a damn about plural form, you got
something along the line: <tt>"%d file(s) processed"</tt> for every values of <tt>%d</tt>, and usually
something even worse for other languages. If you want to display something more user-friendly, a little
bit of work is needed.</p>

<p>We used to distinguish 3 cases for handling plural form: no quantity, singular and plural. Each of
these cases mean they will have a dedicated message. If the quantity to display is zero, it might be
wise to consider removing the message completely if the message does not have any value. For example
if you want to display some information on selected items and if there is nothing selected, just don't
display anything. On the other hand, if this message is the result of a lengthy operation, it might
still be interesting to display it, just to signal to the user that something has been done, but there
is no results to display.

<p>Also don't try to programmatically build sentences to accommodate plural form, like this:

<pre>fprintf(<val>stderr</val>, <val>"<spe>%d</spe> file<spe>%s</spe> processed.<spe>\n</spe>"</val>, n, n == <val>1</val> ? <val>""</val> : <val>"s"</val>);</pre>

<p>This is impossible to translate properly, since most languages have a
more complex plural form than that, where more than one word can be
impacted.</p>

<p>The function to deal with plural is declared like this:</p>

<pre><type>STRPTR</type> LangStrPlural(Lang lang, <type>int</type> nb, <type>STRPTR</type> sing, <type>STRPTR</type> plur);</pre>

<p>And is usually abridged the following way:</p>

<pre><spe>#define	_N(n, sing, plur)   LangStrPlural(<val>NULL</val>, n, sing, plur)</spe></pre>

<p>If you used literal strings as arguments to this function, you will notice
that they will not be recognized by <tt>msgextract</tt> utility. You'll have
to enclose them with a dummy declaration. Take also note that no quantity
case is not handled by this function, you'll have to add special processing
if you ever plan to handle that case.</p>




<h2 class="annex" id="annexA"><span>UtilityLib API</h2>

<p>This library contains some utility functions that you might find useful at some point. The set of
functions comes mostly from what's needed by <tt>SITGL</tt> itself. This part has never been intended
to fill all the gap missing from the standard C library, since this is a nebulous target and highly
susceptible to feature creep.

<p>One of those group of functions was already covered in the <a href="#i18n">internationalization</a>
chapter, here are the remaining:

<h3 class="annex" id="doublelink"><span>Double-linked list</span></h3>

<p>UtilityLib will provide a set of functions to manage a double-linked list. The list is managed through
2 datatypes: one header which gather general info on the list (head, tail, number of items) and a list
node that is inserted into all objects themselves (it is a simple prev/next record). This module will
<b>not</b> allocate anything on its own: the typical use case for this is to declare the types as value
into some bigger struct and allocated the memory for the list at the same time than the objects.

<p><span class="n">Note</span>: single-link list are trivial enough to be implemented on the spot,
therefore there will be no helping functions in this module.

<p>For this very simple module, direct access to datatypes is allowed. Public fields for the list header are:

<pre><type>struct</type> ListHead_t
{
	  ListNode * lh_Head;
	  ListNode * lh_Tail;
};
<type>typedef struct</type> ListHead_t     ListHead;</pre>

<p>This datatype is intended to be <b>declared as a value</b>, not pointer. To initialize it, just memset() it
with 0 or use ListNew() macro.

<p>The other datatype has to be <b>declared in each item</b> you may want to insert
in the list. Again, you have to declare it as value, not as pointer:

<pre><type>struct</type> ListNode_t
{
	  struct ListNode_t * ln_Next;
	  struct ListNode_t * ln_Prev;
};
<type>typedef struct</type> ListNode_t    ListNode;</pre>

<p>Even though the fields are public, more often than not, it is accessed <b>through the use of the macros</b>
<tt>HEAD(list)</tt>, <tt>TAIL(list)</tt>, <tt>NEXT(node)</tt> or <tt>PREV(node)</tt>.

<p><tt>HEAD</tt> and <tt>TAIL</tt> are used to initiate a forward/backward scan of the list. The <b>expected
argument is a value</b>, not a pointer. Obviously, if you started with the head of list, you'll want
to scan the items using the <tt>NEXT</tt> macro, otherwise use <tt>PREV</tt>.

<p>The <tt>NEXT</tt> and <tt>PREV</tt> macros will suppose that the <tt>ListNode</tt> struct <b>is
declared as the first field</b>, so that your <em>node</em> objects can be cast as <tt>ListNode *</tt>.
If that is not the case, those macros cannot be used.

<p>If the node struct has been declared as your first field, you can then iterate over them using a
loop like this:
<pre><type>struct</type> MyObject_t * object;
<kwd>for</kwd> (object = HEAD(parent->list); object; NEXT(object))
{
	<com>/* process &lt;object&gt; here... */</com>
}</pre>

<hr>

<p>It will sometimes happen that a single object is part of <b>several double-linked lists</b>, and therefore
have multiple <tt>ListNode</tt> components embedded. For the node struct that are not declared as first
field, here is the recommended strategy you can use. For example, let's assume the following datatypes:
<pre><type>struct</type> Parent_t
{
	ListHead redItems;
	ListHead blueItems;
	<com>/* ... */</com>
};
<type>struct</type> Node_t
{
	ListNode redNode;
	ListNode blueNode;
	<com>/* ... */</com>
};</pre>

<p>You can add items in the <Tt>blueItems</tt> list, like you would for the <tt>redItems</tt> list,
using something like this:
<pre>ListAddTail(&amp;parent->blueItems, &amp;node->blueNode);</pre>

<p>All the macros will now give you a pointer to the start of the <tt>blueNode</tt> field, which is
<b>not the start of your struct</b>. Attempting to access any fields of the <tt>Node_t</tt> struct at this
point will likely cause a segmentation fault. To prevent this, the scanning loop can be slightly
altered like this:
<pre>ListNode * node;
<kwd>for</kwd> (node = HEAD(parent->blueItems); node; node = node->blueNodes.ln_Next)
{
	<type>struct</type> Node_t * object = START_OF(node, <type>struct</type> Node_t *, blueNode);

	<com>/* process &lt;object&gt; here... */</com>
}</pre>

<p>This is a little bit verbose, but since it is not a very common use case, the overhead is somewhat
acceptable. In this case, you might also want to consider using a single-linked list. If you do not
need backward scan and the slight penalty cost for adding/removing item is not an issue, then using
a double-linked list might not be the right solution.

<hr>

<p>For reference, here is a quick summary of all the functions related to double-linked list manipulation:
<ul>
  <li><tt class="dt">void ListAddHead(ListHead *, ListNode *);</tt>,<br><tt class="dt">void ListAddTail(ListHead *, ListNode *);</tt>
  <p>Add an item at the beginning/end of the list.
  <li><tt class="dt">void ListInsert(ListHead *, ListNode * item, ListNode * insert_after);</tt>
  <p>Insert item at an arbitrary position. <tt>insert_after</tt> must be part of the list, otherwise
  bad thing will happen (you can expect a segmentation fault at some point). If <tt>insert_after</tt>
  is <tt class="o">NULL</tt>, insert will happen at the beginning. To insert at the end, use the <tt>lh_Tail</tt>
  field in the <tt>ListHead</tt>. To do an insert before, assuming <tt>insert_after</tt> is not <tt class="o">NULL</tt>,
  simply deference the <tt>ln_Prev</tt> field of the node.

  <li><tt class="dt">void ListInsertSort(ListHead *, ListNode *, ListSortFunc);</tt>
  <p>Insert an item based on an order function.

  <li><tt class="dt">void ListSort(ListHead *, ListSortFunc);</tt>
  <p>Rearrange the list so that all items are sorted using the given callback. The algorithm used in
  this function is the insert sort, which is a O(n&#xb2;) complexity in the worst case (and probably
  on average too). So not the best, but for small lists, this is largely enough. If performance matters,
  you should use an array and apply the libc standard function <tt>qsort()</tt>.

  <li><tt class="dt">void ListRemove(ListHead *, ListNode *);</tt>
  <p>Remove an item from the list. The item has to be in the list, otherwise segfault pending.

  <li><tt class="dt">ListNode * ListRemHead(ListHead *);</tt>,<br><tt class="dt">ListNode * ListRemTail(ListHead *);</tt>
  <p>Remove the first/last element of the list. If the list is empty, <tt class="o">NULL</tt> will be
  returned.
</ul>

<h3 class="annex" id="dosaccess"><span>DOS access</span></h3>

<p>This is a small module to provide access to the filesystem using functions that supports UTF-8
encoding, without having to deal with the operating system native API calls. Most of these functions
are straightforward, but here is the complete list:
<ul>
  <li><tt class="dt">int ScanDirInit(ScanDirData * ret, STRPTR path);</tt>,<br>
  <tt class="dt">int ScanDirNext(ScanDirData * ret);</tt>,<br>
  <tt class="dt">void ScanDirCancel(ScanDirData * ret);</tt>

  <p>Scan (almost) all entries of a directory. By "mostly" all entries, it will automatically <b>remove
  <tt>.</tt> and <tt>..</tt></b>. You can assume they always exist.

  <p>The <tt>ScanDirData</tt> is declared this way:
  <pre>
<type>struct</type> ScanDirData_t
{
	<type>APTR</type>     path;
	<type>int</type>      isDir;
	<type>uint64_t</type> size;
	<type>TEXT</type>     date[<val>24</val>];
	<type>STRPTR</type>   type;
	<type>STRPTR</type>   name;
	<type>APTR</type>     handle;
	<type>int</type>      error;
};
</pre>
  <p>Each fields have the following meaning:
  <ul>
    <li><tt>path</tt>: private, do not modify.
	<li><tt>isDir</tt>: 1 if the object returned is a directory, 0 otherwise.
	<li><tt>size</tt>: size in bytes of the file (always 0 for directories).
	<li><tt>date</tt>: last modification date, using ISO-8601 format (YYYY-MM-DD HH:MM:SS), using local
	timezone.
	<li><tt>type</tt>: human readable string describing file type. UTF-8 encoded. On Windows, this is
	the same string displayed by the file explorer "Type" column.
	<li><tt>name</tt>: name of the object, UTF-8 encoded.
	<li><tt>handle</tt>: private, do not modify.
	<li><tt>error</tt>: if there was an error while reading the directory content this field will
	contain a positive integer. Use <tt>GetErrorMsg()</tt> to get a human readable description of the
	error.
  </ul>

  <p>The typical way to use these functions is:
  <pre>ScanDirData args;
<type>STRPTR</type> path = <val>"."</val>;
<kwd>if</kwd> (ScanDirInit(&amp;args, path))
{
	<kwd>do</kwd>
	{
		<com>/* process args */</com>
		...

		<com>/* if something went wrong and want to immediately terminate the loop, use this function: */</com>
		<kwd>if</kwd> (<com>/*error condition*/</com>)
		{
			ScanDirCancel(&amp;args);
			<kwd>break</kwd>;
		}
	}
	<kwd>while</kwd> (ScanDirNext(&amp;args));
}
</pre>

  <p><span class="n">Note</span>: memory will be allocated by <tt>ScanDirInit()</tt> (if it returns a
  non-zero value) and will be freed by either <tt>ScanDirCancel()</tt> or <tt>ScanDirNext()</tt> (when
  it returns 0). <b>Do not use the content of the struct after that</b>.

  <li><tt class="dt">Bool AddPart(STRPTR dir, STRPTR file, int max);</tt>
  <p><b>Concatenate partial path</b> <tt>file</tt> into <tt>dir</tt>. The <tt>dir</tt> buffer must be
  large enough to contain <tt>max</tt> bytes. If the resulting is bigger than this, the path will be
  truncated and the function will return <tt class="o">False</tt>. Obviously, the <tt>dir</tt> string
  must contained a valid, NULL-terminated string in the first place.

  <li><tt class="dt">Bool ParentDir(STRPTR path);</tt>
  <p><b>Remove the last component of a path</b>, or returns <tt class="o">False</tt> if there are
  nothing to remove.

  <li><tt class="dt">Bool IsDir(STRPTR path);</tt>
  <p>Returns <tt class="o">True</tt> if the path point to a directory. Root file system like <tt>C:\</tt>
  are considered directories.

  <li><tt class="dt">STRPTR CreatePath(STRPTR path, Bool not_last);</tt>
  <p>Will <b>create all the missing directories</b> from <tt>path</tt>. If <tt>not_last</tt> is <tt class="o">True</tt>,
  the last component of the path will not be created as a directory. The typical use case for this
  function is to call it just before attempting to open a file for writing (if you know that some
  directories might be missing).
  
  <p>In case of an error, it will return a pointer within <tt>path</tt> that failed to be created.
  If all went well, <tt class="o">NULL</tt> will be returned.

  <li><tt class="dt">STRPTR BaseName(STRPTR path);</tt>
  <p>Return the <b>last component</b> of a path, which is typically the file name.

  <li><tt class="dt">ULONG TimeStamp(STRPTR path, int type);</tt>
  <p>Return <b>various date</b> from the given path as a timestamp, depending on what value was given to <tt>type</tt>:
  <ul>
	<li><tt>0</tt>: creation time.
	<li><tt>1</tt>: access time (value might not be accurate though, depending on the file system).
	<li><tt>2</tt>: modification time.
  </ul>
  <p>Return value will be number of seconds since the unix epoch (Jan 1, 1970).

  <li><tt class="dt">int Execute(STRPTR cmd, int timeout);</tt>
  <p>Will <b>execute the given command with its arguments</b>. If the path of the command contains spaces,
  it is advised to enclose the string with double quotes, same with arguments, otherwise they will be
  split into different parts inside the <tt>argv[]</tt> table of the command. <span class="n">Note:</span>
  the string will not be interpreted by the command line tool (like <tt>cmd.exe</tt>), therefore
  some shortcuts won't work: wildcard path expansion, automatic command extension (automatically adding
  <tt>.exe</tt> or <tt>.com</tt> to the command name), file redirection, and so on...
  
  <p><tt>timeout</tt> can have the following values:
  <ul>
	<li><tt>-2</tt>: don't wait for the command to finish, return immediately.
	<li><tt>-1</tt>: wait forever.
	<li>&gt; 0: wait the specified amount of <b>millisecond</b>. If the command hasn't finish by then, it
	will be forcibly terminated.
  </ul>

  <p>Return code for this function is the <b>return code of the command</b>, usually 0 if everything went well.
  -1 is returned if the process failed to be created. <tt>0xbad</tt> will be returned if the process
  was terminated before its end. <tt>0</tt> will be returned if you didn't wait for the process to
  terminate.
  
  <p><span class="n">Note</span>: on Windows, it uses the Win32 <tt>CreateProcessW()</tt> API call.

  <li><tt class="dt">int OpenDocument(STRPTR filename);</tt>
  <p>Try to <b>open the file</b> given as argument with the <b>default application</b> associated with it. The
  typical use case is to open an HTTP link using the default web browser, but it works with any type
  of file (including directories). On Windows, this function will be like double-clicking on a file
  in the explorer: if no applications has been registered for a given file type, a popup asking the
  user what to do with the file will be showed instead.

  <li><tt class="dt">ULLONG FileSize(STRPTR path);</tt>
  <p>Return the <b>size of the file</b> as a 64bit unsigned integer (<tt class="t">uint64_t</tt>).
  If there was an error, 0 will be returned.

  <li><tt class="dt">Bool DeleteDOS(STRPTR path);</tt>
  <p>Attempt to <b>delete the file/directory</b>. For a directory, it needs to be empty before hand, otherwise
  an error will be returned.

  <li><tt class="dt">Bool FileExists(STRPTR file);</tt>
  <p>Check if the given file exist.
  
  <li><tt class="dt">Bool FileRename(STRPTR from, STRPTR to, Bool overwrite);</tt>
  <p><b>Rename a file and/or move it</b> somewhere else. If the <tt>from</tt> parameter contains a directory
  structure, the same structure must be present in the <tt>to</tt> parameter for the file to not be
  moved. In case the destination is located on a different drive, the file will first be copied, then
  the original will be deleted.

  <li><tt class="dt">Bool FileCopy(STRPTR from, STRPTR to, Bool overwrite);</tt>
  <p><b>Copy the file and everything associated with it</b> (including NTFS alternate data stream for example).

  <li><tt class="dt">Bool IsSameFile(STRPTR file1, STRPTR file2);</tt>
  <p>Check if two semmingly different path point in fact to the same file. Useful if you have a relative
  and absolute path, and want to know if they are the same.

  <li><tt class="dt">Bool IsRelativePath(STRPTR file);</tt>
  <p>Check if the path is relative, ie: will depend on current working directory.

  <li><tt class="dt">Bool TruncateFile(STRPTR file, uint64_t offset);</tt>
  <p>Standard libc (stdio) does not have a function to truncate a file: it is advised to close any
  file handle before using this function.

  <li><tt class="dt">STRPTR ExpandEnvVar(STRPTR str);</tt>,<br>
	  <tt class="dt">void ExpandEnvVarBuf(STRPTR str, STRPTR utf8, int max);</tt>
  <p><b>Expand environment variables</b> within <tt>str</tt> to their actual value. The syntax for variable
  names must be <tt>%<em>varname</em>%</tt>. Names are not case sensitive, on Windows at least.

  <p>These functions are somewhat similar to <tt>getenv()</tt>, except it will do the concatenation
  for you. Typical use case, is to expand to user data directory using <tt>%appdata%</tt> variable.
  Check the <tt>env</tt> command line utility to have a list of pre-defined variables.
  
  <p><span class="n">Note</span>: return value will be <tt>malloc()</tt>'ed. You'll have to free the
  string yourself. If your application is linked against the standard <tt>msvcrt.dll</tt>, you can
  use the normal <tt>free()</tt> function, otherwise use <tt>SIT_Free()</tt>.

  <li><tt class="dt">void * fopen_enc(const char * file, const char * mode);</tt>
  <p>This function is a <b>replacement for the stdio <tt>fopen</tt> function</b>: it will allow you to use
  UTF-8 path as argument. To prevent unexpected side-effect, it will be your duty to redirect the
  call to <tt>fopen()</tt>, using a define like this in your application's code:
  <pre>#define fopen     fopen_enc</pre>

  <p>Return code is actually a <tt>FILE *</tt>. The reason it was declared as a void pointer, was to
  prevent including stdio header from <tt>UtilityLibLite.h</tt>.

  <li><tt class="dt">void GetErrorMsg(int code, STRPTR buffer, int max);</tt>,<br>
	  <tt class="dt">int GetErrorCode(void);</tt>,<br>
	  <tt class="dt">STRPTR GetError(void);</tt>
  <p>If an error occur with any of the DOS function, you can get a <b>more detailed reason</b> using one of
  these functions. <tt>GetErrorMsg()</tt> will require you to allocate the memory to hold the message,
  while <tt>GetError()</tt> will use a small (128 bytes) static buffer. The message will be UTF-8
  encoded, using the current localization of the operating system.

</ul>

<h3 class="annex" id="multithread"><span>Multi-thread</span></h3>

<p>These set of functions will allow you to create threads and the typical synchronization objects like
mutexes and semaphores. Be extremely careful with these functions, multi-thread and OpenGL don't mix
very well. OpenGL requires a context per thread, which none of these functions will allocate. Your
windowing framework might provide such facility (like SDL2 and GLFW), and in that case in might be
better to use the functions provided by these instead of <tt>SITGL</tt>.

<p>Keep in mind, if you are using these functions, <b>you must not call any OpenGL functions in the
threads</b>. This is usually way harder than it seems and will require some careful synchronization
with the main thread in order to work properly.

<p>Using correctly all the functions listed here is way harder than it seems. Entire books have been
written about this topic, this documentation will not pretend to replace them. If this is the first
time you are dealing with multi-threading, it is more than strongly advised to familiarized yourself
with this topic in much more depth, than what is explained in here.


<ul>
  <li><tt class="dt">Thread ThreadCreate(ThreadCb func, APTR arg);</tt>
  <p><b>Starts a new thread</b> with the given function to execute. This function needs to have the
  following prototype:
  <pre>void func(void * arg);</pre>
  <p><tt>arg</tt> will be the same value than the one given to the <tt>ThreadCreate()</tt> function.
  <p>If successful, a non-zero number will be returned. At this point, the thread will be already
  running and address space will be shared with main thread. The thread won't be a software hack:
  it will be a real thread handled by the operating system, and therefore possibly running on
  different CPU core, with all the synchronization problems it comes with it.

  <p><span class="n">Note</span>: the <b>recommended way to stop a thread</b>, is to let it exit gracefully.
  In this library, there are no function to forcibly kill a thread. You'll need to setup some synchronization
  points with a shared state that indicate when the thread has to exit, and wait for it.

  <li><tt class="dt">void ThreadPause(int delay);</tt>
  <p><b>Pause the calling thread</b> for the specified amount of milliseconds. The timer used for this delay
  is a low precision timer, tied to the context switch delay. On Windows, with a default configuration,
  the precision will be around 10 to 15ms.

  <li><tt class="dt">Mutex MutexCreate(void);</tt>
  <p>A mutex is used to create a <b>critical section</b> where only one thread is allowed to enter at a time.
  The typical use case is to protect a global variable, <b>if it is modified by a thread</b>. If the
  variable is only read, no need to protect the access.
  
  <li><tt class="dt">void MutexEnter(Mutex);</tt>,<br>
	  <tt class="dt">void MutexLeave(Mutex);</tt>,<br>
	  <tt class="dt">Bool MutexTryEnter(Mutex);</tt>
  <p>Enter/leave a critical section. Be careful that every call to <tt>MutexEnter()</tt> or
  <tt>MutexTryEnter()</tt> is followed by a <tt>MutexLeave()</tt>, otherwise every subsequent thread
  that will attempt to enter the section will block indefinitely. If a mutex is currently locked,
  any other attempt to call <tt>MutexEnter()</tt> will block until <tt>MutexLeave()</tt> is called
  by the thread owning the lock. If multiple thread are waiting to be released, the order by which
  thread are awaken is undefined, and can lead to thread starvation.
  
  <p><tt>MutexTryEnter()</tt> will get ownership of the lock is it returns <tt class="o">True</tt>.
  If it cannot, <tt class="o">False</tt> will be returned and the lock will remain unchanged.

  <li><tt class="dt">void MutexDestroy(Mutex);</tt>
  <p>If the lock is no longer needed, you can free its resource with this function. Keep in mind,
  you'll have to make sure that all the other threads do not have a pending lock on it before freeing
  it, otherwise a segmentation fault is pending.


  <li><tt class="dt">Semaphore SemInit(int count);</tt>
  <p>Create a semaphore object. The purpose of a semaphore is to handle a producer/consumer model.
  The integer in the semaphore represent the amount of resources available. When attempting to grab
  a resource when the count is zero, it will block until it is increased by the producer (using
  <tt>SemAdd()</tt> function).
  
  <p>Technically a semaphore can be implemented using two mutexes and one integer. But since they
  quite common, a standard interface will spare you the hassle of writing that logic.

  <li><tt class="dt">Bool SemWait(Semaphore);</tt>,<br>
	  <tt class="dt">Bool SemWaitTimeout(Semaphore, ULONG ms);</tt>
  <p>Attempt to grab one resource from the semaphore. Will decrease the internal count by 1. If the
  count is zero, it will wait indefinitely. To prevent this, you can use the <tt>SemWaitTimeout()</tt>
  to periodically check if the thread need to exit prematurely.

  <li><tt class="dt">void SemAdd(Semaphore, int count);</tt>
  <p>Add the specified amount to the semaphore. <tt>count</tt> cannot be negative though. Any thread
  currently waiting will be awaken, the order is unspecified and just like mutexes, can lead to thread
  starvation.

  <li><tt class="dt">void SemClose(Semaphore);</tt>
  <p>Free the resource associated to the semaphore. Like with mutexes, you'll have to be sure no
  other threads are currently waiting on it, otherwise a segmentation fault is probably pending.
</ul>

<hr>

<p>Here is a simple example on how to use these functions: suppose you have a button in your interface
that can potentially starts a lengthy operation. You don't want to do that operation inside the
<tt>SITE_OnActivate</tt> event, because the interface will be completely frozen while the operation
is running (especially, you might want to keep a cancel button accessible in the meantime).

<p>Therefore, in the <tt>SITE_OnActivate</tt> event, you'll need to start a thread (using <tt>ThreadCreate()</tt>).
That thread function should write in a <b>global variable</b>, the progress of its work in one form
or another. If the work cannot be measured easily, at least you'll need to set a boolean to indicate
when the function has finished. <b>Be careful though!</b> Remember that threads created by <tt>SITGL</tt>
<b>cannot</b> call any OpenGL functions whatsoever (which also includes any SITGL function).

<p>Once the thread has been started, you'll have to monitor that global variable to know when the function
has finished (and possibly report progress using a <a href="#SIT_PROGRESS">SIT_PROGRESS</a> control).
For this, you can use asynchronous event, using the <tt>SIT_ActionAdd()</tt> function. Therefore the
whole process should looks something like this:

<pre>
<com>/* global variable used to report progress by the thread */</com>
<type>static int</type> progress;

<com>/* this function will run in a separate thread */</com>
<type>static void</type> myCostlyOperation(<type>void</type> * unused)
{
	<type>int</type> i;
	<kwd>for</kwd> (i = <val>0</val>; i &lt; <val>100</val>; i ++)
	{
		<com>/* this is the costly work */</com>
		ThreadPause(<val>500</val>);

		<com>/* report progress <b>/!\ don't call any SITGL function here</b> */</com>
		progress ++;
	}
}

<com>/* this is function that will check the thread progress */</com>
<type>static void</type> myProgressCheck(SIT_Widget w, <type>APTR</type> cd, <type>APTR</type> ud)
{
	<kwd>if</kwd> (progress == <val>100</val>)
	{
		<com>/* thread has finished */</com>
		SIT_CloseDialog(w);
		<com>// Alternatively, you can reenable the button if the dialog isn't closed
		// SIT_SetValues(w, SIT_Enabled, True, NULL);</com>
		
		<com>/* stop the timer now */</com>
		<kwd>return</kwd> -<val>1</val>;
	}

	<com>/* report progress to your interface */
	// SIT_SetValues(progress, SIT_ProgressPos, progress, NULL);</com>
	<kwd>return</kwd> <val>0</val>;
}

<com>/* SITE_OnActivate callback */</com>
<type>static void</type> handleButton(SIT_Widget w, <type>APTR</type> cd, <type>APTR</type> ud)
{
	<com>/* you don't want to start the operation again, while one is running */</com>
	SIT_SetValues(w, SIT_Enabled, <val>False</val>, <val>NULL</val>);

	<com>/* this is where the work will be done */</com>
	progress = <val>0</val>;
	ThreadCreate(myCostlyOperation, <val>NULL</val>);

	<com>/* asynchronous callback that will on the thread progress */</com>
	double curTime = FrameGetTime();
	SIT_ActionAdd(w, curTime, curTime + <val>1e9</val>, myProgressCheck, <val>NULL</val>);
}</pre>

<p>This is a very simple approach though: it supposes that resources used by the thread are independant
from the user interface, and there are no logic to cancel the operation once it is started. As simple
as this approach is, you can already see that there is <b>quite a bit of work involved</b>, therefore
you should only consider adding such a feature if it is really worth it.

<p>Adding a <b>cancellable operation</b> will involve a bit more work. You might have noticed that there
are no functions to immediately stop a thread. More often than, forcibly stopping a thread is a bad idea,
because it will be extremely likely that the thread have allocated some resources, that will need to be
freed before exiting.

<p>To do this, first you have to add a global variable that has to be monitored by the thread to know
if it has to exit immediately. You don't have to do this in the inner loop, but as long as it done every
couple of milliseconds, it will be largely enough. <b>To know when the thread has exited</b>, you can use a
mutex: create one before starting the thread. In the thread, lock that mutex immediately and release
it only at the very end. If you want to cancel the operation, simply set that global variable to
notify the thread to exit immediately and then attempt to lock and then unlock the mutex: once unlocked
you know the thread has exited.


<h3 class="annex" id="timer"><span>Timer functions</span></h3>

<p>This will provide a set of functions to implement high precision timer: wait for a specified amount
of time down to the millisecond range and get current time down to the microsecond range.

<p><span class="n">Note</span>: avoid storing timestamp in <tt class="t">float</tt> datatype. You'll only
have 4 hours and 40 minutes before running out of precision (at the millisecond range, after that time
the precision will drop to 2 milliseconds). You can store them in integer (and losing the fractional part):
a timestamp down to the millisecond range is not too bad for timing purpose. Using this type, you'll have
between about 25 days (<tt class="t">signed</tt>) and 50 days (<tt class="t">unsigned</tt>) before timer
wraps around. The recommended datatype is <tt class="t">double</tt> though (with 285616 years before
there will be a loss of precision at the millisecond range).

<p><span class="n">Note</span>: on Windows, these functions are based on the <tt>QueryPerformanceCounter()</tt>
API.

<ul>
  <li><tt class="dt">void FrameSetFPS(int fps);</tt>
  <p>Before you can use <tt>FrameWaitNext()</tt>, you need to initialize the targeted frame per
  second you want. This function can be called at any point, but this is usually done before the main
  event loop starts.

  <li><tt class="dt">void FrameWaitNext(void);</tt>
  <p>This function will wait until the remainder of the frame time window. It will attempt to do a
  graceful (ie: CPU yielding) wait first, then if there is not enough time left, it will do an active
  loop. This usually happen if the delay up to the next frame is below 10ms.

  <p>This function is usually called last in the event processing loop.

  <li><tt class="dt">double FrameGetTime(void);</tt>
  <p>This will give the time in millisecond, double precision format. The precision of this function
  should be at least 1 microsecond. The origin of the epoch is when <tt>SIT_Init()</tt> was called
  (it is not from an arbitrary fixed point in time).

  <li><tt class="dt">void FramePauseUnpause(Bool pause);</tt>
  <p>If you have to implement a pause menu, you'll need to ignore the time spent while the engine
  is paused, otherwise any actions based on time interval will be messed up. The idea is to call this
  function with the pause parameter set to <tt class="o">True</tt> at the start of the pause, then set
  to <tt class="o">False</tt> at the end. That way, the <tt>FrameGetTime()</tt> function will return
  an (almost) monotonic increase of the time, without any gaps, as if the pause never happened.

  <p>While pause is on, the <tt>FrameGetTime()</tt> will always report the same value. <tt>FrameWaitNext()</tt>
  will work as normal though.

  <li><tt class="dt">void FrameSaveRestoreTime(Bool save);</tt>
  <p>If you want to display a temporary screen on top of your scene, that will need to stop the time
  while being displayed, the function <tt>FramePauseUnpause()</tt> might be too drastic: it will stop
  the time advance in the entirety of <tt>SITGL</tt>. That means asynchronous updates and animation
  will stop working.

  <p>What this function will do, is save the current time (as returned by <tt>FrameGetTime()</tt>), when
  the <tt>save</tt> parameter is set to <tt class="o">True</tt>, and then restore this value when this
  parameter is set to <tt class="o">False</tt>. In the meantime, the <tt>FrameGetTime()</tt> will return
  a normal advance of time. Obviously, you'll need extra logic in your main loop to avoid using that
  function. Extra logic that will not needed if you use the function <tt>FramePauseUnpause()</tt>.

</ul>

<h3 class="annex" id="utility"><span>Utility functions</span></h3>

<p>A few more general functions/macros are available. Here is the complete list:

<ul>
  <li><tt class="dt">void GetSelectionColor(DATA8 fg, DATA8 bg);</tt>
  <p>Will retrieve the default foreground and background selection color. The <tt>-selection</tt> CSS
  attribute will have its initial value set to these. Usually custom widgets will need those
  values at some point or another. <span class="n">Note</span>: the arguments must actually point to
  a valid buffer that can hold at least 4 bytes, it will encode the R, G, B, A component of the
  specified color (ie: can be then passed to the functions like <tt>nvgFillColorRGBA8()</tt> or
  <tt>nvgStrokeColorRGBA8()</tt>).

  <li><tt class="dt">void CopyString(STRPTR destination, STRPTR source, int max);</tt>
  <p>A <tt>strncpy()</tt>-like function without nasty surprises: it will attempt to copy <tt>source</tt>
  into <tt>destination</tt>, while writing at most <tt>max</tt> bytes. The destination string will always be
  <tt>NULL</tt>-terminated. Also, UTF-8 sequence will be cut correctly if it the sequence does not fit
  fully in the buffer (it supposes that those sequences are correctly encoded in the first place though).

  <p>This function is not really designed for performance: it only copies one character at a time,
  but for short strings, this is usually more than enough.

  <li><tt class="dt">int StrCat(STRPTR dest, int max, int pos, STRPTR cat);</tt>
  <p>The purpose of this function is to build a more complex string in pieces, concatenating each one,
  using a fixed size buffer, while ensuring there will be no buffer overflow. The arguments work as follows:
  <ul>
	<li><tt>dest</tt>: must <b>always</b> point to the start of the fixed size buffer.
	<li><tt>max</tt>: how many <b>bytes</b> fits in this buffer. Usually should be the result of a sizeof operator.
	<li><tt>pos</tt>: position where to start looking for the end of <tt>&lt;dest&gt;</tt>. Usually,
	this is the value returned by a previous call of this function. If you do not care to track that
	information, you can give <tt class="o">0</tt> as value, at the price of having a potentially
	quadratic complexity (but for small strings, this can be acceptable).
	<li><tt>cat</tt>: the <tt class="o">NULL</tt>-terminated string to add at the end of <tt>&lt;dest&gt;</tt>.
  </ul>
  <p>The return value will the position of the <tt class="o">NULL</tt> byte within <tt>&lt;dest&gt;</tt>,
  so that this value can be reused as an argument for <tt>&lt;pos&gt;</tt>, for the next call of this
  function (and thus concatenating using a linear complexity).

  <p><span class="n">Note</span>: since this function will always scan for a <tt class="o">NULL</tt>
  byte within <tt>&lt;dest&gt;</tt>, this buffer must have its first byte set to <tt class="o">0</tt>
  before the first call of this function.

  <li><tt class="dt">int FindInList(STRPTR list, STRPTR word, int len);</tt>
  <p>This is a quick and not so efficient function to <b>convert a keyword into an integer</b>. <tt>list</tt>
  must be a comma-separated list of words, <tt>word</tt> is the text that will be matched case
  insensitively for each word of the list, <tt>len</tt> is an optional length you want to limit the
  length of the <tt>word</tt>. If given <tt class="o">0</tt> for this parameter, the <tt>word</tt>
  parameter is supposed to be <tt class="o">NULL</tt>-terminated.
  
  <p>Return value will be the index of the n<sup>th</sup> string that the <tt>word</tt> matched, started
  from <tt class="o">0</tt>. If the word did not match anything, <tt class="o">-1</tt> will be returned.

  <p>Here are a few examples of how this function works:
  <ul>
	<li><tt>FindInList(<val>"aaa,aa,a"</val>, <val>"aa"</val>, <val>0</val>);</tt>: will return 1: only whole words are matched.
	<li><tt>FindInList(<val>"STR,URI,POS,INT,COLOR"</val>, <val>"POS POS POS COLOR"</val>, <val>3</val>);</tt>: will return 2: only the
	first 3 characters from the word will be matched against the word list.
  </ul>

  <li><tt class="dt">STRPTR StripCRLF(STRPTR in);</tt>
  <p>Remove newlines from end of string. Will attempt to remove the string <tt class="o">"\n"</tt>,
  <tt class="o">"\r\n"</tt> or <tt class="o">"\r"</tt> from the end. The typical use case is
  to call this function after having retrieved something from <tt>fgets()</tt>.

  <li><tt class="dt">STRPTR NextLine(STRPTR start, Bool cut);</tt>
  <p>Return a pointer to the next line, optionally replacing the newline character(s) by <val>0</val>,
  if <tt>cut</tt> is <val>True</val>. If no end of line has been found, <val>NULL</val>
  will be returned. If you have a text file entirely loaded into memory, you can read it line by line,
  using a code like this:
  <pre><type>STRPTR</type> line, next, file = ReadEntireFile(path);
<kwd>for</kwd> (line = file; line; line = next)
{
	next = NextLine(line, <val>True</val>);

	<com>/* &lt;line&gt; points to a single line of text, and is NULL-terminated */</com>
}</pre>

  <li><tt class="dt">int Split(STRPTR * table, STRPTR str, int max, int chr);</tt>
  <p>Will split <tt>str</tt> at each character <tt>chr</tt> encountered and store the start of each
  string into <tt>table</tt>, which can hold at most <tt>max</tt> items.

  <p>Obviously, <tt>str</tt> must be writable. <tt>chr</tt> only supports ASCII range (ie: values below
  127).

  <p>Returns the number of items written in <tt>table</tt>. If less than <tt>max</tt>, remaining
  items will be set to <val>NULL</val> (but won't be included in final count).

  <li><tt class="dt">int StrCount(STRPTR list, int chr);</tt>
  <p>Counts the occurences of <tt>chr</tt> within <tt>list</tt> (only works with ASCII range).

  <li><tt class="dt">STRDUPA(str)</tt>
  <p>Copy <val>NULL</val>-terminated string <tt>str</tt> onto the stack. If you know you have a small
  string, and don't want to declare an arbitrary large temporary buffer, you can use this macro.
  <p>Obviously that string <b>cannot</b> be used as return value.

</ul>

<h3 class="annex" id="inifile"><span>INI file</span></h3>

<p>INI is a small module to read/write INI configuration file. It is quick way to <b>store/read configuration
parameters</b>. You can roll your own implementation, but this module will spare you that hassle, if your
needs are not too complicated: INI files have mostly a flat structure. You can create sections if you
don't mind adding some extra boilerplate code.

<p>Here is the <b>syntax recognized for keys/values</b>:
<pre><kwd>Key</kwd> = <val>value</val> <com>; comment</com>
<kwd>Key</kwd> = <val>"long value"</val> <com>; possible comment</com></pre>

<p>The key is any string (possibly containing blanks). The value is any character on the right side of
the equal sign. Values can be given enclosed with quotes. If no quotes are present, the value will be
all characters between the first and the last non-blank characters. The following declarations are
identical:

<pre><kwd>Key</kwd> = <val>"this is a long string value"</val> <com>; comment</com>
<kwd>Key</kwd> = <val>this is a long string value</val> <com>; comment</com></pre>

<p>Moreover, INI files <b>can be split into sections</b> (but sections do not nest, though):
<pre><spe>[Section1]</spe>
<kwd>Key1</kwd> = <val>12345</val>
<kwd>Key2</kwd> = <val>3.141592</val>

<spe>[Section2]</spe>
<com>; Despite sharing the same name, you'll be able to retrieve each key independently with this module</com>
<kwd>Key1</kwd> = <val>Section2 Key1 value</val>
<kwd>Key2</kwd> = <val>"Section2 Key2 value"</val></pre>

<p>Here are the functions you can use to manipulate INI files:

<ul>
  <li><tt class="dt">INIFile ParseINI(STRPTR file);</tt>,<br>
	  <tt class="dt">INIFile ParseINIStr(STRPTR buf);</tt>
  <p>Parse an INI file using a UTF-8 encoded path or a memory buffer already having the entire content
  of the file. That buffer must be <val>0</val>-terminated, modifiable and have a lifespan
  that equals at least the INI object.

  <li><tt class="dt">STRPTR GetINIValue(INIFile, STRPTR section);</tt>,<br>
	  <tt class="dt">STRPTR GetINIValueStr(INIFile ini, STRPTR key, STRPTR def);</tt>,<br>
	  <tt class="dt">int    GetINIValueInt(INIFile ini, STRPTR key, int def);</tt>
  <p>Get value value associated to key in the given ini file. Key can preceded by section name,
  separated by /, for example: <tt class="o">"Section1/Key1"</tt>.

  <li><tt class="dt">Bool SetINIValue(STRPTR path, STRPTR key, STRPTR val);</tt>,<br>
	  <tt class="dt">Bool SetINIValueInt(STRPTR path, STRPTR key, int val);</tt>
  <p>These functions will modify value of given key, or add it if it does not exist. "key" can have
  the same syntax than <tt>GetINIValue()</tt>. If the section is also missing, it will be added as well
  (at the end).

  <p>This function will try it's best to do minimal changes to your file, changing only what's required.
  Thus if value has a comment following, it will not be removed, nor altered. Actually if the new value
  is the same than the one currently stored, nothing will be modified at all.

  <p>Notice that this function does not work with INIFile object, but will deal directly with the INI
  file itself.

  <li><tt class="dt">void FreeINI(INIFile);</tt>
  <p>Free memory allocated for parsing the INI file. Keep in mind that if you had kept pointers
  returned by <tt>GetINIValue()</tt>, those pointers are now invalid if you used <tt>ParseINI()</tt>
  to parse the file (otherwise, those pointers will point within the buffer you provided).
</ul>

<h2 class="annex" id="annexB"><span>stb_image API</h2>

<p>Any 3d engine will need at some point to load external image files. If your needs are fairly standard
(8bits RGB or RGBA) textures, you can reuse the image loading capabilities from <tt>nanovg</tt>. These
functions support the following file formats (quoted from stb_image.h):
<ul>
  <li>JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
  <li>PNG 1/2/4/8-bit-per-channel (16 bpc not supported)
  <li>TGA (not sure what subset, if a subset)
  <li>BMP non-1bpp, non-RLE
  <li>PSD (composited view only, no extra channels, 8/16 bit-per-channel)
  <li>GIF (*comp always reports as 4-channel)
  <li>HDR (radiance rgbE format)
  <li>PIC (Softimage PIC)
  <li>PNM (PPM and PGM binary only, ie: P5 or P6)
</ul>

<p>Here are the functions you can use to get image's data from one of these formats:

<pre><type>unsigned char</type> * stbi_load(<type>char const</type> * filename, <type>int</type> *x, <type>int</type> *y, <type>int</type> *comp, <type>int</type> req_comp);
<type>unsigned char</type> * stbi_load_from_memory(<type>unsigned char const</type> * buffer, <type>int</type> len, <type>int</type> *x, <type>int</type> *y, <type>int</type> *comp, <type>int</type> req_comp);
<type>unsigned char</type> * stbi_load_from_file(<type>FILE</type> * f, <type>int</type> *x, <type>int</type> *y, <type>int</type> *comp, <type>int</type> req_comp);
</pre>

<p>These functions all work the same way, only the source of the image differs. These functions
will return the image's data as the return value. The data will have interleaved 8bit channel, using
the order RGBA, without any padding between scanlines. The scanlines will be organized top-down.

<p><tt>x</tt> and <tt>y</tt> will contain the size of the image. <tt>comp</tt> will contain the number
of channel the image has.

<p><tt>req_comp</tt> allows you to force the number of channel returned. It can be assigned to the following
values:
<ul>
  <li>0: try to use the same number of channels than the image. Use <tt>comp</tt>
  parameter, to get how many channels there are in the buffer.
  <li>1: force the image to be grayscale.
  <li>2: grayscale + alpha.
  <li>3: RGB only.
  <li>4: RGBA.
</ul>

<p>Any other value will cause these function to fail. If you forced the number of channel, the value
returned in <tt>comp</tt> will still contain the number of channels that was originally specified in
the image.

<p>If there was an error while decoding the image, <tt class="o">NULL</tt> will be returned.

<h2 class="annex" id="annexC"><span>Advanced rendering API</h2>

<p>At some point, you might want to render graphics on top of <tt>SITGL</tt> elements, outside of the
<tt>SITGL</tt> rendering pipeline (typical use case: render some geometry using your own OpenGL commands).
In order to not overwrite elements, you'll need some help from this library to know when it is safe
to render your graphics.

<h3 class="annex" id="composite"><span>Composited rendering</span></h3>

<p>The first step to achieve this, is to mark elements that will be rendered over (outside of <tt>SITGL</tt>
control) as composited. You do this by assigning a positive integer to the property <tt>SIT_Composited</tt>.
This integer has to be managed on your side. It will be given back when it is safe to render over this
particular area. Consider the following example:

<div class="image">
  <img src="images/SIT_Composited.png">
</div>

<p>Here the grid is actually a single <tt>SIT_CANVAS</tt> widget, where a single cell using an inset
border was copied to give the illusion of a grid like pattern. Inside each cell, graphics were rendered
using OpenGL commands, completely outside of <tt>SITGL</tt> control. On top of all this, a tooltip
(managed by <tt>SITGL</tt>) was finally rendered (if you zoom in this image, you can also see that the
tooltip background is partially transparent). Both have been created this way:

<pre>SIT_CreateWidgets(diag,
	<com>/* some declarations have been removed for clarity */</com>
	<val>"&lt;canvas composited=1 name=tb.inv left=FORM top=WIDGET,player,0.5em/&gt;"
	"&lt;tooltip name=info delayTime="</val>, SITV_TooltipManualTrigger, <val>" displayTime=10000"
	" toolTipAnchor="</val>, SITV_TooltipFollowMouse, <val>">"</val>
);</pre>

<p>Note that the tooltip is not a child of the canvas element: overlapping will take rendering order
and coordinates into account, to be sure that if any element overlaps a composited area, it will be
refreshed at a later time.


<p>This is where the return code of <tt>SIT_RenderNodes()</tt> matters. If it is <tt>SIT_RenderComposite</tt>,
that means you should render the areas marked as ready. This is the typical loop you want to use:

<pre><type>int</type> code = SIT_RenderNodes(FrameGetTime());
<kwd>while</kwd> (code == SIT_RenderComposite)
{
	DATA8 areas;
	<type>int</type>   i;
	SIT_GetValues(app, SIT_CompositedAreas, &amp;areas, <val>NULL</val>);
	for (i = areas[<val>0</val>]; i &gt; <val>0</val>; i --)
	{
		<com>/* refresh widget whose SIT_Composited value is areas[i] */
		/* ... */</com>
	}
	<com>/* note: in composited rendering time parameter is ignored */</com>
	code = SIT_RenderNodes(<val>0</val>);
}
<kwd>if</kwd> (code == SIT_RenderDone)
	SDL_GL_SwapBuffers();
</pre>

<p>This loop can be a bit simplified, if there are only one composited area, or if you 100% sure that
those areas <b>cannot</b> overlap each other:
<pre><kwd>switch</kwd> (SIT_RenderNodes(FrameGetTime())) {
<kwd>case</kwd> SIT_RenderComposite:
	<com>/* refresh required widgets with your own commands */
	/* ... */

	/* required if there are widgets that are overlapping a composited area */</com>
	SIT_RenderNodes(<val>0</val>);
	SDL_GL_SwapBuffers();
	<kwd>break</kwd>;
<kwd>case</kwd> SIT_RenderDone:
	<com>/* refresh required widgets with your own commands */
	/* ... */</com>

	SDL_GL_SwapBuffers();
<kwd>default</kwd>: <kwd>break</kwd>;
}</pre>

<h3 class="annex" id="rendernode"><span>Rendering individual widget</span></h3>

<p>You might also be interested in reusing some of the rendering capabilities of <tt>SITGL</tt>. Sadly,
the low level rendering functions (like border or background) are not exposed in public API, because they
rely heavily on internal datatypes.

<p>You can take advantage of these functions indirectly though: that's the purpose of <tt>SIT_HTMLTAG</tt>
widget type. There are not expected to receive any user input, just to be displayed. By creating them
normally, you'll be able to use all the CSS styling options, be it inline or through the main stylesheet
file.

<p>The important aspect is to <b>create them hidden</b>, by setting the <tt>SIT_Visible</tt> property
to <tt class="o">False</tt>.

<p>Once in a <tt>SITE_OnPaint</tt> callback, you can set their position manually by setting the
properties <tt>SIT_X</tt>, <tt>SIT_Y</tt>, <tt>SIT_Width</tt> and <tt>SIT_Height</tt>. Keep in mind that
the X/Y property will be relative to the parent widget.

<p>Once this is done, you can simply render the node using the following function:
<pre><type>void</type> SIT_RenderNode(SIT_Widget);</pre>

<p>This can be particularly useful, if you want to repeat an element a decent number of times, without
needing to allocate one item for each. Because as far as rendering instructions are concerned, using
an existing item to repeatedly render it over multiple place will be exactly the same as allocating
one item per render.






<h2 class="annex" id="annexD"><span>Border rendering</h2>

<p>This part will describe the algorithm used to handle the CSS <tt>border:</tt> property, because the
code is not particularly clear as how this is achieved, and given how difficult it was getting that
information, being the author of the code <b>and</b> the documentation. The source is located in
<tt>SIT_Render.c:renderBorder()</tt>.

<p>To understand this, you need to have this schema in mind:
<div class="photo">
  <img src="images/schema-border.png">
</div>

<p>The numbers circled in green indicate the order in which each part of the border is rendered: top,
right, bottom, left: which is the standard CSS order. The numbers in blue refer to offset within 2 tables:
<tt>shape</tt> and <tt>inner</tt>. Each indices represent a dimension highlighted in this schema: there
are 16 numbers:
<ul>
  <li>0, 3, 6, 9: horizontal radius of the <tt>border-radius</tt> property.
  <li>1, 4, 7, 10: vertical radius.
  <li>2: width of top horizontal segment, which is outer width minus segment 0 and 3.
  <li>5: height of right vertical segment, which is outer height minus length of segment 4 and 7.
  <li>8, 11: same for bottom/left segment.
  <li>12, 13: top/left screen position where to draw the border.
  <li>14, 15: total width/height of the outer border.
</ul>

<p>Once all those values are extracted, we can <b>push this shape inward</b> by the amount of the border
thickness to get the shape of the inner border. Of course, if one of the number becomes negative, it
will be clamped to 0. That simple trick is what allows to handle nearly all use cases, including
degenerate cases with variable/null border width and/or weird rounded corner values.

<p>At this point, <b>we could draw each part (left, top, right, bottom) of the border individually</b>,
using a bunch of arcs and lines to draw a polygon and filling it with whatever color was specified for
this segment. Sadly, due to the way anti-aliasing works, the result will not look so good, especially
if the border color is uniform (which, admittedly, happens quite often):

<div class="photo">
  <img src="images/border-0width.png">
</div>

<p><span class="n">Note</span>: this image has been enlarged 3 times, without interpolation. You can see
there are <b>faint lines</b> that shows how the border was split during the rendering phase. It doesn't
look that bad, but once you see them, they stand out like a sore thumb. This is a problem inherent to
anti-aliasing: when you have 2 polygons that share an edge, it is difficult to not let the background
color bleeds between the edge.

<p>The only way to <b>prevent this, is to render the border as one polygon</b>. Sadly <tt>nanovg</tt>
has another limitation: you need to avoid 0-width path. Otherwise, you could just create a bunch of
paths for each part of the border that have identical styles, and issue a single fill command. Doing
so, you'll need a vector drawing library that knows how to handle 0-width path (ie: merge polygon,
which is not trivial).

<p>This is the purpose of the <tt>merge</tt> variable in the <tt>renderBorder()</tt> function: it
encodes the borders to draw and borders that have been drawn, using a bitfield. The first 8bit encodes
the border parts to draw as a single polygon (assuming they have the same style). The parts are encoded
using the CSS order: bit1 is top border, bit2 is right, bit3 is bottom and bit4 is left. Bit4 to 7 are
actually a copy of bit0 to 3. This is a cheap trick to avoid doing complicated bit rotation: if we want
to know if the next border segment is drawn in the same pass, we just have to test the next bit.

<p>Bit8 to 11 encodes borders that have been drawn, therefore these parts must be skipped no matter what.
Inlines with borders can be split, that's why the <tt>merge</tt> variable is set to the reverse
bitfield of the border to draw (<tt>flags</tt> parameter to <tt>renderBorder()</tt>). For block elements,
this parameter will always be 15 (ie: draw all border parts).

<p>While checking which borders are contiguous, we only want parts that form a single border: if the
top and bottom parts use the same style (but left and right use something different), the two borders
will still be rendered individually because they do not form a single polygon. This is the purpose of
this test:
<pre><kwd>if</kwd> (b->color.val == <val>0</val> || (&amp;borders.top)[j] &lt;= <val>0</val> || (merge &amp; (<val>0x100</val>&lt;&lt;j)) || (merge &amp; (<val>5</val><<(j-<val>1</val>))) == <val>0</val>)
	<kwd>continue</kwd>;</pre>

<p>This test is divided into 4 parts:
<ol>
  <li>Check if the border part is completely transparent, in which case there is no point in rendering anything.
  <li>Check if the border width is 0, in which case there will be nothing to render.
  <li>Check if the border part has already been rendered.
  <li>Check if the border <b>before or after</b> the current part (<tt>j</tt>) is part of the merge.
  If neither of these are, it means the current part will form a standalone polygon. Technically, <tt>nanovg</tt>
  can render this, the problem is issuing the right path drawing commands to achieve this (which current
  code base does not support at all).

  <p>This is where duplicating the bitfield helps a little bit: we can check if left border part (<tt>j == <val>3</val></tt>)
  has to be rendered with top border part (<tt>j == <val>0</val></tt>) simply by looking at bit4. No
  need to do any bit rotation.
</ol>

<p>Once we know which border parts need to be rendered at once, time to issue the drawing commands.
First, the inner part of the border path is rendered in counter-clockwise order, then the outer path
is done in clockwise order. At the start and at the end of the path, if there is a border-radius at
this location, the arc needs to span 45&deg;, otherwise, in the middle of the loop, it will span
90&deg;.

<p>At this point, it is a lot of tedious house-keeping, but hopefully the code should be more straightforward
as to what it is doing.

</div>
</body>
</html>
